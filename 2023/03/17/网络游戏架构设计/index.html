

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="ysich">
  <meta name="keywords" content="">
  
    <meta name="description" content="网络游戏架构设计第一节 代码结构项目代码结构需要满足的需求热更新需要把Unity的MonoBehaviour等等这些和Unity交互较深的脚本进行分离 至少有一个热更新的程序集 数据跟方法分离，热重载热重载​	热重载只是数据跟方法分离后得到的好处 ​	热重载便于改bug，节省重现环节。 数据跟方法分离​	在C语言中叫做data + function的设计。数据就是定义数据结构，方法则是面向过程的方">
<meta property="og:type" content="article">
<meta property="og:title" content="网络游戏架构设计">
<meta property="og:url" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/index.html">
<meta property="og:site_name" content="ysich&#39;Blog">
<meta property="og:description" content="网络游戏架构设计第一节 代码结构项目代码结构需要满足的需求热更新需要把Unity的MonoBehaviour等等这些和Unity交互较深的脚本进行分离 至少有一个热更新的程序集 数据跟方法分离，热重载热重载​	热重载只是数据跟方法分离后得到的好处 ​	热重载便于改bug，节省重现环节。 数据跟方法分离​	在C语言中叫做data + function的设计。数据就是定义数据结构，方法则是面向过程的方">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230308124513.png">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230308124518-1678250733684.jpg">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230308123835.jpg">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230308123804-1678250496566.jpg">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230308005444.jpg">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230308233904030.png">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230314225046861.png">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230314225755691.png">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230314230323393.png">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230314232242465.png">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230314232906957.png">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230314232915651.png">
<meta property="article:published_time" content="2023-03-17T06:07:03.000Z">
<meta property="article:modified_time" content="2023-03-17T06:09:19.444Z">
<meta property="article:author" content="ysich">
<meta property="article:tag" content="Manager 框架 ET框架">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230308124513.png">
  
  
  
  <title>网络游戏架构设计 - ysich&#39;Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"ysich.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  



  
<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>三十六分热</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="网络游戏架构设计"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-03-17 14:07" pubdate>
          2023年3月17日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          11k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          91 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">网络游戏架构设计</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="网络游戏架构设计"><a href="#网络游戏架构设计" class="headerlink" title="网络游戏架构设计"></a>网络游戏架构设计</h1><h2 id="第一节-代码结构"><a href="#第一节-代码结构" class="headerlink" title="第一节 代码结构"></a>第一节 代码结构</h2><h3 id="项目代码结构需要满足的需求"><a href="#项目代码结构需要满足的需求" class="headerlink" title="项目代码结构需要满足的需求"></a>项目代码结构需要满足的需求</h3><h4 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h4><p>需要把Unity的MonoBehaviour等等这些和Unity交互较深的脚本进行分离</p>
<p>至少有一个热更新的程序集</p>
<h4 id="数据跟方法分离，热重载"><a href="#数据跟方法分离，热重载" class="headerlink" title="数据跟方法分离，热重载"></a>数据跟方法分离，热重载</h4><h5 id="热重载"><a href="#热重载" class="headerlink" title="热重载"></a>热重载</h5><p>​	热重载只是数据跟方法分离后得到的好处</p>
<p>​	热重载便于改bug，节省重现环节。</p>
<h5 id="数据跟方法分离"><a href="#数据跟方法分离" class="headerlink" title="数据跟方法分离"></a>数据跟方法分离</h5><p>​	在C语言中叫做<code>data + function</code>的设计。数据就是定义数据结构，方法则是面向过程的方法。</p>
<p>​	相比于面向对象而已没有类与类之间的关联，只有方法和方法的关联，便于重构。</p>
<h4 id="逻辑跟表现分离"><a href="#逻辑跟表现分离" class="headerlink" title="逻辑跟表现分离"></a>逻辑跟表现分离</h4><p>数据是同步的，而表现可能是异步的情况。在表现过程中可能会有一些资源加载的操作，在这个过程中逻辑发生了变化，表现也需要发生变化。</p>
<p>预表现。表现层可能提前做出一些表现比如一些战斗前摇，但是对逻辑层没有什么影响。等逻辑层同步了命中逻辑后，再播放命中的表现。</p>
<p>在MMO的切换场景中，服务器通知场景切换后，客户端逻辑层加载数据，表现层则在数据加载完成后开始异步加载场景。服务器再通知单位模型的数据后，客户端逻辑层整理数据后，表现成开始异步加载单位模型。</p>
<p>帧同步。帧同步两端的逻辑层的逻辑是一样的。而状态同步逻辑在服务端，两端的逻辑层实际上也是一样的。区别只在于一个是客户端计算一个是服务端计算。 帧同步如果把逻辑层看做是一个服务端，看起来就像是逻辑层在给表现层发消息。逻辑是离散的，表现是要做插值的。</p>
<h4 id="ECS数据驱动"><a href="#ECS数据驱动" class="headerlink" title="ECS数据驱动"></a>ECS数据驱动</h4><p>数据变化是通过事件通知的。逻辑和表现监听事件产生变化。</p>
<h3 id="ET版本变更"><a href="#ET版本变更" class="headerlink" title="ET版本变更"></a>ET版本变更</h3><h4 id="1-0"><a href="#1-0" class="headerlink" title="1.0"></a>1.0</h4><p>客户端</p>
<ul>
<li>Hoxfix 热更层</li>
<li>Main 主工程</li>
</ul>
<p>服务端</p>
<ul>
<li>Hoxfix 纯逻辑</li>
<li>Main 纯数据</li>
</ul>
<h4 id="中间版本"><a href="#中间版本" class="headerlink" title="中间版本"></a>中间版本</h4><p>客户端 </p>
<p>asmdef功能，多个程序集提升编译速度</p>
<ul>
<li>Hoxfix	热更层</li>
<li>Loader 游戏入口，可放Unity脚本</li>
<li>Core 框架核心</li>
<li>ThirdParty 第三方库</li>
</ul>
<p>服务端</p>
<ul>
<li>Hoxfix</li>
<li>Model</li>
<li>Loader</li>
<li>Core</li>
<li>ThirdParty</li>
</ul>
<h4 id="热重载需求"><a href="#热重载需求" class="headerlink" title="热重载需求"></a>热重载需求</h4><p>客户端</p>
<ul>
<li>Hoxfix 热更层的逻辑层  <ul>
<li>纯逻辑改变时不用关闭游戏，直接重载这个程序集</li>
</ul>
</li>
<li>Model 热更层的数据层</li>
<li>Loader 游戏入口，可放Unity脚本</li>
<li>Core 框架核心</li>
<li>ThirdParty 第三方库</li>
</ul>
<h4 id="另一种划分"><a href="#另一种划分" class="headerlink" title="另一种划分"></a>另一种划分</h4><ul>
<li>HoxfixView 表现层</li>
<li>Hoxfix 逻辑层 抛事件通知表现层</li>
<li>Loader</li>
<li>ThridParty</li>
<li>Core</li>
</ul>
<h4 id="结合前面两个版本"><a href="#结合前面两个版本" class="headerlink" title="结合前面两个版本"></a>结合前面两个版本</h4><h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><ul>
<li>HoxfixView 表现层的方法</li>
<li>ModelView 表现层数据结构</li>
<li>Hofix 逻辑层方法</li>
<li>Model 逻辑层数据</li>
<li>Loader</li>
<li>Core</li>
<li>ThridParty</li>
</ul>
<p>前四个程序集编译在一起做热更新。HofixView和Hofix编译在一起做热重载。</p>
<p>并且逻辑和表现分离</p>
<h5 id="Robot"><a href="#Robot" class="headerlink" title="Robot"></a>Robot</h5><ul>
<li>Hofix 逻辑层方法</li>
<li>Model 逻辑层数据</li>
<li>Loader</li>
<li>Core</li>
<li>ThridParty</li>
</ul>
<p>去掉客户端的表现层，就是机器人的程序集了。</p>
<p>Hofix和Model共用客户端的程序集。</p>
<h2 id="第二节-All-In-One"><a href="#第二节-All-In-One" class="headerlink" title="第二节 All In One"></a>第二节 All In One</h2><h3 id="各类服务器进程合并"><a href="#各类服务器进程合并" class="headerlink" title="各类服务器进程合并"></a>各类服务器进程合并</h3><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230308124513.png" srcset="/img/loading.gif" lazyload alt="微信图片_20230308124513"></p>
<p>很多多进程的设计，都把一个服务整理成一个exe。多个服务就有多个exe，代码可能是高度相似的，或者基本一样的。只是启动时环境变量不同。合并成一个exe并设置环境变量。</p>
<ul>
<li>发布部署简单、配置资源方便、多种服务共用进程。</li>
<li>结构调整容易，比如两种或多种服务要合并，拆分<ul>
<li>多个exe会有多个进程，当其中一部分逻辑压力过大时（比如一个中心服有好友和组队功能，好友功能压力过大时 ）不好拆分，需要再拆成多个exe。</li>
<li>无限增加app类型，千古风流有几十种SceneType</li>
<li>根据配置需要什么服务，就配置什么类型。多个服务配置在一个进程内。</li>
</ul>
</li>
</ul>
<h3 id="后端和机器人合并"><a href="#后端和机器人合并" class="headerlink" title="后端和机器人合并"></a>后端和机器人合并</h3><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230308124518-1678250733684.jpg" srcset="/img/loading.gif" lazyload alt="微信图片_20230308124518"></p>
<p>机器人和服务器的代码基本一样。也引用了大部分的后端代码。还引用了客户端的逻辑代码。代码引用很乱。</p>
<p>机器人要单独起一个exe很不方便，跑测试需要起两个进程。</p>
<h4 id="server和机器人合并带来的问题"><a href="#server和机器人合并带来的问题" class="headerlink" title="server和机器人合并带来的问题"></a>server和机器人合并带来的问题</h4><ul>
<li>代码类重名<ul>
<li>合并后分别引用了客户端和服务端的代码。两端代码的类名重名（item、buff）。</li>
<li>用命名空间隔离解决重名冲突，带来的好处只需要检查目录下的命名空间就能保证不会调用到错误的代码。</li>
<li>ET.Server、ET.Client</li>
</ul>
</li>
<li>事件订阅怎么区分前后端<ul>
<li>有些工具类，或数值组件这种两端共用的代码就不用隔离。ET</li>
<li>比如单位组件，前后端都有抛出的事件很难做区分。需要区分订阅。</li>
<li>通过场景类型做区分SceneType</li>
</ul>
</li>
<li>配置文件结构不同怎么共享<ul>
<li>问题也不大，大不了两端配置都存在。</li>
</ul>
</li>
</ul>
<p>机器人在写组队逻辑时很有用。</p>
<h3 id="前端跟后端合并"><a href="#前端跟后端合并" class="headerlink" title="前端跟后端合并"></a>前端跟后端合并</h3><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230308123835.jpg" srcset="/img/loading.gif" lazyload alt="微信图片_20230308123835"></p>
<h4 id="不需要单独起服务端，前后端代码共享更方便"><a href="#不需要单独起服务端，前后端代码共享更方便" class="headerlink" title="不需要单独起服务端，前后端代码共享更方便"></a>不需要单独起服务端，前后端代码共享更方便</h4><p>不需要单独启动服务器，unity一启动就启动前后端代码。</p>
<p>前后端代码的共享，前端可以包含一个服务器，后端可以包含前端的逻辑做个机器人。</p>
<h4 id="后端可以更方便做Unity可视化工具，可视化树ENABLE-VIEW"><a href="#后端可以更方便做Unity可视化工具，可视化树ENABLE-VIEW" class="headerlink" title="后端可以更方便做Unity可视化工具，可视化树ENABLE_VIEW"></a>后端可以更方便做Unity可视化工具，可视化树ENABLE_VIEW</h4><p>后端如果是命令行程序，做数据可视化很困难。</p>
<p>写后端就像写前端一样简单，比如写个行为树，后端可以直接调试，前端可以直接拿到后端数据。</p>
<p>ET7加上ENABLE_VIEW宏开启可视化树</p>
<h4 id="更方便做插件机制"><a href="#更方便做插件机制" class="headerlink" title="更方便做插件机制"></a>更方便做插件机制</h4><p>用unity的导入导出做插件机制。</p>
<h4 id="各种游戏代码合并的需求分析"><a href="#各种游戏代码合并的需求分析" class="headerlink" title="各种游戏代码合并的需求分析"></a>各种游戏代码合并的需求分析</h4><h5 id="竞技游戏"><a href="#竞技游戏" class="headerlink" title="竞技游戏"></a>竞技游戏</h5><p>比如守望先锋，用的状态帧同步。本地先预测下一帧行为，服务器同步下来如果结果不符合则进行回滚。那么两端肯定有相同代码，否则产生结果肯定是不一致的。</p>
<h5 id="MMO游戏、MOBA游戏"><a href="#MMO游戏、MOBA游戏" class="headerlink" title="MMO游戏、MOBA游戏"></a>MMO游戏、MOBA游戏</h5><p>模拟机器人的需求，充当普通玩家。</p>
<p>机器人压测需求。</p>
<h5 id="状态同步"><a href="#状态同步" class="headerlink" title="状态同步"></a>状态同步</h5><p>客户端预测和服务器权威数据跑的代码基本一致。</p>
<h5 id="帧同步"><a href="#帧同步" class="headerlink" title="帧同步"></a>帧同步</h5><p>逻辑都在客户端，但是在结算结果的时候数据不权威。后期帧同步，很多是依靠服务器也跑一份逻辑，根据跑出来的结果判定结算。也是防作弊很重要的内容。</p>
<h3 id="前端和后端合并的细节问题"><a href="#前端和后端合并的细节问题" class="headerlink" title="前端和后端合并的细节问题"></a>前端和后端合并的细节问题</h3><h4 id="怎么区分编译前端代码跟后端代码，还有双端编译"><a href="#怎么区分编译前端代码跟后端代码，还有双端编译" class="headerlink" title="怎么区分编译前端代码跟后端代码，还有双端编译"></a>怎么区分编译前端代码跟后端代码，还有双端编译</h4><p>搞一个编译工具，按照需求选择编译</p>
<h4 id="配置要区分前端跟后端，以及双端，configpatial的处理"><a href="#配置要区分前端跟后端，以及双端，configpatial的处理" class="headerlink" title="配置要区分前端跟后端，以及双端，configpatial的处理"></a>配置要区分前端跟后端，以及双端，configpatial的处理</h4><p>有些配置不需要双端都知道的，比如前端的特效，或后端比较权威计算的数值。</p>
<p>这就需要导出三份配置。C、CS、S</p>
<p>config patial就是把配置反序列化成需要的类对象的工具</p>
<p>config patial不能共享，需要写三份。</p>
<p>消息要区分前后端，以及双端。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230308123804-1678250496566.jpg" srcset="/img/loading.gif" lazyload alt="微信图片_20230308123804"></p>
<p>把服务器逻辑代码也写在客户端程序集内，直接引用。</p>
<p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230308005444.jpg" srcset="/img/loading.gif" lazyload alt="微信图片_20230308005444"></p>
<h2 id="第三节-单间管理器"><a href="#第三节-单间管理器" class="headerlink" title="第三节 单间管理器"></a>第三节 单间管理器</h2><h3 id="为什么需要单间管理器？"><a href="#为什么需要单间管理器？" class="headerlink" title="为什么需要单间管理器？"></a>为什么需要单间管理器？</h3><h4 id="统一管理单间类。单间类的问题？"><a href="#统一管理单间类。单间类的问题？" class="headerlink" title="统一管理单间类。单间类的问题？"></a>统一管理单间类。单间类的问题？</h4><p>单间类生命周期的问题，创建了什么时候释放的问题。</p>
<p>内存随着生命周期清理的问题。</p>
<h4 id="统一管理基础库，灵活引入基础库"><a href="#统一管理基础库，灵活引入基础库" class="headerlink" title="统一管理基础库，灵活引入基础库"></a>统一管理基础库，灵活引入基础库</h4><h4 id="消除静态字段"><a href="#消除静态字段" class="headerlink" title="消除静态字段"></a>消除静态字段</h4><p><code>static Dictionary</code>这种静态变量，生命周期清理的问题。</p>
<h4 id="Unity-domain模式"><a href="#Unity-domain模式" class="headerlink" title="Unity domain模式"></a>Unity domain模式</h4><p>domain模式为了提升性能不清理静态字段，需要自己清理。</p>
<h4 id="为什么不用组件？"><a href="#为什么不用组件？" class="headerlink" title="为什么不用组件？"></a>为什么不用组件？</h4><p>组件本身需要一些额外的东西，比如创建的时候需要对象池。对象池又是谁管理。就可以使用单间管理器创建对象池。</p>
<h4 id="为什么用Game-AddSingleton-创建单间"><a href="#为什么用Game-AddSingleton-创建单间" class="headerlink" title="为什么用Game.AddSingleton 创建单间"></a>为什么用Game.AddSingleton 创建单间</h4><p><code>Game.AddSingleton&lt;TimeInfo&gt;();</code></p>
<h5 id="代码可读性，明确知道单间初始化的地方。"><a href="#代码可读性，明确知道单间初始化的地方。" class="headerlink" title="代码可读性，明确知道单间初始化的地方。"></a>代码可读性，明确知道单间初始化的地方。</h5><p>如果都是<code>Instance</code>很难找到哪里是初始化的地方。</p>
<h5 id="明确知道初始化顺序，方便调整"><a href="#明确知道初始化顺序，方便调整" class="headerlink" title="明确知道初始化顺序，方便调整"></a>明确知道初始化顺序，方便调整</h5><h5 id="好释放，相反的顺序释放"><a href="#好释放，相反的顺序释放" class="headerlink" title="好释放，相反的顺序释放"></a>好释放，相反的顺序释放</h5><p>明确知道了初始化顺序，能更明确释放的顺序。</p>
<figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ISingleton</span>: <span class="hljs-title">IDisposable</span><br>{<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Register</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Destroy</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">IsDisposed</span>()</span>;<br>}<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>&lt;<span class="hljs-title">T</span>&gt;: <span class="hljs-title">ISingleton</span> <span class="hljs-keyword">where</span> <span class="hljs-title">T</span>: <span class="hljs-title">Singleton</span>&lt;<span class="hljs-title">T</span>&gt;, <span class="hljs-title">new</span>(){<br><br>}<br></code></pre></td></tr></tbody></table></figure>

<h5 id="通过接口创建生命周期"><a href="#通过接口创建生命周期" class="headerlink" title="通过接口创建生命周期"></a>通过接口创建生命周期</h5><p><code>ISingletonAwake</code> 、<code>ISingletonUpdate</code> 、<code>ISingletonLateUpdate</code></p>
<p><code>AddSingleton</code>时判断是否有生命周期接口，如果有添加对应生命周期。</p>
<figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddSingleton</span>(<span class="hljs-params">ISingleton singleton</span>)</span><br>{<br>    Type singletonType = singleton.GetType();<br>    <span class="hljs-keyword">if</span> (singletonTypes.ContainsKey(singletonType))<br>    {<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">$"already exist singleton: <span class="hljs-subst">{singletonType.Name}</span>"</span>);<br>    }<br><br>    singletonTypes.Add(singletonType, singleton);<br>    <span class="hljs-comment">//管理单间加载顺序，做卸载时可用</span><br>    singletons.Push(singleton);<br><br>    singleton.Register();<br><br>    <span class="hljs-keyword">if</span> (singleton <span class="hljs-keyword">is</span> ISingletonAwake awake)<br>    {<br>        awake.Awake();<br>    }<br><br>    <span class="hljs-keyword">if</span> (singleton <span class="hljs-keyword">is</span> ISingletonUpdate)<br>    {<br>        updates.Enqueue(singleton);<br>    }<br><br>    <span class="hljs-keyword">if</span> (singleton <span class="hljs-keyword">is</span> ISingletonLateUpdate)<br>    {<br>        lateUpdates.Enqueue(singleton);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<h2 id="第四节-多线程、单线程、Task-await-async的关系"><a href="#第四节-多线程、单线程、Task-await-async的关系" class="headerlink" title="第四节 多线程、单线程、Task await async的关系"></a>第四节 多线程、单线程、Task await async的关系</h2><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>使用多线程去执行复杂逻辑时，callback会在执行线程继续执行进行响应。</p>
<p>比如寻路的逻辑比较复杂抛给其他线程去处理，响应回调时也是会在寻路线程进行响应。</p>
<p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230308233904030.png" srcset="/img/loading.gif" lazyload alt="image-20230308233904030"></p>
<h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><p>当遇到框架内的api都是单线程的api时，必须在主线程完成回调。在其他线程响应回调会导致线程竞争。</p>
<p>解决方法也很简单，在其他线程响应回调时把回调放到一个缓存队列中（需要同步上下文），在主线程的update里不断去取缓存队列中的响应，并去执行它。就能把回调丢回到主线程执行。(C++中的没有task而使用的手法)</p>
<p>详情看看MainThreadSynchronizationContext这个类</p>
<h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><p>线程消耗比较大，创建的时候一般都使用线程池。Task就是线程池封装的结果。</p>
<p>Task 执行的线程和响应回调的线程不一致，回调的响应会丢到其他线程执行。</p>
<p>Task本质就是个状态机，当设置了同步上下文时，回调会被自动调整到主线程执行。 编译器帮我们做了这一步</p>
<figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StartTask</span>()</span>{<br>	SynchronizationContext synchronizationContext = SynchronizationContext.Current;<br>    <span class="hljs-keyword">await</span> Task.Run(FindPath);<br>    <span class="hljs-keyword">if</span>(synchronizationContext == <span class="hljs-literal">null</span>){<br>        <span class="hljs-comment">//没设置同步上下文会在当前线程响应。</span><br>        SendMessage();<br>    }<span class="hljs-keyword">else</span>{<br>        <span class="hljs-comment">//设置了同步上下文实际会在设置的线程响应。</span><br>        synchronizationContext.post(()=&gt;{<br>            SendMessage();<br>        },<span class="hljs-literal">null</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<h3 id="自己实现个TaskRun"><a href="#自己实现个TaskRun" class="headerlink" title="自己实现个TaskRun"></a>自己实现个TaskRun</h3><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Run</span>(<span class="hljs-params">Action action</span>)</span><br>        {<br>            TaskCompletionSource tcs = <span class="hljs-keyword">new</span> TaskCompletionSource();<br>            ThreadPool.QueueUserWorkItem((_) =&gt;<br>            {<br>                action.Invoke();<br>                tcs.SetResult();<br>            });<br>            <span class="hljs-keyword">await</span> tcs.Task;<br>        }<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StartTask</span>()</span>{<br>    <span class="hljs-keyword">await</span> Run(FindPath);<br>    <span class="hljs-comment">//这里把回调和多线程的调用放在同个方法执行</span><br>    SendMessage();<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>使用<code>Task.Factory.StartNew</code>创建可以自由调度的线程</p>
<figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StartTask</span>()</span><br>       {<br>    <span class="hljs-comment">//MyTaskScheduler是自己实现的线程调度器</span><br>           <span class="hljs-keyword">await</span> Task.Factory.StartNew(FindPath,<span class="hljs-keyword">new</span> CancellationToken(),TaskCreationOptions.None,<span class="hljs-keyword">new</span> MyTaskScheduler());<br>       }<br></code></pre></td></tr></tbody></table></figure>

<h3 id="自定义线程调度器"><a href="#自定义线程调度器" class="headerlink" title="自定义线程调度器"></a>自定义线程调度器</h3><p>继承<code>TaskScheduler</code>实现自己的线程调度器</p>
<figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyTaskScheduler</span>:<span class="hljs-title">TaskScheduler</span><br>        {<br>            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> IEnumerable&lt;Task&gt; <span class="hljs-title">GetScheduledTasks</span>()</span><br>            {<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            }<br><br>            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">QueueTask</span>(<span class="hljs-params">Task task</span>)</span><br>            {<br>                <span class="hljs-comment">//执行完回收到线程池</span><br>                ThreadPool.QueueUserWorkItem((_) =&gt; TryExecuteTask(task));<br>            }<br><br>            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">TryExecuteTaskInline</span>(<span class="hljs-params">Task task, <span class="hljs-built_in">bool</span> taskWasPreviouslyQueued</span>)</span><br>            {<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException();<br>            }<br>        }<br></code></pre></td></tr></tbody></table></figure>



<h2 id="第五节-ETTask"><a href="#第五节-ETTask" class="headerlink" title="第五节 ETTask"></a>第五节 ETTask</h2><h3 id="回调地狱-Callback-Hell"><a href="#回调地狱-Callback-Hell" class="headerlink" title="回调地狱 Callback Hell"></a>回调地狱 Callback Hell</h3><p>Task主要是为了解决回调地狱 </p>
<p>在没有协程和await之前，cpp主要靠函数对象模拟Lambda。 </p>
<p>后续谷歌推出NewCallback</p>
<p>C# 5.0 推出了 await async 关键字</p>
<p>await难以维护的操作<code>while await</code>，await all 所有任务才执行回调。</p>
<p>go python js ts cpp后续也推出了await关键字，但是go的await不完善，是通过线程的方式去执行。比如玩家有的操作是需要单线程等待一段事件再执行的，回调则会执行在其他线程中。而好的设计则应该是只把回调拉直，而不关心你后续实现是在多线程还是单线程。</p>
<h3 id="回调转成Task"><a href="#回调转成Task" class="headerlink" title="回调转成Task"></a>回调转成Task</h3><p><code>TaskCompleteSource</code></p>
<figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> ETTask <span class="hljs-title">FindPath</span>()</span>{<br>    TaskCompletionSource tcs = TaskCompletionSource();<br>    ThreadPool.QueueUserWorkItem( state=&gt;{<br>       Consle.WriteLine(<span class="hljs-string">"FindPATH"</span>);<br>        tcs.SetResult();<br>    });<br>    <span class="hljs-keyword">await</span> tcs.Task;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p><code>CancellationTokenSource</code> await的取消操作</p>
<p>传入token，通过token状态来判断后续代码是否执行。 </p>
<h3 id="ETTask的好处"><a href="#ETTask的好处" class="headerlink" title="ETTask的好处"></a>ETTask的好处</h3><p>生成代码极简，去除了多线程的支持，性能最好。</p>
<p>对象池消除了Task GC</p>
<p><code>TaskCompleteSource</code>和<code>CancellationTokenSource</code>这两个类比较庞大并且没有入池，gc问题比较严重。</p>
<p>去掉了ETVoid </p>
<p>ETVoid对应 async void。任何异步都返回ETTask。不需要等待则直接Coroutine。操作简单。</p>
<h3 id="线程取消"><a href="#线程取消" class="headerlink" title="线程取消"></a>线程取消</h3><ul>
<li><p>超级简单的ETCancelToken</p>
<p>ETCancelToken替换<code>CancellationTokenSource</code></p>
</li>
<li><p>协程取消判断</p>
<figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">if</span>(cancellationToken.IsCancel()){<br>	Console.WriteLine(<span class="hljs-string">"Start cancel"</span>);<br>	<span class="hljs-keyword">return</span>;<br>}<br>Console.WriteLine(<span class="hljs-string">"Start finish"</span>);<br></code></pre></td></tr></tbody></table></figure>

<p>在ETTask中判断ETCanelToken是否取消然后继续执行后面操作。而Task在取消后则抛出异常。</p>
</li>
<li><p>ETCancelToken取消多个协程</p>
<p>多个ETTask判断同一个ETCancelToken</p>
</li>
<li><p>ETCancelToken的必要性</p>
<p>尽可能设计一个await的取消方式，否则后续维护扩展非常困难。</p>
</li>
</ul>
<h3 id="awaitable"><a href="#awaitable" class="headerlink" title="awaitable"></a>awaitable</h3><h4 id="GetAwaiter"><a href="#GetAwaiter" class="headerlink" title="GetAwaiter"></a>GetAwaiter</h4><p>c#提供的<code>GetAwaiter</code>的机制，只要对象有一个成员方法或者静态方法名为<code>GetAwaiter</code>，就可以使用await的语法。</p>
<h4 id="Unity-yield转换"><a href="#Unity-yield转换" class="headerlink" title="Unity yield转换"></a>Unity yield转换</h4><p>本质上也是回调操作，把yield用await的形式更加简单。</p>
<figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//unity中yield都会返回AsyncOperation的子类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> ETTask <span class="hljs-title">GetAwaiter</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> AsyncOperation asyncOperation</span>)</span>{<br>    ETTask task = ETTask.Create(<span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">//SetResult执行后会回到await后的操作。</span><br>    asyncOperation.completed += _=&gt;{ task.SetResult();};<br>    <span class="hljs-keyword">await</span> task;<br>}<br></code></pre></td></tr></tbody></table></figure>

<figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> ETTask&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">HttpGet</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> link</span>)</span>{<br>    <span class="hljs-keyword">try</span>{<br>        UnityWedRequest req = UnityWebRequest.Get(link);<br>        <span class="hljs-comment">//req.SendWebRequest()会返回UnityWebRequestAsyncOperation，继承于AsyncOperation</span><br>        <span class="hljs-keyword">await</span> req.SendWebRequest();<br>        <span class="hljs-keyword">return</span> req.downloadHandler.text;<br>	}<br>    <span class="hljs-keyword">catch</span>{<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<h2 id="第五节-2-ETTask源码分析"><a href="#第五节-2-ETTask源码分析" class="headerlink" title="第五节 -2 ETTask源码分析"></a>第五节 -2 ETTask源码分析</h2><p>用反编译工具<code>.NET Reflector</code>查看ETTask实现。</p>
<p>这里需要反复看生成概念。</p>
<p>本质上是基于状态机的实现，执行时通过判断ETTaskCompleted的值来判断是否走到后面的逻辑，如果需要等待则将状态机的<code>MoveNext</code>方法传到ETTask的CallBack中。通过状态机的状态变化继续后面的逻辑。 ETTask的<code>SetResult</code>操作会触发回调，执行状态机的<code>MoveNext</code>。</p>
<p>实际上是把await前的代码和await后的操作，各放在一个状态中，通过状态机切换来执行。保证了上下文的统一。</p>
<p>多个await会生成多个状态机</p>
<h4 id="ETTask"><a href="#ETTask" class="headerlink" title="ETTask"></a>ETTask</h4><p>只要用了<code>ettask.Coroutine()</code>在编译后会生成一个<code>ETAsyncTaskMethodBuilder.Create()</code></p>
<h4 id="ETAsyncTaskMethodBuilder"><a href="#ETAsyncTaskMethodBuilder" class="headerlink" title="ETAsyncTaskMethodBuilder"></a>ETAsyncTaskMethodBuilder</h4><p>struct类型，包含一个ETTask。</p>
<p>在方法执行了Coroutine编译后会对应生成一个相对的struct，继承于<code>IAsyncStateMachine</code>。生成一个状态机，根据state参数执行相对应阶段的代码。</p>
<h4 id="ETVoid"><a href="#ETVoid" class="headerlink" title="ETVoid"></a>ETVoid</h4><h4 id="ETAsyncVoidMethodBuilder"><a href="#ETAsyncVoidMethodBuilder" class="headerlink" title="ETAsyncVoidMethodBuilder"></a>ETAsyncVoidMethodBuilder</h4><h4 id="ETTaskCompleted"><a href="#ETTaskCompleted" class="headerlink" title="ETTaskCompleted"></a>ETTaskCompleted</h4><p>返回完成状态，基本是true</p>
<h4 id="ETAsyncTaskCompletedMethodBuilder"><a href="#ETAsyncTaskCompletedMethodBuilder" class="headerlink" title="ETAsyncTaskCompletedMethodBuilder"></a>ETAsyncTaskCompletedMethodBuilder</h4><h3 id="协程的使用"><a href="#协程的使用" class="headerlink" title="协程的使用"></a>协程的使用</h3><p>用协程简化工作流程。</p>
<p><code>int result = await OpenBox();</code>弹窗时返回点击按钮的type做相应的判断，简化在窗口里写逻辑，逻辑上更清晰。(有点像VB的弹窗返回值</p>
<p> <code>await MoveTo();</code></p>
<p><code>await ChangeScene();</code> 切换场景的操作写成一个方法，await后执行切换场景完成后的代码。</p>
<p><code>await CastSpell();</code> 释放技能，技能成功或失败后的操作。比如失败时使用道具，成功后捡道具。如果用事件则会变得很复杂。 </p>
<p>熊猫哥举了个例子，比如自动寻路时，需要通过几个场景的传送门才能到达最终场景。先把场景选出来，给每个场景写一个最短路径的寻路方法。根据读配置去执行相应的寻路方法。只需要通过一个while循环就能到达最终目标位置。</p>
<p>把逻辑异步化后，逻辑更清晰，只需要对内容进行封装抽象不需要再关心后续的逻辑了。</p>
<h2 id="第六节-计时器"><a href="#第六节-计时器" class="headerlink" title="第六节 计时器"></a>第六节 计时器</h2><p><code>TimerComponent</code></p>
<h3 id="需求场景"><a href="#需求场景" class="headerlink" title="需求场景"></a>需求场景</h3><ul>
<li>UI倒计时</li>
<li>网络超时</li>
<li>技能释放</li>
<li>buff超时删除，定时事件</li>
</ul>
<h3 id="Task-Delay的问题"><a href="#Task-Delay的问题" class="headerlink" title="Task.Delay的问题"></a>Task.Delay的问题</h3><p>C#提供的定时器<code>Task.Delay</code>。</p>
<ul>
<li>跨线程<ul>
<li><code>Task.Delay</code>是跨线程的，会把await的回调放在其他线程执行。</li>
</ul>
</li>
<li>性能<ul>
<li>如果需要把回调设置到主线程，就需要设置同步上下文<code>SynchronizationContext synchronizationContext = SynchronizationContext.Current;</code>。把action post到主线程，性能很糟糕</li>
</ul>
</li>
<li>CancleToken抛异常<ul>
<li>抛异常的性能问题</li>
<li>不执行后续操作</li>
</ul>
</li>
<li>GC<ul>
<li>基于Task实现 有GC</li>
</ul>
</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="相对时间"><a href="#相对时间" class="headerlink" title="相对时间"></a>相对时间</h5><p><code>public async ETTask WaitAsync(long time,ETCancellationToken cancellationToken = null)</code></p>
<h5 id="unix绝对时间"><a href="#unix绝对时间" class="headerlink" title="unix绝对时间"></a>unix绝对时间</h5><p><code>public async ETTask WaitTillAsync(long tillTime,ETCancellationToken cancellationToken = null)</code></p>
<p>相对时间的会跟随帧率 或 线程情况受影响。而绝对时间则是跟随unix时间。在时间达到时，无论什么情况都会执行。</p>
<h5 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h5><p><code>public long NewOnceTimer(long tillTime,int type,object args)</code></p>
<p>为什么不用callback？</p>
<p>计时器里可能会有泄露，方便查找泄露。callback没法热重载，基本不用callback。</p>
<p>跟WaitAsync的区别？</p>
<p>时间长时，用<code>NewOnceTimer</code>，可以热重载。而<code>WaitAsync</code>不能热重载。</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>MultMap 管理时间线，在每个时间点插入一个list管理多个计时器。插入list的操作有gc，用对象池创建的话会有回收问题，一直创建池子只会越来越大，在切换场景的时候回收。</p>
<p>Remove细节，只从timerActions中删除。不删除MultMap 管理的计时器，MultMap管理的List插入删除都会影响性能。时间到了从MultMap 取出执行时，判断是否在timerActions中，如果在再执行。</p>
<p>WaitAsync ETCancellationToken怎么判断去取消。</p>
<h2 id="第七节-协程锁"><a href="#第七节-协程锁" class="headerlink" title="第七节 协程锁"></a>第七节 协程锁</h2><p><code>CoroutineLockComponent</code></p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>协程并发造成协程竞争，类比于线程竞争</li>
<li>unity资源加载<ul>
<li>同时异步加载同一个资源会报错</li>
<li>如果打标记后续逻辑比较不好扩展，比如要做await操作。</li>
</ul>
</li>
<li>加载mail数据<ul>
<li>不同服务器玩家数据的竞争</li>
</ul>
</li>
<li>unit消息队列，上线下线<ul>
<li>玩家下线了，但是有些异步操作还没完成。</li>
</ul>
</li>
<li>数据库查询保存队列，防止并发过多<ul>
<li>mongodb数据的并发数量是有限的。</li>
</ul>
</li>
</ul>
<p>用了协程锁后，协程则是并列进行。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="协程锁中再次获得同一把锁"><a href="#协程锁中再次获得同一把锁" class="headerlink" title="协程锁中再次获得同一把锁"></a>协程锁中再次获得同一把锁</h4><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230314225046861.png" srcset="/img/loading.gif" lazyload alt="image-20230314225046861"></p>
<h4 id="A-B互相等待"><a href="#A-B互相等待" class="headerlink" title="A B互相等待"></a>A B互相等待</h4><h4 id="想象不到的死锁"><a href="#想象不到的死锁" class="headerlink" title="想象不到的死锁"></a>想象不到的死锁</h4><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230314225755691.png" srcset="/img/loading.gif" lazyload alt="image-20230314225755691"></p>
<p>两条没有关联的消息正好在同一时间请求，请求的内容都需要用到同一把锁。就造成了死锁。</p>
<p>这种情况比较罕见，要么改成请求锁的地方统一通过转发形式。要么干脆直接不处理了。</p>
<h3 id="协程队列实现"><a href="#协程队列实现" class="headerlink" title="协程队列实现"></a>协程队列实现</h3><p>CoroutineLockComponent</p>
<p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230314230323393.png" srcset="/img/loading.gif" lazyload alt="image-20230314230323393"></p>
<ul>
<li>协程锁划分类型<ul>
<li>不同类型的锁没必要等，比如资源和数据。</li>
</ul>
</li>
<li>同一个类型，再根据id划分协程锁队列。</li>
<li>同一个类型，并且id相同则在同一个队列中，并列执行。</li>
</ul>
<p>CoroutineLockQueueType</p>
<p>CoroutineLockQueue 对象池</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>为什么不用池？不用struct？</p>
<p>超时实现</p>
<h2 id="第八节-协程同步"><a href="#第八节-协程同步" class="headerlink" title="第八节 协程同步"></a>第八节 协程同步</h2><p>三件套<code>ETTask</code>、<code>协程锁</code>、<code>WaitAll</code></p>
<p>在使用waitAll时需要考虑是否能并发，是否需要并发。</p>
<p><code>ETTaskHelper.WaitAll</code></p>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="资源加载并发"><a href="#资源加载并发" class="headerlink" title="资源加载并发"></a>资源加载并发</h4><p><code>ResourceComponent</code>实现了并发加载资源</p>
<p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230314232242465.png" srcset="/img/loading.gif" lazyload alt="image-20230314232242465"></p>
<h4 id="机器人登录并发"><a href="#机器人登录并发" class="headerlink" title="机器人登录并发"></a>机器人登录并发</h4><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230314232906957.png" srcset="/img/loading.gif" lazyload alt="image-20230314232906957"></p>
<p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230314232915651.png" srcset="/img/loading.gif" lazyload alt="image-20230314232915651"></p>
<p>每个流程都可以实现并发</p>
<h3 id="WaitAll实现"><a href="#WaitAll实现" class="headerlink" title="WaitAll实现"></a>WaitAll实现</h3><h4 id="线程同步barrier"><a href="#线程同步barrier" class="headerlink" title="线程同步barrier"></a>线程同步barrier</h4><p>可以参考barrier</p>
<ol>
<li>主协程要阻塞住<ul>
<li>主协程wait</li>
</ul>
</li>
<li>所有子协程执行完，要通知主协程往下执行<ul>
<li>子协程执行完有个回调，至少有个setResult的操作<ul>
<li>用计数形式，每执行完一个子协程，count-1，count=0时表示子协程都执行完毕。</li>
</ul>
</li>
<li>主协程在所有子协程都执行完后才开始执行，就需要判断。<ul>
<li>在主协程开始时，判断计数是否为0，为0时直接执行。不为0时创建个ETTask等待。</li>
</ul>
</li>
</ul>
</li>
<li>Cancel的判断<ul>
<li>WaitAll取消的操作</li>
</ul>
</li>
</ol>
<h3 id="WaitAny"><a href="#WaitAny" class="headerlink" title="WaitAny"></a>WaitAny</h3><p>有任一一个协程执行完则返回。</p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>计数设置为1，执行完一个-1，count&lt;=0返回</p>
<h2 id="第九节-ID、TimeInfo、ObjectPool"><a href="#第九节-ID、TimeInfo、ObjectPool" class="headerlink" title="第九节 ID、TimeInfo、ObjectPool"></a>第九节 ID、TimeInfo、ObjectPool</h2><h3 id="ID"><a href="#ID" class="headerlink" title="ID"></a>ID</h3><p>对应类<code>IdGenerater</code></p>
<h4 id="ID跟InstanceID"><a href="#ID跟InstanceID" class="headerlink" title="ID跟InstanceID"></a>ID跟InstanceID</h4><h5 id="ID是逻辑上的，InstanceID是对象的"><a href="#ID是逻辑上的，InstanceID是对象的" class="headerlink" title="ID是逻辑上的，InstanceID是对象的"></a>ID是逻辑上的，InstanceID是对象的</h5><h5 id="ID可以重复，管理器管理，而InstanceID是全局唯一的"><a href="#ID可以重复，管理器管理，而InstanceID是全局唯一的" class="headerlink" title="ID可以重复，管理器管理，而InstanceID是全局唯一的"></a>ID可以重复，管理器管理，而InstanceID是全局唯一的</h5><h4 id="为什么需要InstanceID？"><a href="#为什么需要InstanceID？" class="headerlink" title="为什么需要InstanceID？"></a>为什么需要InstanceID？</h4><h5 id="InstanceID表示对象的唯一性"><a href="#InstanceID表示对象的唯一性" class="headerlink" title="InstanceID表示对象的唯一性"></a>InstanceID表示对象的唯一性</h5><p>对象可能会被释放或者清除，通过InstanceID判断对象是否存在</p>
<h5 id="InstanceID有位置信息"><a href="#InstanceID有位置信息" class="headerlink" title="InstanceID有位置信息"></a>InstanceID有位置信息</h5><p>InstanceID拥有时间、进程号</p>
<h5 id="InstanceID能方便区分对象进入对象池再被使用"><a href="#InstanceID能方便区分对象进入对象池再被使用" class="headerlink" title="InstanceID能方便区分对象进入对象池再被使用"></a>InstanceID能方便区分对象进入对象池再被使用</h5><p>在await等待时当持有的unit可能在某个操作被对象池回收，后再被创建。持有的unit已经变成了新的unit造成逻辑错误。</p>
<p>InstanceID被池回收后再创建，InstanceID发生变化。在await操作时判断前后InstanceID是否一致。</p>
<h4 id="ID的构成"><a href="#ID的构成" class="headerlink" title="ID的构成"></a>ID的构成</h4><p><code>long</code>类型 64位</p>
<ul>
<li>Time 30bit  34年<ul>
<li>不用从1970开始，可以从项目发布时间开始，还能用34年</li>
</ul>
</li>
<li>Process进程号 18bit 1024*256<ul>
<li>一个区大概使用256个进程(根据游戏类型调整)，可以支持1024个区</li>
</ul>
</li>
<li>自增 16bit 65535<ul>
<li>当一秒内的自增id超过范围时，借用下一秒的</li>
</ul>
</li>
</ul>
<h4 id="UnitID构成"><a href="#UnitID构成" class="headerlink" title="UnitID构成"></a>UnitID构成</h4><ul>
<li>Time  30bit 34年</li>
<li>Zone 10bit 1024个区 跨服用<ul>
<li>当出现跨服活动时，很方便的通过zone来做区分</li>
</ul>
</li>
<li>ProcessMode 8bit Process % 256</li>
<li>自增 16bit 65535</li>
</ul>
<h4 id="InstanceID构成"><a href="#InstanceID构成" class="headerlink" title="InstanceID构成"></a>InstanceID构成</h4><ul>
<li>Time 28bit  当年开始的tick<ul>
<li>生命周期比较短，不需要那么长的 time</li>
</ul>
</li>
<li>Process进程号 18bit 1024*256<ul>
<li>一个区大概使用256个进程(根据游戏类型调整)，可以支持1024个区</li>
</ul>
</li>
<li>自增 18bit 65535 *4<ul>
<li>数量比较多，增加自增率</li>
</ul>
</li>
</ul>
<h3 id="TimeInfo"><a href="#TimeInfo" class="headerlink" title="TimeInfo"></a>TimeInfo</h3><p>对应类<code>TimeInfo</code></p>
<ul>
<li>Unix Time 自1970年1月1日以来的毫秒</li>
<li>ServerMinusClientTime<ul>
<li>服务器时间  -  客户端时间得到的时间差。在 ping的过程中获取。</li>
<li>客户端时间 + 与服务器的时间差 = 服务器时间</li>
</ul>
</li>
<li>ServerTime、ClientTime<ul>
<li>对于服务器而言，ServerTime和ClientTime是一样的，对服务器而言不需要考虑客户端时间。</li>
<li>对客户端而言，ServerTime就是  客户端时间 加上 与服务器的时间差获得的。</li>
</ul>
</li>
<li>性能优化<ul>
<li>在ClientNow中 计算时间用到Ticks，Ticks的操作非常耗时。</li>
</ul>
</li>
</ul>
<h3 id="ObjectPool"><a href="#ObjectPool" class="headerlink" title="ObjectPool"></a>ObjectPool</h3><p>mono的垃圾回收很垃圾。</p>
<p>在异步代码里，处处使用对象池很有问题。在每个操作都要判断是不是新的对象，漏了一个就有很大的问题。</p>
<p>有些对象池有定时回收的功能，这个功能的缺陷在于，在某一帧可能会回收大量对象，加深了那一帧的时间。</p>
<p>ET的设计则是将对象池设置个最大容量，超过最大容量时则不入池，避免内存占用过大。</p>
<p>在一些场景切换中也可以对对象池进行清理，避免没有意义的内存占用。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%A1%86%E6%9E%B6%E7%AF%87/" class="category-chain-item">框架篇</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Manager-%E6%A1%86%E6%9E%B6-ET%E6%A1%86%E6%9E%B6/">#Manager 框架 ET框架</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>网络游戏架构设计</div>
      <div>http://ysich.github.io/2023/03/17/网络游戏架构设计/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>ysich</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年3月17日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/07/14/%E7%BA%B9%E7%90%86%E8%AF%A6%E8%A7%A3/" title="纹理详解">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">纹理详解</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/01/31/%E5%85%B3%E4%BA%8ECallBack/" title="关于CallBack">
                        <span class="hidden-mobile">关于CallBack</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/ysich" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
