

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="ysich">
  <meta name="keywords" content="">
  
    <meta name="description" content="网络游戏架构设计第一节 代码结构项目代码结构需要满足的需求热更新需要把Unity的MonoBehaviour等等这些和Unity交互较深的脚本进行分离 至少有一个热更新的程序集 数据跟方法分离，热重载热重载​	热重载只是数据跟方法分离后得到的好处 ​	热重载便于改bug，节省重现环节。 数据跟方法分离​	在C语言中叫做data + function的设计。数据就是定义数据结构，方法则是面向过程的方">
<meta property="og:type" content="article">
<meta property="og:title" content="网络游戏架构设计">
<meta property="og:url" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/index.html">
<meta property="og:site_name" content="ysich&#39;Blog">
<meta property="og:description" content="网络游戏架构设计第一节 代码结构项目代码结构需要满足的需求热更新需要把Unity的MonoBehaviour等等这些和Unity交互较深的脚本进行分离 至少有一个热更新的程序集 数据跟方法分离，热重载热重载​	热重载只是数据跟方法分离后得到的好处 ​	热重载便于改bug，节省重现环节。 数据跟方法分离​	在C语言中叫做data + function的设计。数据就是定义数据结构，方法则是面向过程的方">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230308124513.png">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230308124518-1678250733684.jpg">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230308123835.jpg">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230308123804-1678250496566.jpg">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230308005444.jpg">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230308233904030.png">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230314225046861.png">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230314225755691.png">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230314230323393.png">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230314232242465.png">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230314232906957.png">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230314232915651.png">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230320090859.jpg">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230720100918090.png">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230726193709984.png">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230726195506719.png">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230727093218220.png">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230727101112402.png">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230727101932122.png">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230727103406008.png">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230727110904752.png">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230727152954789.png">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230728163810320.png">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230728171109863.png">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230728173529322.png">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230731095715561.png">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230731101934132.png">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230731102622947.png">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230731195658960.png">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230731195658960.png">
<meta property="og:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230731203603381.png">
<meta property="article:published_time" content="2023-03-17T06:07:03.000Z">
<meta property="article:modified_time" content="2023-08-01T02:38:37.720Z">
<meta property="article:author" content="ysich">
<meta property="article:tag" content="Manager 框架 ET框架">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230308124513.png">
  
  
  
  <title>网络游戏架构设计 - ysich&#39;Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"ysich.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  



  
<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>三十六分热</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="网络游戏架构设计"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-03-17 14:07" pubdate>
          2023年3月17日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          36k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          300 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">网络游戏架构设计</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="网络游戏架构设计"><a href="#网络游戏架构设计" class="headerlink" title="网络游戏架构设计"></a>网络游戏架构设计</h1><h2 id="第一节-代码结构"><a href="#第一节-代码结构" class="headerlink" title="第一节 代码结构"></a>第一节 代码结构</h2><h3 id="项目代码结构需要满足的需求"><a href="#项目代码结构需要满足的需求" class="headerlink" title="项目代码结构需要满足的需求"></a>项目代码结构需要满足的需求</h3><h4 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h4><p>需要把Unity的MonoBehaviour等等这些和Unity交互较深的脚本进行分离</p>
<p>至少有一个热更新的程序集</p>
<h4 id="数据跟方法分离，热重载"><a href="#数据跟方法分离，热重载" class="headerlink" title="数据跟方法分离，热重载"></a>数据跟方法分离，热重载</h4><h5 id="热重载"><a href="#热重载" class="headerlink" title="热重载"></a>热重载</h5><p>​	热重载只是数据跟方法分离后得到的好处</p>
<p>​	热重载便于改bug，节省重现环节。</p>
<h5 id="数据跟方法分离"><a href="#数据跟方法分离" class="headerlink" title="数据跟方法分离"></a>数据跟方法分离</h5><p>​	在C语言中叫做<code>data + function</code>的设计。数据就是定义数据结构，方法则是面向过程的方法。</p>
<p>​	相比于面向对象而已没有类与类之间的关联，只有方法和方法的关联，便于重构。</p>
<h4 id="逻辑跟表现分离"><a href="#逻辑跟表现分离" class="headerlink" title="逻辑跟表现分离"></a>逻辑跟表现分离</h4><p>数据是同步的，而表现可能是异步的情况。在表现过程中可能会有一些资源加载的操作，在这个过程中逻辑发生了变化，表现也需要发生变化。</p>
<p>预表现。表现层可能提前做出一些表现比如一些战斗前摇，但是对逻辑层没有什么影响。等逻辑层同步了命中逻辑后，再播放命中的表现。</p>
<p>在MMO的切换场景中，服务器通知场景切换后，客户端逻辑层加载数据，表现层则在数据加载完成后开始异步加载场景。服务器再通知单位模型的数据后，客户端逻辑层整理数据后，表现成开始异步加载单位模型。</p>
<p>帧同步。帧同步两端的逻辑层的逻辑是一样的。而状态同步逻辑在服务端，两端的逻辑层实际上也是一样的。区别只在于一个是客户端计算一个是服务端计算。 帧同步如果把逻辑层看做是一个服务端，看起来就像是逻辑层在给表现层发消息。逻辑是离散的，表现是要做插值的。</p>
<h4 id="ECS数据驱动"><a href="#ECS数据驱动" class="headerlink" title="ECS数据驱动"></a>ECS数据驱动</h4><p>数据变化是通过事件通知的。逻辑和表现监听事件产生变化。</p>
<h3 id="ET版本变更"><a href="#ET版本变更" class="headerlink" title="ET版本变更"></a>ET版本变更</h3><h4 id="1-0"><a href="#1-0" class="headerlink" title="1.0"></a>1.0</h4><p>客户端</p>
<ul>
<li>Hoxfix 热更层</li>
<li>Main 主工程</li>
</ul>
<p>服务端</p>
<ul>
<li>Hoxfix 纯逻辑</li>
<li>Main 纯数据</li>
</ul>
<h4 id="中间版本"><a href="#中间版本" class="headerlink" title="中间版本"></a>中间版本</h4><p>客户端 </p>
<p>asmdef功能，多个程序集提升编译速度</p>
<ul>
<li>Hoxfix	热更层</li>
<li>Loader 游戏入口，可放Unity脚本</li>
<li>Core 框架核心</li>
<li>ThirdParty 第三方库</li>
</ul>
<p>服务端</p>
<ul>
<li>Hoxfix</li>
<li>Model</li>
<li>Loader</li>
<li>Core</li>
<li>ThirdParty</li>
</ul>
<h4 id="热重载需求"><a href="#热重载需求" class="headerlink" title="热重载需求"></a>热重载需求</h4><p>客户端</p>
<ul>
<li>Hoxfix 热更层的逻辑层  <ul>
<li>纯逻辑改变时不用关闭游戏，直接重载这个程序集</li>
</ul>
</li>
<li>Model 热更层的数据层</li>
<li>Loader 游戏入口，可放Unity脚本</li>
<li>Core 框架核心</li>
<li>ThirdParty 第三方库</li>
</ul>
<h4 id="另一种划分"><a href="#另一种划分" class="headerlink" title="另一种划分"></a>另一种划分</h4><ul>
<li>HoxfixView 表现层</li>
<li>Hoxfix 逻辑层 抛事件通知表现层</li>
<li>Loader</li>
<li>ThridParty</li>
<li>Core</li>
</ul>
<h4 id="结合前面两个版本"><a href="#结合前面两个版本" class="headerlink" title="结合前面两个版本"></a>结合前面两个版本</h4><h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><ul>
<li>HoxfixView 表现层的方法</li>
<li>ModelView 表现层数据结构</li>
<li>Hofix 逻辑层方法</li>
<li>Model 逻辑层数据</li>
<li>Loader</li>
<li>Core</li>
<li>ThridParty</li>
</ul>
<p>前四个程序集编译在一起做热更新。HofixView和Hofix编译在一起做热重载。</p>
<p>并且逻辑和表现分离</p>
<h5 id="Robot"><a href="#Robot" class="headerlink" title="Robot"></a>Robot</h5><ul>
<li>Hofix 逻辑层方法</li>
<li>Model 逻辑层数据</li>
<li>Loader</li>
<li>Core</li>
<li>ThridParty</li>
</ul>
<p>去掉客户端的表现层，就是机器人的程序集了。</p>
<p>Hofix和Model共用客户端的程序集。</p>
<h2 id="第二节-All-In-One"><a href="#第二节-All-In-One" class="headerlink" title="第二节 All In One"></a>第二节 All In One</h2><h3 id="各类服务器进程合并"><a href="#各类服务器进程合并" class="headerlink" title="各类服务器进程合并"></a>各类服务器进程合并</h3><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230308124513.png" srcset="/img/loading.gif" lazyload alt="微信图片_20230308124513"></p>
<p>很多多进程的设计，都把一个服务整理成一个exe。多个服务就有多个exe，代码可能是高度相似的，或者基本一样的。只是启动时环境变量不同。合并成一个exe并设置环境变量。</p>
<ul>
<li>发布部署简单、配置资源方便、多种服务共用进程。</li>
<li>结构调整容易，比如两种或多种服务要合并，拆分<ul>
<li>多个exe会有多个进程，当其中一部分逻辑压力过大时（比如一个中心服有好友和组队功能，好友功能压力过大时 ）不好拆分，需要再拆成多个exe。</li>
<li>无限增加app类型，千古风流有几十种SceneType</li>
<li>根据配置需要什么服务，就配置什么类型。多个服务配置在一个进程内。</li>
</ul>
</li>
</ul>
<h3 id="后端和机器人合并"><a href="#后端和机器人合并" class="headerlink" title="后端和机器人合并"></a>后端和机器人合并</h3><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230308124518-1678250733684.jpg" srcset="/img/loading.gif" lazyload alt="微信图片_20230308124518"></p>
<p>机器人和服务器的代码基本一样。也引用了大部分的后端代码。还引用了客户端的逻辑代码。代码引用很乱。</p>
<p>机器人要单独起一个exe很不方便，跑测试需要起两个进程。</p>
<h4 id="server和机器人合并带来的问题"><a href="#server和机器人合并带来的问题" class="headerlink" title="server和机器人合并带来的问题"></a>server和机器人合并带来的问题</h4><ul>
<li>代码类重名<ul>
<li>合并后分别引用了客户端和服务端的代码。两端代码的类名重名（item、buff）。</li>
<li>用命名空间隔离解决重名冲突，带来的好处只需要检查目录下的命名空间就能保证不会调用到错误的代码。</li>
<li>ET.Server、ET.Client</li>
</ul>
</li>
<li>事件订阅怎么区分前后端<ul>
<li>有些工具类，或数值组件这种两端共用的代码就不用隔离。ET</li>
<li>比如单位组件，前后端都有抛出的事件很难做区分。需要区分订阅。</li>
<li>通过场景类型做区分SceneType</li>
</ul>
</li>
<li>配置文件结构不同怎么共享<ul>
<li>问题也不大，大不了两端配置都存在。</li>
</ul>
</li>
</ul>
<p>机器人在写组队逻辑时很有用。</p>
<h3 id="前端跟后端合并"><a href="#前端跟后端合并" class="headerlink" title="前端跟后端合并"></a>前端跟后端合并</h3><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230308123835.jpg" srcset="/img/loading.gif" lazyload alt="微信图片_20230308123835"></p>
<h4 id="不需要单独起服务端，前后端代码共享更方便"><a href="#不需要单独起服务端，前后端代码共享更方便" class="headerlink" title="不需要单独起服务端，前后端代码共享更方便"></a>不需要单独起服务端，前后端代码共享更方便</h4><p>不需要单独启动服务器，unity一启动就启动前后端代码。</p>
<p>前后端代码的共享，前端可以包含一个服务器，后端可以包含前端的逻辑做个机器人。</p>
<h4 id="后端可以更方便做Unity可视化工具，可视化树ENABLE-VIEW"><a href="#后端可以更方便做Unity可视化工具，可视化树ENABLE-VIEW" class="headerlink" title="后端可以更方便做Unity可视化工具，可视化树ENABLE_VIEW"></a>后端可以更方便做Unity可视化工具，可视化树ENABLE_VIEW</h4><p>后端如果是命令行程序，做数据可视化很困难。</p>
<p>写后端就像写前端一样简单，比如写个行为树，后端可以直接调试，前端可以直接拿到后端数据。</p>
<p>ET7加上ENABLE_VIEW宏开启可视化树</p>
<h4 id="更方便做插件机制"><a href="#更方便做插件机制" class="headerlink" title="更方便做插件机制"></a>更方便做插件机制</h4><p>用unity的导入导出做插件机制。</p>
<h4 id="各种游戏代码合并的需求分析"><a href="#各种游戏代码合并的需求分析" class="headerlink" title="各种游戏代码合并的需求分析"></a>各种游戏代码合并的需求分析</h4><h5 id="竞技游戏"><a href="#竞技游戏" class="headerlink" title="竞技游戏"></a>竞技游戏</h5><p>比如守望先锋，用的状态帧同步。本地先预测下一帧行为，服务器同步下来如果结果不符合则进行回滚。那么两端肯定有相同代码，否则产生结果肯定是不一致的。</p>
<h5 id="MMO游戏、MOBA游戏"><a href="#MMO游戏、MOBA游戏" class="headerlink" title="MMO游戏、MOBA游戏"></a>MMO游戏、MOBA游戏</h5><p>模拟机器人的需求，充当普通玩家。</p>
<p>机器人压测需求。</p>
<h5 id="状态同步"><a href="#状态同步" class="headerlink" title="状态同步"></a>状态同步</h5><p>客户端预测和服务器权威数据跑的代码基本一致。</p>
<h5 id="帧同步"><a href="#帧同步" class="headerlink" title="帧同步"></a>帧同步</h5><p>逻辑都在客户端，但是在结算结果的时候数据不权威。后期帧同步，很多是依靠服务器也跑一份逻辑，根据跑出来的结果判定结算。也是防作弊很重要的内容。</p>
<h3 id="前端和后端合并的细节问题"><a href="#前端和后端合并的细节问题" class="headerlink" title="前端和后端合并的细节问题"></a>前端和后端合并的细节问题</h3><h4 id="怎么区分编译前端代码跟后端代码，还有双端编译"><a href="#怎么区分编译前端代码跟后端代码，还有双端编译" class="headerlink" title="怎么区分编译前端代码跟后端代码，还有双端编译"></a>怎么区分编译前端代码跟后端代码，还有双端编译</h4><p>搞一个编译工具，按照需求选择编译</p>
<h4 id="配置要区分前端跟后端，以及双端，configpatial的处理"><a href="#配置要区分前端跟后端，以及双端，configpatial的处理" class="headerlink" title="配置要区分前端跟后端，以及双端，configpatial的处理"></a>配置要区分前端跟后端，以及双端，configpatial的处理</h4><p>有些配置不需要双端都知道的，比如前端的特效，或后端比较权威计算的数值。</p>
<p>这就需要导出三份配置。C、CS、S</p>
<p>config patial就是把配置反序列化成需要的类对象的工具</p>
<p>config patial不能共享，需要写三份。</p>
<p>消息要区分前后端，以及双端。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230308123804-1678250496566.jpg" srcset="/img/loading.gif" lazyload alt="微信图片_20230308123804"></p>
<p>把服务器逻辑代码也写在客户端程序集内，直接引用。</p>
<p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230308005444.jpg" srcset="/img/loading.gif" lazyload alt="微信图片_20230308005444"></p>
<h2 id="第三节-单间管理器"><a href="#第三节-单间管理器" class="headerlink" title="第三节 单间管理器"></a>第三节 单间管理器</h2><h3 id="为什么需要单间管理器？"><a href="#为什么需要单间管理器？" class="headerlink" title="为什么需要单间管理器？"></a>为什么需要单间管理器？</h3><h4 id="统一管理单间类。单间类的问题？"><a href="#统一管理单间类。单间类的问题？" class="headerlink" title="统一管理单间类。单间类的问题？"></a>统一管理单间类。单间类的问题？</h4><p>单间类生命周期的问题，创建了什么时候释放的问题。</p>
<p>内存随着生命周期清理的问题。</p>
<h4 id="统一管理基础库，灵活引入基础库"><a href="#统一管理基础库，灵活引入基础库" class="headerlink" title="统一管理基础库，灵活引入基础库"></a>统一管理基础库，灵活引入基础库</h4><h4 id="消除静态字段"><a href="#消除静态字段" class="headerlink" title="消除静态字段"></a>消除静态字段</h4><p><code>static Dictionary</code>这种静态变量，生命周期清理的问题。</p>
<h4 id="Unity-domain模式"><a href="#Unity-domain模式" class="headerlink" title="Unity domain模式"></a>Unity domain模式</h4><p>domain模式为了提升性能不清理静态字段，需要自己清理。</p>
<h4 id="为什么不用组件？"><a href="#为什么不用组件？" class="headerlink" title="为什么不用组件？"></a>为什么不用组件？</h4><p>组件本身需要一些额外的东西，比如创建的时候需要对象池。对象池又是谁管理。就可以使用单间管理器创建对象池。</p>
<h4 id="为什么用Game-AddSingleton-创建单间"><a href="#为什么用Game-AddSingleton-创建单间" class="headerlink" title="为什么用Game.AddSingleton 创建单间"></a>为什么用Game.AddSingleton 创建单间</h4><p><code>Game.AddSingleton&lt;TimeInfo&gt;();</code></p>
<h5 id="代码可读性，明确知道单间初始化的地方。"><a href="#代码可读性，明确知道单间初始化的地方。" class="headerlink" title="代码可读性，明确知道单间初始化的地方。"></a>代码可读性，明确知道单间初始化的地方。</h5><p>如果都是<code>Instance</code>很难找到哪里是初始化的地方。</p>
<h5 id="明确知道初始化顺序，方便调整"><a href="#明确知道初始化顺序，方便调整" class="headerlink" title="明确知道初始化顺序，方便调整"></a>明确知道初始化顺序，方便调整</h5><h5 id="好释放，相反的顺序释放"><a href="#好释放，相反的顺序释放" class="headerlink" title="好释放，相反的顺序释放"></a>好释放，相反的顺序释放</h5><p>明确知道了初始化顺序，能更明确释放的顺序。</p>
<figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ISingleton</span>: <span class="hljs-title">IDisposable</span><br>{<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Register</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Destroy</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">IsDisposed</span>()</span>;<br>}<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>&lt;<span class="hljs-title">T</span>&gt;: <span class="hljs-title">ISingleton</span> <span class="hljs-keyword">where</span> <span class="hljs-title">T</span>: <span class="hljs-title">Singleton</span>&lt;<span class="hljs-title">T</span>&gt;, <span class="hljs-title">new</span>(){<br><br>}<br></code></pre></td></tr></tbody></table></figure>

<h5 id="通过接口创建生命周期"><a href="#通过接口创建生命周期" class="headerlink" title="通过接口创建生命周期"></a>通过接口创建生命周期</h5><p><code>ISingletonAwake</code> 、<code>ISingletonUpdate</code> 、<code>ISingletonLateUpdate</code></p>
<p><code>AddSingleton</code>时判断是否有生命周期接口，如果有添加对应生命周期。</p>
<figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddSingleton</span>(<span class="hljs-params">ISingleton singleton</span>)</span><br>{<br>    Type singletonType = singleton.GetType();<br>    <span class="hljs-keyword">if</span> (singletonTypes.ContainsKey(singletonType))<br>    {<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">$"already exist singleton: <span class="hljs-subst">{singletonType.Name}</span>"</span>);<br>    }<br><br>    singletonTypes.Add(singletonType, singleton);<br>    <span class="hljs-comment">//管理单间加载顺序，做卸载时可用</span><br>    singletons.Push(singleton);<br><br>    singleton.Register();<br><br>    <span class="hljs-keyword">if</span> (singleton <span class="hljs-keyword">is</span> ISingletonAwake awake)<br>    {<br>        awake.Awake();<br>    }<br><br>    <span class="hljs-keyword">if</span> (singleton <span class="hljs-keyword">is</span> ISingletonUpdate)<br>    {<br>        updates.Enqueue(singleton);<br>    }<br><br>    <span class="hljs-keyword">if</span> (singleton <span class="hljs-keyword">is</span> ISingletonLateUpdate)<br>    {<br>        lateUpdates.Enqueue(singleton);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<h2 id="第四节-多线程、单线程、Task-await-async的关系"><a href="#第四节-多线程、单线程、Task-await-async的关系" class="headerlink" title="第四节 多线程、单线程、Task await async的关系"></a>第四节 多线程、单线程、Task await async的关系</h2><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>使用多线程去执行复杂逻辑时，callback会在执行线程继续执行进行响应。</p>
<p>比如寻路的逻辑比较复杂抛给其他线程去处理，响应回调时也是会在寻路线程进行响应。</p>
<p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230308233904030.png" srcset="/img/loading.gif" lazyload alt="image-20230308233904030"></p>
<h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><p>当遇到框架内的api都是单线程的api时，必须在主线程完成回调。在其他线程响应回调会导致线程竞争。</p>
<p>解决方法也很简单，在其他线程响应回调时把回调放到一个缓存队列中（需要同步上下文），在主线程的update里不断去取缓存队列中的响应，并去执行它。就能把回调丢回到主线程执行。(C++中的没有task而使用的手法)</p>
<p>详情看看MainThreadSynchronizationContext这个类</p>
<h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><p>线程消耗比较大，创建的时候一般都使用线程池。Task就是线程池封装的结果。</p>
<p>Task 执行的线程和响应回调的线程不一致，回调的响应会丢到其他线程执行。</p>
<p>Task本质就是个状态机，当设置了同步上下文时，回调会被自动调整到主线程执行。 编译器帮我们做了这一步</p>
<figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StartTask</span>()</span>{<br>	SynchronizationContext synchronizationContext = SynchronizationContext.Current;<br>    <span class="hljs-keyword">await</span> Task.Run(FindPath);<br>    <span class="hljs-keyword">if</span>(synchronizationContext == <span class="hljs-literal">null</span>){<br>        <span class="hljs-comment">//没设置同步上下文会在当前线程响应。</span><br>        SendMessage();<br>    }<span class="hljs-keyword">else</span>{<br>        <span class="hljs-comment">//设置了同步上下文实际会在设置的线程响应。</span><br>        synchronizationContext.post(()=&gt;{<br>            SendMessage();<br>        },<span class="hljs-literal">null</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<h3 id="自己实现个TaskRun"><a href="#自己实现个TaskRun" class="headerlink" title="自己实现个TaskRun"></a>自己实现个TaskRun</h3><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Run</span>(<span class="hljs-params">Action action</span>)</span><br>        {<br>            TaskCompletionSource tcs = <span class="hljs-keyword">new</span> TaskCompletionSource();<br>            ThreadPool.QueueUserWorkItem((_) =&gt;<br>            {<br>                action.Invoke();<br>                tcs.SetResult();<br>            });<br>            <span class="hljs-keyword">await</span> tcs.Task;<br>        }<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StartTask</span>()</span>{<br>    <span class="hljs-keyword">await</span> Run(FindPath);<br>    <span class="hljs-comment">//这里把回调和多线程的调用放在同个方法执行</span><br>    SendMessage();<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>使用<code>Task.Factory.StartNew</code>创建可以自由调度的线程</p>
<figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StartTask</span>()</span><br>       {<br>    <span class="hljs-comment">//MyTaskScheduler是自己实现的线程调度器</span><br>           <span class="hljs-keyword">await</span> Task.Factory.StartNew(FindPath,<span class="hljs-keyword">new</span> CancellationToken(),TaskCreationOptions.None,<span class="hljs-keyword">new</span> MyTaskScheduler());<br>       }<br></code></pre></td></tr></tbody></table></figure>

<h3 id="自定义线程调度器"><a href="#自定义线程调度器" class="headerlink" title="自定义线程调度器"></a>自定义线程调度器</h3><p>继承<code>TaskScheduler</code>实现自己的线程调度器</p>
<figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyTaskScheduler</span>:<span class="hljs-title">TaskScheduler</span><br>        {<br>            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> IEnumerable&lt;Task&gt; <span class="hljs-title">GetScheduledTasks</span>()</span><br>            {<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            }<br><br>            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">QueueTask</span>(<span class="hljs-params">Task task</span>)</span><br>            {<br>                <span class="hljs-comment">//执行完回收到线程池</span><br>                ThreadPool.QueueUserWorkItem((_) =&gt; TryExecuteTask(task));<br>            }<br><br>            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">TryExecuteTaskInline</span>(<span class="hljs-params">Task task, <span class="hljs-built_in">bool</span> taskWasPreviouslyQueued</span>)</span><br>            {<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException();<br>            }<br>        }<br></code></pre></td></tr></tbody></table></figure>



<h2 id="第五节-ETTask"><a href="#第五节-ETTask" class="headerlink" title="第五节 ETTask"></a>第五节 ETTask</h2><h3 id="回调地狱-Callback-Hell"><a href="#回调地狱-Callback-Hell" class="headerlink" title="回调地狱 Callback Hell"></a>回调地狱 Callback Hell</h3><p>Task主要是为了解决回调地狱 </p>
<p>在没有协程和await之前，cpp主要靠函数对象模拟Lambda。 </p>
<p>后续谷歌推出NewCallback</p>
<p>C# 5.0 推出了 await async 关键字</p>
<p>await难以维护的操作<code>while await</code>，await all 所有任务才执行回调。</p>
<p>go python js ts cpp后续也推出了await关键字，但是go的await不完善，是通过线程的方式去执行。比如玩家有的操作是需要单线程等待一段事件再执行的，回调则会执行在其他线程中。而好的设计则应该是只把回调拉直，而不关心你后续实现是在多线程还是单线程。</p>
<h3 id="回调转成Task"><a href="#回调转成Task" class="headerlink" title="回调转成Task"></a>回调转成Task</h3><p><code>TaskCompleteSource</code></p>
<figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> ETTask <span class="hljs-title">FindPath</span>()</span>{<br>    TaskCompletionSource tcs = TaskCompletionSource();<br>    ThreadPool.QueueUserWorkItem( state=&gt;{<br>       Consle.WriteLine(<span class="hljs-string">"FindPATH"</span>);<br>        tcs.SetResult();<br>    });<br>    <span class="hljs-keyword">await</span> tcs.Task;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p><code>CancellationTokenSource</code> await的取消操作</p>
<p>传入token，通过token状态来判断后续代码是否执行。 </p>
<h3 id="ETTask的好处"><a href="#ETTask的好处" class="headerlink" title="ETTask的好处"></a>ETTask的好处</h3><p>生成代码极简，去除了多线程的支持，性能最好。</p>
<p>对象池消除了Task GC</p>
<p><code>TaskCompleteSource</code>和<code>CancellationTokenSource</code>这两个类比较庞大并且没有入池，gc问题比较严重。</p>
<p>去掉了ETVoid </p>
<p>ETVoid对应 async void。任何异步都返回ETTask。不需要等待则直接Coroutine。操作简单。</p>
<h3 id="线程取消"><a href="#线程取消" class="headerlink" title="线程取消"></a>线程取消</h3><ul>
<li><p>超级简单的ETCancelToken</p>
<p>ETCancelToken替换<code>CancellationTokenSource</code></p>
</li>
<li><p>协程取消判断</p>
<figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">if</span>(cancellationToken.IsCancel()){<br>	Console.WriteLine(<span class="hljs-string">"Start cancel"</span>);<br>	<span class="hljs-keyword">return</span>;<br>}<br>Console.WriteLine(<span class="hljs-string">"Start finish"</span>);<br></code></pre></td></tr></tbody></table></figure>

<p>在ETTask中判断ETCanelToken是否取消然后继续执行后面操作。而Task在取消后则抛出异常。</p>
</li>
<li><p>ETCancelToken取消多个协程</p>
<p>多个ETTask判断同一个ETCancelToken</p>
</li>
<li><p>ETCancelToken的必要性</p>
<p>尽可能设计一个await的取消方式，否则后续维护扩展非常困难。</p>
</li>
</ul>
<h3 id="awaitable"><a href="#awaitable" class="headerlink" title="awaitable"></a>awaitable</h3><h4 id="GetAwaiter"><a href="#GetAwaiter" class="headerlink" title="GetAwaiter"></a>GetAwaiter</h4><p>c#提供的<code>GetAwaiter</code>的机制，只要对象有一个成员方法或者静态方法名为<code>GetAwaiter</code>，就可以使用await的语法。</p>
<h4 id="Unity-yield转换"><a href="#Unity-yield转换" class="headerlink" title="Unity yield转换"></a>Unity yield转换</h4><p>本质上也是回调操作，把yield用await的形式更加简单。</p>
<figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//unity中yield都会返回AsyncOperation的子类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> ETTask <span class="hljs-title">GetAwaiter</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> AsyncOperation asyncOperation</span>)</span>{<br>    ETTask task = ETTask.Create(<span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">//SetResult执行后会回到await后的操作。</span><br>    asyncOperation.completed += _=&gt;{ task.SetResult();};<br>    <span class="hljs-keyword">await</span> task;<br>}<br></code></pre></td></tr></tbody></table></figure>

<figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> ETTask&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">HttpGet</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> link</span>)</span>{<br>    <span class="hljs-keyword">try</span>{<br>        UnityWedRequest req = UnityWebRequest.Get(link);<br>        <span class="hljs-comment">//req.SendWebRequest()会返回UnityWebRequestAsyncOperation，继承于AsyncOperation</span><br>        <span class="hljs-keyword">await</span> req.SendWebRequest();<br>        <span class="hljs-keyword">return</span> req.downloadHandler.text;<br>	}<br>    <span class="hljs-keyword">catch</span>{<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<h2 id="第五节-2-ETTask源码分析"><a href="#第五节-2-ETTask源码分析" class="headerlink" title="第五节 -2 ETTask源码分析"></a>第五节 -2 ETTask源码分析</h2><p>用反编译工具<code>.NET Reflector</code>查看ETTask实现。</p>
<p>这里需要反复看生成概念。</p>
<p>本质上是基于状态机的实现，执行时通过判断ETTaskCompleted的值来判断是否走到后面的逻辑，如果需要等待则将状态机的<code>MoveNext</code>方法传到ETTask的CallBack中。通过状态机的状态变化继续后面的逻辑。 ETTask的<code>SetResult</code>操作会触发回调，执行状态机的<code>MoveNext</code>。</p>
<p>实际上是把await前的代码和await后的操作，各放在一个状态中，通过状态机切换来执行。保证了上下文的统一。</p>
<p>多个await会生成多个状态机</p>
<h4 id="ETTask"><a href="#ETTask" class="headerlink" title="ETTask"></a>ETTask</h4><p>只要用了<code>ettask.Coroutine()</code>在编译后会生成一个<code>ETAsyncTaskMethodBuilder.Create()</code></p>
<h4 id="ETAsyncTaskMethodBuilder"><a href="#ETAsyncTaskMethodBuilder" class="headerlink" title="ETAsyncTaskMethodBuilder"></a>ETAsyncTaskMethodBuilder</h4><p>struct类型，包含一个ETTask。</p>
<p>在方法执行了Coroutine编译后会对应生成一个相对的struct，继承于<code>IAsyncStateMachine</code>。生成一个状态机，根据state参数执行相对应阶段的代码。</p>
<h4 id="ETVoid"><a href="#ETVoid" class="headerlink" title="ETVoid"></a>ETVoid</h4><h4 id="ETAsyncVoidMethodBuilder"><a href="#ETAsyncVoidMethodBuilder" class="headerlink" title="ETAsyncVoidMethodBuilder"></a>ETAsyncVoidMethodBuilder</h4><h4 id="ETTaskCompleted"><a href="#ETTaskCompleted" class="headerlink" title="ETTaskCompleted"></a>ETTaskCompleted</h4><p>返回完成状态，基本是true</p>
<h4 id="ETAsyncTaskCompletedMethodBuilder"><a href="#ETAsyncTaskCompletedMethodBuilder" class="headerlink" title="ETAsyncTaskCompletedMethodBuilder"></a>ETAsyncTaskCompletedMethodBuilder</h4><h3 id="协程的使用"><a href="#协程的使用" class="headerlink" title="协程的使用"></a>协程的使用</h3><p>用协程简化工作流程。</p>
<p><code>int result = await OpenBox();</code>弹窗时返回点击按钮的type做相应的判断，简化在窗口里写逻辑，逻辑上更清晰。(有点像VB的弹窗返回值</p>
<p> <code>await MoveTo();</code></p>
<p><code>await ChangeScene();</code> 切换场景的操作写成一个方法，await后执行切换场景完成后的代码。</p>
<p><code>await CastSpell();</code> 释放技能，技能成功或失败后的操作。比如失败时使用道具，成功后捡道具。如果用事件则会变得很复杂。 </p>
<p>熊猫哥举了个例子，比如自动寻路时，需要通过几个场景的传送门才能到达最终场景。先把场景选出来，给每个场景写一个最短路径的寻路方法。根据读配置去执行相应的寻路方法。只需要通过一个while循环就能到达最终目标位置。</p>
<p>把逻辑异步化后，逻辑更清晰，只需要对内容进行封装抽象不需要再关心后续的逻辑了。</p>
<h2 id="第六节-计时器"><a href="#第六节-计时器" class="headerlink" title="第六节 计时器"></a>第六节 计时器</h2><p><code>TimerComponent</code></p>
<h3 id="需求场景"><a href="#需求场景" class="headerlink" title="需求场景"></a>需求场景</h3><ul>
<li>UI倒计时</li>
<li>网络超时</li>
<li>技能释放</li>
<li>buff超时删除，定时事件</li>
</ul>
<h3 id="Task-Delay的问题"><a href="#Task-Delay的问题" class="headerlink" title="Task.Delay的问题"></a>Task.Delay的问题</h3><p>C#提供的定时器<code>Task.Delay</code>。</p>
<ul>
<li>跨线程<ul>
<li><code>Task.Delay</code>是跨线程的，会把await的回调放在其他线程执行。</li>
</ul>
</li>
<li>性能<ul>
<li>如果需要把回调设置到主线程，就需要设置同步上下文<code>SynchronizationContext synchronizationContext = SynchronizationContext.Current;</code>。把action post到主线程，性能很糟糕</li>
</ul>
</li>
<li>CancleToken抛异常<ul>
<li>抛异常的性能问题</li>
<li>不执行后续操作</li>
</ul>
</li>
<li>GC<ul>
<li>基于Task实现 有GC</li>
</ul>
</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="相对时间"><a href="#相对时间" class="headerlink" title="相对时间"></a>相对时间</h5><p><code>public async ETTask WaitAsync(long time,ETCancellationToken cancellationToken = null)</code></p>
<h5 id="unix绝对时间"><a href="#unix绝对时间" class="headerlink" title="unix绝对时间"></a>unix绝对时间</h5><p><code>public async ETTask WaitTillAsync(long tillTime,ETCancellationToken cancellationToken = null)</code></p>
<p>相对时间的会跟随帧率 或 线程情况受影响。而绝对时间则是跟随unix时间。在时间达到时，无论什么情况都会执行。</p>
<h5 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h5><p><code>public long NewOnceTimer(long tillTime,int type,object args)</code></p>
<p>为什么不用callback？</p>
<p>计时器里可能会有泄露，方便查找泄露。callback没法热重载，基本不用callback。</p>
<p>跟WaitAsync的区别？</p>
<p>时间长时，用<code>NewOnceTimer</code>，可以热重载。而<code>WaitAsync</code>不能热重载。</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>MultMap 管理时间线，在每个时间点插入一个list管理多个计时器。插入list的操作有gc，用对象池创建的话会有回收问题，一直创建池子只会越来越大，在切换场景的时候回收。</p>
<p>Remove细节，只从timerActions中删除。不删除MultMap 管理的计时器，MultMap管理的List插入删除都会影响性能。时间到了从MultMap 取出执行时，判断是否在timerActions中，如果在再执行。</p>
<p>WaitAsync ETCancellationToken怎么判断去取消。</p>
<h2 id="第七节-协程锁"><a href="#第七节-协程锁" class="headerlink" title="第七节 协程锁"></a>第七节 协程锁</h2><p><code>CoroutineLockComponent</code></p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>协程并发造成协程竞争，类比于线程竞争</li>
<li>unity资源加载<ul>
<li>同时异步加载同一个资源会报错</li>
<li>如果打标记后续逻辑比较不好扩展，比如要做await操作。</li>
</ul>
</li>
<li>加载mail数据<ul>
<li>不同服务器玩家数据的竞争</li>
</ul>
</li>
<li>unit消息队列，上线下线<ul>
<li>玩家下线了，但是有些异步操作还没完成。</li>
</ul>
</li>
<li>数据库查询保存队列，防止并发过多<ul>
<li>mongodb数据的并发数量是有限的。</li>
</ul>
</li>
</ul>
<p>用了协程锁后，协程则是并列进行。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="协程锁中再次获得同一把锁"><a href="#协程锁中再次获得同一把锁" class="headerlink" title="协程锁中再次获得同一把锁"></a>协程锁中再次获得同一把锁</h4><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230314225046861.png" srcset="/img/loading.gif" lazyload alt="image-20230314225046861"></p>
<h4 id="A-B互相等待"><a href="#A-B互相等待" class="headerlink" title="A B互相等待"></a>A B互相等待</h4><h4 id="想象不到的死锁"><a href="#想象不到的死锁" class="headerlink" title="想象不到的死锁"></a>想象不到的死锁</h4><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230314225755691.png" srcset="/img/loading.gif" lazyload alt="image-20230314225755691"></p>
<p>两条没有关联的消息正好在同一时间请求，请求的内容都需要用到同一把锁。就造成了死锁。</p>
<p>这种情况比较罕见，要么改成请求锁的地方统一通过转发形式。要么干脆直接不处理了。</p>
<h3 id="协程队列实现"><a href="#协程队列实现" class="headerlink" title="协程队列实现"></a>协程队列实现</h3><p>CoroutineLockComponent</p>
<p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230314230323393.png" srcset="/img/loading.gif" lazyload alt="image-20230314230323393"></p>
<ul>
<li>协程锁划分类型<ul>
<li>不同类型的锁没必要等，比如资源和数据。</li>
</ul>
</li>
<li>同一个类型，再根据id划分协程锁队列。</li>
<li>同一个类型，并且id相同则在同一个队列中，并列执行。</li>
</ul>
<p>CoroutineLockQueueType</p>
<p>CoroutineLockQueue 对象池</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>为什么不用池？不用struct？</p>
<p>超时实现</p>
<h2 id="第八节-协程同步"><a href="#第八节-协程同步" class="headerlink" title="第八节 协程同步"></a>第八节 协程同步</h2><p>三件套<code>ETTask</code>、<code>协程锁</code>、<code>WaitAll</code></p>
<p>在使用waitAll时需要考虑是否能并发，是否需要并发。</p>
<p><code>ETTaskHelper.WaitAll</code></p>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="资源加载并发"><a href="#资源加载并发" class="headerlink" title="资源加载并发"></a>资源加载并发</h4><p><code>ResourceComponent</code>实现了并发加载资源</p>
<p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230314232242465.png" srcset="/img/loading.gif" lazyload alt="image-20230314232242465"></p>
<h4 id="机器人登录并发"><a href="#机器人登录并发" class="headerlink" title="机器人登录并发"></a>机器人登录并发</h4><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230314232906957.png" srcset="/img/loading.gif" lazyload alt="image-20230314232906957"></p>
<p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230314232915651.png" srcset="/img/loading.gif" lazyload alt="image-20230314232915651"></p>
<p>每个流程都可以实现并发</p>
<h3 id="WaitAll实现"><a href="#WaitAll实现" class="headerlink" title="WaitAll实现"></a>WaitAll实现</h3><h4 id="线程同步barrier"><a href="#线程同步barrier" class="headerlink" title="线程同步barrier"></a>线程同步barrier</h4><p>可以参考barrier</p>
<ol>
<li>主协程要阻塞住<ul>
<li>主协程wait</li>
</ul>
</li>
<li>所有子协程执行完，要通知主协程往下执行<ul>
<li>子协程执行完有个回调，至少有个setResult的操作<ul>
<li>用计数形式，每执行完一个子协程，count-1，count=0时表示子协程都执行完毕。</li>
</ul>
</li>
<li>主协程在所有子协程都执行完后才开始执行，就需要判断。<ul>
<li>在主协程开始时，判断计数是否为0，为0时直接执行。不为0时创建个ETTask等待。</li>
</ul>
</li>
</ul>
</li>
<li>Cancel的判断<ul>
<li>WaitAll取消的操作</li>
</ul>
</li>
</ol>
<h3 id="WaitAny"><a href="#WaitAny" class="headerlink" title="WaitAny"></a>WaitAny</h3><p>有任一一个协程执行完则返回。</p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>计数设置为1，执行完一个-1，count&lt;=0返回</p>
<h2 id="第九节-ID、TimeInfo、ObjectPool"><a href="#第九节-ID、TimeInfo、ObjectPool" class="headerlink" title="第九节 ID、TimeInfo、ObjectPool"></a>第九节 ID、TimeInfo、ObjectPool</h2><h3 id="ID"><a href="#ID" class="headerlink" title="ID"></a>ID</h3><p>对应类<code>IdGenerater</code></p>
<h4 id="ID跟InstanceID"><a href="#ID跟InstanceID" class="headerlink" title="ID跟InstanceID"></a>ID跟InstanceID</h4><h5 id="ID是逻辑上的，InstanceID是对象的"><a href="#ID是逻辑上的，InstanceID是对象的" class="headerlink" title="ID是逻辑上的，InstanceID是对象的"></a>ID是逻辑上的，InstanceID是对象的</h5><h5 id="ID可以重复，管理器管理，而InstanceID是全局唯一的"><a href="#ID可以重复，管理器管理，而InstanceID是全局唯一的" class="headerlink" title="ID可以重复，管理器管理，而InstanceID是全局唯一的"></a>ID可以重复，管理器管理，而InstanceID是全局唯一的</h5><h4 id="为什么需要InstanceID？"><a href="#为什么需要InstanceID？" class="headerlink" title="为什么需要InstanceID？"></a>为什么需要InstanceID？</h4><h5 id="InstanceID表示对象的唯一性"><a href="#InstanceID表示对象的唯一性" class="headerlink" title="InstanceID表示对象的唯一性"></a>InstanceID表示对象的唯一性</h5><p>对象可能会被释放或者清除，通过InstanceID判断对象是否存在</p>
<h5 id="InstanceID有位置信息"><a href="#InstanceID有位置信息" class="headerlink" title="InstanceID有位置信息"></a>InstanceID有位置信息</h5><p>InstanceID拥有时间、进程号</p>
<h5 id="InstanceID能方便区分对象进入对象池再被使用"><a href="#InstanceID能方便区分对象进入对象池再被使用" class="headerlink" title="InstanceID能方便区分对象进入对象池再被使用"></a>InstanceID能方便区分对象进入对象池再被使用</h5><p>在await等待时当持有的unit可能在某个操作被对象池回收，后再被创建。持有的unit已经变成了新的unit造成逻辑错误。</p>
<p>InstanceID被池回收后再创建，InstanceID发生变化。在await操作时判断前后InstanceID是否一致。</p>
<h4 id="ID的构成"><a href="#ID的构成" class="headerlink" title="ID的构成"></a>ID的构成</h4><p><code>long</code>类型 64位</p>
<ul>
<li>Time 30bit  34年<ul>
<li>不用从1970开始，可以从项目发布时间开始，还能用34年</li>
</ul>
</li>
<li>Process进程号 18bit 1024*256<ul>
<li>一个区大概使用256个进程(根据游戏类型调整)，可以支持1024个区</li>
</ul>
</li>
<li>自增 16bit 65535<ul>
<li>当一秒内的自增id超过范围时，借用下一秒的</li>
</ul>
</li>
</ul>
<h4 id="UnitID构成"><a href="#UnitID构成" class="headerlink" title="UnitID构成"></a>UnitID构成</h4><ul>
<li>Time  30bit 34年</li>
<li>Zone 10bit 1024个区 跨服用<ul>
<li>当出现跨服活动时，很方便的通过zone来做区分</li>
</ul>
</li>
<li>ProcessMode 8bit Process % 256</li>
<li>自增 16bit 65535</li>
</ul>
<h4 id="InstanceID构成"><a href="#InstanceID构成" class="headerlink" title="InstanceID构成"></a>InstanceID构成</h4><ul>
<li>Time 28bit  当年开始的tick<ul>
<li>生命周期比较短，不需要那么长的 time</li>
</ul>
</li>
<li>Process进程号 18bit 1024*256<ul>
<li>一个区大概使用256个进程(根据游戏类型调整)，可以支持1024个区</li>
</ul>
</li>
<li>自增 18bit 65535 *4<ul>
<li>数量比较多，增加自增率</li>
</ul>
</li>
</ul>
<h3 id="TimeInfo"><a href="#TimeInfo" class="headerlink" title="TimeInfo"></a>TimeInfo</h3><p>对应类<code>TimeInfo</code></p>
<ul>
<li>Unix Time 自1970年1月1日以来的毫秒</li>
<li>ServerMinusClientTime<ul>
<li>服务器时间  -  客户端时间得到的时间差。在 ping的过程中获取。</li>
<li>客户端时间 + 与服务器的时间差 = 服务器时间</li>
</ul>
</li>
<li>ServerTime、ClientTime<ul>
<li>对于服务器而言，ServerTime和ClientTime是一样的，对服务器而言不需要考虑客户端时间。</li>
<li>对客户端而言，ServerTime就是  客户端时间 加上 与服务器的时间差获得的。</li>
</ul>
</li>
<li>性能优化<ul>
<li>在ClientNow中 计算时间用到Ticks，Ticks的操作非常耗时。</li>
</ul>
</li>
</ul>
<h3 id="ObjectPool"><a href="#ObjectPool" class="headerlink" title="ObjectPool"></a>ObjectPool</h3><p>mono的垃圾回收很垃圾。</p>
<p>在异步代码里，处处使用对象池很有问题。在每个操作都要判断是不是新的对象，漏了一个就有很大的问题。</p>
<p>有些对象池有定时回收的功能，这个功能的缺陷在于，在某一帧可能会回收大量对象，加深了那一帧的时间。</p>
<p>ET的设计则是将对象池设置个最大容量，超过最大容量时则不入池，避免内存占用过大。</p>
<p>在一些场景切换中也可以对对象池进行清理，避免没有意义的内存占用。</p>
<h2 id="第十节-配置Excel、NLog、Options"><a href="#第十节-配置Excel、NLog、Options" class="headerlink" title="第十节 配置Excel、NLog、Options"></a>第十节 配置Excel、NLog、Options</h2><h3 id="Option"><a href="#Option" class="headerlink" title="Option"></a>Option</h3><p><code>Options</code></p>
<ul>
<li>Options类 示例</li>
<li>长名 短名 Required Default HelperText<ul>
<li><code>OptionAttribute</code> </li>
<li>Required 为false时不强制要求带参数</li>
</ul>
</li>
<li>序列化 反序列化<ul>
<li>序列化和反序列称unix和linux命令行风格的字符串</li>
</ul>
</li>
<li>起服命令参数<ul>
<li>option一般用于服务器启动，起服命令参数一般用于创建进程的配置信息。</li>
</ul>
</li>
<li>GM指令参数，手动解析？<ul>
<li>GM指令如果是命令行最好使用option的形式来配置。optin提供静态检查，不容易出错。</li>
</ul>
</li>
</ul>
<h3 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h3><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230320090859.jpg" srcset="/img/loading.gif" lazyload alt="微信图片_20230320090859"></p>
<ul>
<li>Logger单间类</li>
<li>ILog接口，策略模式<ul>
<li>策略模式，客户端使用UnityLogger，服务端用NLogger</li>
</ul>
</li>
<li>LogLevel<ul>
<li>提供Log等级，来按照等级进行输出。开发模式，测试模式和线上模式</li>
</ul>
</li>
<li>Conditional<ul>
<li>当有些日志需要进行拼接的操作时，拼接消耗性能，就给个宏定义判断。</li>
<li>通过打标签的形式对指定 Log函数进行标记，等有了宏定义之后才生效。</li>
<li>一个函数可以定义多个宏</li>
<li>.NET的新特性，可以使用DefalutInterpolatedStringHandler来减少字符串拼接带来的GC</li>
</ul>
</li>
<li>LogTrace<ul>
<li>当需要查看日志的堆栈时可以用LogTrace，函数内会创建个堆栈。这里可以看看堆栈的逻辑。</li>
</ul>
</li>
</ul>
<h3 id="NLog配置"><a href="#NLog配置" class="headerlink" title="NLog配置"></a>NLog配置</h3><p>对应config里的参数</p>
<ul>
<li>Variables<ul>
<li>通过变量修改Config里的配置，来达到指定参数的日志输出</li>
<li>LogManager.Configuration.Variables</li>
</ul>
</li>
<li>rules</li>
<li>targets</li>
<li>async、buffersize</li>
</ul>
<h3 id="Excel"><a href="#Excel" class="headerlink" title="Excel"></a>Excel</h3><ul>
<li>StartConfig<ul>
<li>启动时通过命令行选择加载指定的配置</li>
</ul>
</li>
<li>C S #</li>
<li>patial<ul>
<li>有些配置，不方便填类型比如 ip地址等等</li>
<li>通过patial扩展想要的类型，通过proto反序列化时赋值。</li>
</ul>
</li>
<li>KV<ul>
<li>通过key value的形式配置buff</li>
</ul>
</li>
</ul>
<h3 id="配置用时再加载"><a href="#配置用时再加载" class="headerlink" title="配置用时再加载"></a>配置用时再加载</h3><p>节省内存</p>
<p>懒加载减少同时加载造成的cpu过载</p>
<h2 id="第十一节-Why-not-继承，多态，组合？"><a href="#第十一节-Why-not-继承，多态，组合？" class="headerlink" title="第十一节 Why not 继承，多态，组合？"></a>第十一节 Why not 继承，多态，组合？</h2><h3 id="成员继承的问题"><a href="#成员继承的问题" class="headerlink" title="成员继承的问题"></a>成员继承的问题</h3><h4 id="类层级调整复杂、耦合，一个变化回影响很多子类"><a href="#类层级调整复杂、耦合，一个变化回影响很多子类" class="headerlink" title="类层级调整复杂、耦合，一个变化回影响很多子类"></a>类层级调整复杂、耦合，一个变化回影响很多子类</h4><p>​	当层级变多了后，插入一个新的对旧的逻辑都都会有影响</p>
<h4 id="继承成员随意组合问题"><a href="#继承成员随意组合问题" class="headerlink" title="继承成员随意组合问题"></a>继承成员随意组合问题</h4><h4 id="接口-组合？组合优于继承？"><a href="#接口-组合？组合优于继承？" class="headerlink" title="接口 + 组合？组合优于继承？"></a>接口 + 组合？组合优于继承？</h4><p>​	每个类都继承了接口的话，都需要额外实现。</p>
<p>​	缺乏动态性。当有一个功能，当前不开放但是之后开放。如果是接口，代码实现则需要预先实现，是否开放变成了时机的问题。浪费空间</p>
<p>​	特殊性影响了普遍性，可能并不是所有成员都拥有的功能，则需要给每个成员都添加对应的逻辑。</p>
<p>​	临时接口跟成员数量极多。比如各种种类的buff。</p>
<p>​	成员容易随意放置，没有规范。</p>
<p>​	patial分开逻辑？没有解决根本的问题，内存占用巨大。不需要的成员拥有了不需要的字段。</p>
<h3 id="类方法的问题"><a href="#类方法的问题" class="headerlink" title="类方法的问题"></a>类方法的问题</h3><p>函数跟数据混在一起，重构困难。当需要挪出逻辑时，会有private字段限制，不好挪动。</p>
<p>类和类之间方法互相调用，耦合，重构困难。</p>
<p>静态方法和类方法，界限不清晰。</p>
<h3 id="虚函数问题-多态"><a href="#虚函数问题-多态" class="headerlink" title="虚函数问题(多态)"></a>虚函数问题(多态)</h3><p>行为跟类型绑定，类型数量会爆炸</p>
<p>当一个类拆的不够细时。由于子类做不到任何成员组合，子函数会巨大。</p>
<p>不同类型经常写差不多的方法</p>
<h3 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h3><p>学习成本极大，打补丁的设计模式太多。</p>
<p>人员要求太高，经常设计不够细致。</p>
<p>如果没有统一标准，代码维护困难。</p>
<h3 id="Unity组件的优点"><a href="#Unity组件的优点" class="headerlink" title="Unity组件的优点"></a>Unity组件的优点</h3><p>成员自由搭配</p>
<p>成员动态插拔的，内存占用率高。</p>
<p>方法也是动态插拔的，更合理，更不容易出错。</p>
<p>临时数据不会导致信息爆炸，成员，方法</p>
<p>代码可读性高，因为内部实现少都是组合。</p>
<h3 id="Unity组件的缺陷"><a href="#Unity组件的缺陷" class="headerlink" title="Unity组件的缺陷"></a>Unity组件的缺陷</h3><p>数据跟方法没分离，容易耦合，互相调用。</p>
<p>事件方法基于反射，性能有些损失。</p>
<p>GameObject过于庞大，里面的东西过多，只需要纯逻辑时不需要view。 </p>
<p>没有替代多态的解决方案。</p>
<p>组件无法再挂组件，组件无法再有child。</p>
<h3 id="ECS的问题"><a href="#ECS的问题" class="headerlink" title="ECS的问题"></a>ECS的问题</h3><p>Entity只有一个ID，全是Entity。全是entity找bug起来很复杂</p>
<p>组件是strust，限制太大用起来很难受</p>
<p>非树状结构，不符合对世界的描述，工厂的管理模式。</p>
<p>组件无法再挂组件，过于扁平，组件无法再有child</p>
<h2 id="第十二节-实体组件系统"><a href="#第十二节-实体组件系统" class="headerlink" title="第十二节 实体组件系统"></a>第十二节 实体组件系统</h2><h3 id="Entity-Component-System"><a href="#Entity-Component-System" class="headerlink" title="Entity Component System"></a>Entity Component System</h3><p>AddComponet、RemoveComponet、生命周期等等接口名与生命周期都和Unity保持一致。</p>
<h4 id="Entity和Component合并。原因？区别？"><a href="#Entity和Component合并。原因？区别？" class="headerlink" title="Entity和Component合并。原因？区别？"></a>Entity和Component合并。原因？区别？</h4><p>Entity和Component很类似，功能开发时逻辑很容易互相嵌套，不容易区分。只有Entity能挂组件很不灵活，在线上环境中Component需要扩展成Entity很难进行扩展因为数据已经是Component的形式。</p>
<h4 id="数据跟方法完全分离"><a href="#数据跟方法完全分离" class="headerlink" title="数据跟方法完全分离"></a>数据跟方法完全分离</h4><h4 id="Entity不能继承"><a href="#Entity不能继承" class="headerlink" title="Entity不能继承"></a>Entity不能继承</h4><p>用组件代替继承，需要什么数据挂在需要的组件。</p>
<h4 id="Entity树状无限嵌套"><a href="#Entity树状无限嵌套" class="headerlink" title="Entity树状无限嵌套"></a>Entity树状无限嵌套</h4><p>大世界概念，比较容易描述游戏需求。</p>
<h4 id="跟传统ECS的区别"><a href="#跟传统ECS的区别" class="headerlink" title="跟传统ECS的区别"></a>跟传统ECS的区别</h4><p>传统ECS的System更多是成员的形式。</p>
<p>传统ECS强调组件的筛选</p>
<h3 id="ET组件数据跟方法分离的好处"><a href="#ET组件数据跟方法分离的好处" class="headerlink" title="ET组件数据跟方法分离的好处"></a>ET组件数据跟方法分离的好处</h3><p>没有耦合，没有设计模式，学习简单，重构简单</p>
<p>热重载容易</p>
<p>多态实现简单，能基于任何字段做逻辑分发</p>
<h3 id="逻辑分发-多态"><a href="#逻辑分发-多态" class="headerlink" title="逻辑分发-多态"></a>逻辑分发-多态</h3><h4 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h4><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><h4 id="Dictionary-lt-int-Action-gt"><a href="#Dictionary-lt-int-Action-gt" class="headerlink" title="Dictionary<int,Action>"></a>Dictionary&lt;int,Action&gt;</h4><p>状态注册，相比switch而言优化了寻找时的复杂度。</p>
<p>问题在于需要手动注册状态，删除时需要手动删除相对而言比较麻烦</p>
<h4 id="ET的分发形式，基于Attribute的自动注册"><a href="#ET的分发形式，基于Attribute的自动注册" class="headerlink" title="ET的分发形式，基于Attribute的自动注册"></a>ET的分发形式，基于Attribute的自动注册</h4><p>eventsystem</p>
<h3 id="Entity树"><a href="#Entity树" class="headerlink" title="Entity树"></a>Entity树</h3><h4 id="Entity的parent"><a href="#Entity的parent" class="headerlink" title="Entity的parent"></a>Entity的parent</h4><p>最顶层的Scene没有parent</p>
<p>Entity被反序列化出来时是没有parent的</p>
<h4 id="Domain"><a href="#Domain" class="headerlink" title="Domain"></a>Domain</h4><p>每个Entity都有一个Domain字段，记录在于哪个场景下</p>
<p>在找中间某个节点时，防止写了过多的getParent。</p>
<h4 id="对象生命周期管理的重要性"><a href="#对象生命周期管理的重要性" class="headerlink" title="对象生命周期管理的重要性"></a>对象生命周期管理的重要性</h4><p>创建对象时，谁去管理释放。谁去管理对象的生命周期。</p>
<p>如果通过单间管理对象的生命周期，又缺少了对单间生命周期的管理。写多了容易遗漏。</p>
<p>通过父级来管理孩子，父级移除时移除自身挂在的child。</p>
<h4 id="UISceneComponet-ResourceSceneComponent-Timer等等"><a href="#UISceneComponet-ResourceSceneComponent-Timer等等" class="headerlink" title="UISceneComponet ResourceSceneComponent Timer等等"></a>UISceneComponet ResourceSceneComponent Timer等等</h4><p>按Scene挂ui，根据Scene的生命周期进行资源回收。</p>
<p>创建时需要想清楚，需要让谁进行管理。</p>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>不建议把Entity做为另一个Entity的成员，要么作为组件，要么作为Child。</p>
<p>异步代码，容易出现对象消失，引用还在的情况。特别是用了对象池更危险，做分析器禁止</p>
<p>服务端逻辑帧一般不用Update和LateUpdate。服务器的一帧1毫秒，实际上不需要这么频繁，用Update100ms或者定时器来实现。</p>
<h3 id="Entity代码详解"><a href="#Entity代码详解" class="headerlink" title="Entity代码详解"></a>Entity代码详解</h3><p>Entity内，存放Component以Type为key ，一种Type的Component只能存在一个。</p>
<p>存放AddChild则是以Id为key。</p>
<h4 id="EntityStatus"><a href="#EntityStatus" class="headerlink" title="EntityStatus"></a>EntityStatus</h4><p>8位的枚举，每一位都记录了一个信息。</p>
<h4 id="SetParent"><a href="#SetParent" class="headerlink" title="SetParent"></a>SetParent</h4><p>Parent{Set方法}</p>
<p>严格限制parent必须要有domain，parent必须在数据树上。</p>
<h4 id="ComponentParent"><a href="#ComponentParent" class="headerlink" title="ComponentParent"></a>ComponentParent</h4><p>只能通过AddComponent来添加。</p>
<h4 id="Domain-1"><a href="#Domain-1" class="headerlink" title="Domain"></a>Domain</h4><p>根节点的Domain为自己，其他节点的Domain为父节点的Domain</p>
<p>如果是通过反序列化出来的Entity则没有domain，这时候需要递归把children的domain都设置一遍</p>
<h4 id="DB"><a href="#DB" class="headerlink" title="DB"></a>DB</h4><p>如果Child继承于ComponentDB或者ChildDB，则会加到componentsDB或childrenDB内。表示需要持久化。</p>
<h2 id="第十三节-EventSystem"><a href="#第十三节-EventSystem" class="headerlink" title="第十三节 EventSystem"></a>第十三节 EventSystem</h2><p><strong>Type.GetType在IL2CPP中性能很差</strong></p>
<h3 id="实体组件生命周期相关"><a href="#实体组件生命周期相关" class="headerlink" title="实体组件生命周期相关"></a>实体组件生命周期相关</h3><p>Awake Update LateUpdate Destory</p>
<h3 id="Publish-自定义的抛事件方法"><a href="#Publish-自定义的抛事件方法" class="headerlink" title="Publish 自定义的抛事件方法"></a>Publish 自定义的抛事件方法</h3><h5 id="类比dll的单项依赖，防止互相依赖"><a href="#类比dll的单项依赖，防止互相依赖" class="headerlink" title="类比dll的单项依赖，防止互相依赖"></a>类比dll的单项依赖，防止互相依赖</h5><h5 id="模块隔离"><a href="#模块隔离" class="headerlink" title="模块隔离"></a>模块隔离</h5><h5 id="同步异步"><a href="#同步异步" class="headerlink" title="同步异步"></a>同步异步</h5><p>异步Publish，等待订阅者完成操作后，发布者才会进行后面逻辑</p>
<h5 id="SceneType"><a href="#SceneType" class="headerlink" title="SceneType"></a>SceneType</h5><p>all in one的设计，用来区分是客户端还是服务端</p>
<p>服务端也能用来做进程间的限制</p>
<h5 id="全局事件-静态事件"><a href="#全局事件-静态事件" class="headerlink" title="全局事件(静态事件)"></a>全局事件(静态事件)</h5><p>动态事件的绑定都有一个绑定的过程，需要额外管理什么时候监听并且什么时候释放。在查看代码时，需要查看监听的绑定调用，会降低可读性。</p>
<p>不需要每个监听类都有一个callback，只有全局的callback。</p>
<h3 id="Invoke"><a href="#Invoke" class="headerlink" title="Invoke"></a>Invoke</h3><p>相当于回调。取决于怎么去触发回调。</p>
<p>根据id分发。程序启动时把响应方法注册进EventSystem内。</p>
<h3 id="Invoke和Publish的区别"><a href="#Invoke和Publish的区别" class="headerlink" title="Invoke和Publish的区别"></a>Invoke和Publish的区别</h3><p>Publish抛出去不关心结果不关心订阅者的，Invoke是主动调用(类似函数)需要知道函数真实存在。</p>
<p>Publish区分SceneType，Invoke没有区分</p>
<p>Publish没有分发作用，Invoke带有分发作用</p>
<p>Publish一对多，Invoke一对一</p>
<p>Publish跟Invoke命名不同，Publish命名跟时间点相关，Invoke命名跟使用者相关</p>
<h3 id="TypeSystem"><a href="#TypeSystem" class="headerlink" title="TypeSystem"></a>TypeSystem</h3><p>每个Type都有一个对应的OneTypeSystems</p>
<h4 id="OneTypeSystems"><a href="#OneTypeSystems" class="headerlink" title="OneTypeSystems"></a>OneTypeSystems</h4><p>OneTypeSystems中的QueueFlag记录实现了哪些生命周期，ISystemType中的GetInstanceQueueIndex可以获取到 生命周期的Index</p>
<p>当Entity实例化时通过OneTypeSystems取生命周期的Flag</p>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>按照生命周期的Flag来缓存需要生命周期的组件ID队列，因为组件可能被对象池回收，所以缓存组件ID</p>
<h2 id="第十四节-序列化反序列化"><a href="#第十四节-序列化反序列化" class="headerlink" title="第十四节 序列化反序列化"></a>第十四节 序列化反序列化</h2><h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><p>Excel配置文件，编辑器配置文件，大小跟速度都无所谓</p>
<p>网络消息 大小速度很重要</p>
<p>Entity对象，很复杂，需要支持继承等复杂特性</p>
<p>数据库，mongodb</p>
<p>命令行</p>
<h3 id="库的选择"><a href="#库的选择" class="headerlink" title="库的选择"></a>库的选择</h3><p>Google Protobuf 性能最好，代码生成复杂不容易扩展，容易无gc</p>
<p>Protobuf-net 性能较好，代码简洁，使用最广泛。使用反射机制不好定制</p>
<p>MessagePack 性能较好，代码简洁，其他语言使用少</p>
<p>Mongo.Bson 性能较差，功能最强，并且支持Json</p>
<p>选择Protobuf-net跟MongoDB，满足任何需求</p>
<h4 id="Protobuf-net"><a href="#Protobuf-net" class="headerlink" title="Protobuf-net"></a>Protobuf-net</h4><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>为了支持protobuf的格式，需要在父类上打标签表示继承关系</p>
<figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">ProtoContract</span>]<br>[<span class="hljs-meta">ProtoInclude(3,typeof(BB))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AA</span>{<br>    [<span class="hljs-meta">ProtoMember(1)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> a;<br>    [<span class="hljs-meta">ProtoMember(2)</span>]<br>    <span class="hljs-keyword">public</span> float3 pos;<br>}<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BB</span>:<span class="hljs-title">AA</span>{<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> b;<br>}<br></code></pre></td></tr></tbody></table></figure>

<h5 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h5><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">RuntimeTypeModel.Default.<span class="hljs-keyword">add</span>(<span class="hljs-keyword">typeof</span>(float3),<span class="hljs-literal">false</span>).<span class="hljs-keyword">add</span>(<span class="hljs-string">"x"</span>,<span class="hljs-string">"y"</span>,<span class="hljs-string">"z"</span>);<br>AA aa = <span class="hljs-keyword">new</span> AA(){<br>    a =<span class="hljs-number">1</span>,<br>    pos = <span class="hljs-keyword">new</span> float3(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br>}<br></code></pre></td></tr></tbody></table></figure>

<h4 id="Mongo-Bson"><a href="#Mongo-Bson" class="headerlink" title="Mongo Bson"></a>Mongo Bson</h4><p>MongoDB的C#库，把C#对象序列化成MongoDB可以用的格式，也可以转换成其他格式，并且支持嵌套。</p>
<h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ul>
<li>Bsonld<ul>
<li>每条数据都需要有一个Bsonld，如果没有赋值会默认给个96位的Id</li>
</ul>
</li>
<li>BsonElement<ul>
<li>private字段需要序列化字段的标签</li>
<li>可以重命名，可以取个别名可以节省空间。序列化反序列速度也能提升</li>
</ul>
</li>
<li>Bsonlgnore<ul>
<li>public字段不需要序列化的标签</li>
</ul>
</li>
<li>BsonDefaultValue<ul>
<li>没有赋值则取默认值</li>
</ul>
</li>
<li>BsonlgnoreIfDefault<ul>
<li>如果是默认值则 序列化过程中不进行序列化</li>
</ul>
</li>
</ul>
<h5 id="子类默认不能反序列化成父类"><a href="#子类默认不能反序列化成父类" class="headerlink" title="子类默认不能反序列化成父类"></a>子类默认不能反序列化成父类</h5><p><code>BsonIgnoreExtraElements</code>加上则在反序列化过程中排除多余的字段</p>
<p>每个都加比较麻烦，Mongo Bson提供了默认操作</p>
<figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 自动注册IgnoreExtraElements</span><br>ConventionPack conventionPack = <span class="hljs-keyword">new</span> ConventionPack { <span class="hljs-keyword">new</span> IgnoreExtraElementsConvention(<span class="hljs-literal">true</span>) };<br><br>ConventionRegistry.Register(<span class="hljs-string">"IgnoreExtraElements"</span>, conventionPack, type =&gt; <span class="hljs-literal">true</span>);<br></code></pre></td></tr></tbody></table></figure>

<h5 id="StructBsonSerialize"><a href="#StructBsonSerialize" class="headerlink" title="StructBsonSerialize"></a>StructBsonSerialize</h5><p>注册了结构体后可以反序列化成结构体</p>
<h5 id="BsonDictionaryOptions"><a href="#BsonDictionaryOptions" class="headerlink" title="BsonDictionaryOptions"></a>BsonDictionaryOptions</h5><p>字典序列化时，默认的key需要为string。因为默认的json库的key是string类型</p>
<p><code>BsonDictionaryOptions</code>提供了多种字典序列化方式</p>
<p>一般用ArrayOfArray的形式</p>
<h5 id="BsonClassMap-LookupClassMap"><a href="#BsonClassMap-LookupClassMap" class="headerlink" title="BsonClassMap.LookupClassMap"></a>BsonClassMap.LookupClassMap</h5><p>mongo在序列化时会记录继承关系，反序列化则会成功。</p>
<p>但是如果直接进行反序列化，mongo默认不知道继承关系则会失败。 </p>
<p>把每个类型都进行注册<code>BsonClassMap.LookupClassMap(type)</code></p>
<h5 id="标准json格式"><a href="#标准json格式" class="headerlink" title="标准json格式"></a>标准json格式</h5><p>MongoHelper.ToJson时可以传入设置，则为标准json格式。</p>
<h3 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h3><p>ISerializeToEntity ComponentDB ChildrenDB</p>
<p>DeserializeSystem 反序列化后执行的System</p>
<h2 id="第十五节-Network-1"><a href="#第十五节-Network-1" class="headerlink" title="第十五节 Network-1"></a>第十五节 Network-1</h2><ul>
<li>socket</li>
<li>IP</li>
<li>Port</li>
<li>bind</li>
<li>accept</li>
<li>connect<ul>
<li>分为阻塞和非阻塞</li>
</ul>
</li>
<li>read<ul>
<li>分为阻塞和非阻塞</li>
<li>socket有缓冲区，read需要等缓冲区满了才会进行读取。</li>
</ul>
</li>
<li>write<ul>
<li>分为阻塞和非阻塞</li>
<li>socket有缓冲区，write等缓存去满了才会进行write操作</li>
</ul>
</li>
</ul>
<h3 id="ET的需求"><a href="#ET的需求" class="headerlink" title="ET的需求"></a>ET的需求</h3><h4 id="一个主线程-一个网络线程"><a href="#一个主线程-一个网络线程" class="headerlink" title="一个主线程 一个网络线程"></a>一个主线程 一个网络线程</h4><p>网络独立线程后不好做，对客户端而言很难实现0gc的操作不能用对象池，客户端对网络性能的需求没那么高。</p>
<p>对服务端而言，不是复杂场景下单线程网络线程基本满足需求。</p>
<h4 id="单进程有多个监听-accept-all-in-one"><a href="#单进程有多个监听-accept-all-in-one" class="headerlink" title="单进程有多个监听(accept)	all in one"></a>单进程有多个监听(accept)	all in one</h4><h4 id="序列化跟反序列化在网络线程，减轻主线程压力"><a href="#序列化跟反序列化在网络线程，减轻主线程压力" class="headerlink" title="序列化跟反序列化在网络线程，减轻主线程压力"></a>序列化跟反序列化在网络线程，减轻主线程压力</h4><p>如果放在主线程序列化和反序列化就会造成，在序列化后发送请求时，网络线程可能还需要等待一段时间后才会真正发送。这个时间片段内主线程又重新发送了相同的请求，如果使用了对象池就会修改到前面请求的数据。因为对象池是单线程的。</p>
<h3 id="ET的设计"><a href="#ET的设计" class="headerlink" title="ET的设计"></a>ET的设计</h3><p>抽象出NetService来处理主线程跟网络线程通信</p>
<p>抽象出AService来处理监听，管理连接</p>
<p>抽象出AChannel(网络连接)来做消息收发</p>
<p>多个AService注册到NetService</p>
<p>主线程封装NetComponent处理收到的连接，消息，错误</p>
<p>主线程封装Session做主线程消息发送，以及rpc</p>
<h3 id="NetServices线程安全队列"><a href="#NetServices线程安全队列" class="headerlink" title="NetServices线程安全队列"></a>NetServices线程安全队列</h3><p>NetServices主要负责主线程跟网络线程之间的通信</p>
<p>主线程-&gt;网络线程：</p>
<ol>
<li>创建连接创建Channel</li>
<li>发送消息给Channel发送</li>
</ol>
<p>网络线程-&gt;主线程: </p>
<ol>
<li>接收连接创建Session</li>
<li>接收消息回调主线程</li>
<li>网络错误回调</li>
</ol>
<p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230720100918090.png" srcset="/img/loading.gif" lazyload alt="image-20230720100918090"></p>
<h4 id="主线程回调函数"><a href="#主线程回调函数" class="headerlink" title="主线程回调函数"></a>主线程回调函数</h4><ul>
<li>acceptCallback</li>
<li>readCallback</li>
<li>errorCallback</li>
</ul>
<h4 id="Service管理"><a href="#Service管理" class="headerlink" title="Service管理"></a>Service管理</h4><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ConcurrentDictionary&lt;<span class="hljs-built_in">long</span>, AService&gt; services = <span class="hljs-keyword">new</span>();<br></code></pre></td></tr></tbody></table></figure>

<h4 id="多线程注意事项"><a href="#多线程注意事项" class="headerlink" title="多线程注意事项"></a>多线程注意事项</h4><ul>
<li><p>除了线程队列，一个成员永远只能一个线程操作</p>
<ul>
<li>一个方法永远只能跑在一个线程中，如果方法内操作了成员非常危险。</li>
</ul>
</li>
<li><p>非常清楚每个字段是哪个线程操作的，绝对不能出错</p>
</li>
<li><p><strong>NetOperator</strong>，跨线程消息要注意</p>
<ul>
<li><p>只通过跨线程的消息做跨线程的处理</p>
</li>
<li><p>只通过双队列进行跨线程的数据传递，通过Update来取出双队列的数据。</p>
</li>
</ul>
 <figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ConcurrentQueue&lt;NetOperator&gt; netThreadOperators = <span class="hljs-keyword">new</span> ConcurrentQueue&lt;NetOperator&gt;();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ConcurrentQueue&lt;NetOperator&gt; mainThreadOperators = <span class="hljs-keyword">new</span> ConcurrentQueue&lt;NetOperator&gt;(); <br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="第十六节-Network-2"><a href="#第十六节-Network-2" class="headerlink" title="第十六节 Network -2"></a>第十六节 Network -2</h2><h3 id="TCP特点"><a href="#TCP特点" class="headerlink" title="TCP特点"></a>TCP特点</h3><p><strong>监听的socket  监听到连接后，会返回读写的socket</strong></p>
<p><strong>TODO：看看TService和Tchannel</strong></p>
<p><strong>面向连接的协议，syn ask fin</strong> <strong>三次握手</strong></p>
<p><strong>可靠有序</strong></p>
<p><strong>滑动窗口</strong></p>
<p>告诉发送方还能发多少还能接受多少数据，避免一次性发送过多，把缓冲区发爆了</p>
<p><strong>拥塞窗口</strong></p>
<p>发现丢包就控制下发包数量，未确认的包过多时，则会等待确认后再发包。控制发包速度。</p>
<p>一旦发生丢包，发送速度会指数型的下降。但是恢复则是线性的增长。</p>
<p><strong>流</strong></p>
<p>只保证数据会发送到，不保证顺序和完整性。</p>
<h3 id="TCP实现"><a href="#TCP实现" class="headerlink" title="TCP实现"></a>TCP实现</h3><ul>
<li>CPP包装</li>
<li>BindSend EndSend</li>
<li>TcpListener TcpClient NetworkSteam<ul>
<li>c#提供的tcpsocket包装有少量GC</li>
</ul>
</li>
<li>SocketAsyncEventArgs<ul>
<li>用这个做异步回调，没有gc</li>
<li>TService</li>
<li>TChannel</li>
</ul>
</li>
<li>System.IO.Pipelines</li>
</ul>
<p>异步回调</p>
<ul>
<li>TService Listem</li>
<li>TChannel Read Write</li>
</ul>
<h3 id="IOCP线程，网络线程"><a href="#IOCP线程，网络线程" class="headerlink" title="IOCP线程，网络线程"></a>IOCP线程，网络线程</h3><p>windos下的网络异步api是完成端口。异步回调是在IO线程内。</p>
<ul>
<li>SocketAsyncEventArgs的回调<ul>
<li>回调是在另外一个线程，并不是在哪里调用就是在哪个线程。需要扔回网络线程处理</li>
</ul>
</li>
<li>ConcurrentQueue<targs><ul>
<li>网络线程处理回调的队列，收到回调时会塞数据到队列中。网络线程Update轮询拿出数据</li>
</ul>
</targs></li>
<li>TArgs<ul>
<li>类似于NetOperator，用作线程间的传递</li>
</ul>
</li>
</ul>
<h3 id="CircularBuffer"><a href="#CircularBuffer" class="headerlink" title="CircularBuffer"></a>CircularBuffer</h3><p>减少Read和Write的调用</p>
<p>把异步的操作变成同步操作(和缓冲队列同理，写入和读取都是同步的)</p>
<p>socket是在内核里的，每次调用socket的代价算是比较大的。</p>
<ul>
<li>recvBuffer<ul>
<li>socket写入，应用层取出调用</li>
</ul>
</li>
<li>sendBuffer<ul>
<li>应用层写入，socket取出调用</li>
</ul>
</li>
</ul>
<p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230726193709984.png" srcset="/img/loading.gif" lazyload alt="image-20230726193709984"></p>
<h3 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h3><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230726195506719.png" srcset="/img/loading.gif" lazyload alt="image-20230726195506719"></p>
<p><code>PacketParser类</code>解析消息</p>
<h3 id="遇到的问题-1"><a href="#遇到的问题-1" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><ul>
<li>堆栈溢出<ul>
<li>TChannel.StartSend()内的while循环，之前是用递归写的。递归造成的问题就是调用的层数太多，会造成堆栈溢出</li>
</ul>
</li>
<li>Tcp在linux上占用过多线程， cpu占用过多，不好观察性能</li>
</ul>
<h2 id="第十七节-Network-3"><a href="#第十七节-Network-3" class="headerlink" title="第十七节 Network -3"></a>第十七节 Network -3</h2><h3 id="TCP的问题"><a href="#TCP的问题" class="headerlink" title="TCP的问题"></a>TCP的问题</h3><ul>
<li>有连接<ul>
<li>内核内，无法定制</li>
<li>不需要断开连接的时候被断开连接</li>
</ul>
</li>
<li>拥塞控制算法</li>
<li>丢包重传算法</li>
<li>ICMP<ul>
<li>TCP层发送的数据无法到达时，IP层会进行通知</li>
<li>上层无法控制</li>
</ul>
</li>
<li>容易破解<ul>
<li>容易创建中间连接，中间连接容易破解数据</li>
</ul>
</li>
<li>内核，不好定制</li>
</ul>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ul>
<li>无连接</li>
<li>不可靠</li>
<li>无序</li>
</ul>
<h3 id="KCP"><a href="#KCP" class="headerlink" title="KCP"></a>KCP</h3><ul>
<li>应用层连接</li>
<li>可靠有序<ul>
<li>模拟tcp</li>
</ul>
</li>
<li>数据冗余，降低丢包影响</li>
<li>拥塞控制</li>
<li>好定制</li>
<li>http3.0</li>
</ul>
<h3 id="ET-KCP改进"><a href="#ET-KCP改进" class="headerlink" title="ET KCP改进"></a>ET KCP改进</h3><ul>
<li>KCP默认连接端才有conn，ET双端都有conn<ul>
<li>PS：conn连接号</li>
</ul>
</li>
<li>默认客户端只能一个socket一个连接，ET一个socket可以发起多个连接<ul>
<li>因为双端都有conn带来的好处</li>
</ul>
</li>
<li>ikcp_input修改<ul>
<li>客户端和服务端各有各的连接号，需要删除连接号的判断条件</li>
<li><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230727093218220.png" srcset="/img/loading.gif" lazyload alt="image-20230727093218220"></li>
</ul>
</li>
</ul>
<h4 id="KCP改造"><a href="#KCP改造" class="headerlink" title="KCP改造"></a>KCP改造</h4><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230727101112402.png" srcset="/img/loading.gif" lazyload alt="image-20230727101112402"></p>
<h5 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h5><p>标识这条消息的类型，连接消息、断开消息、确认消息等等</p>
<p><code>TService.Recv()</code></p>
<ul>
<li>SYN<ul>
<li>accept</li>
</ul>
</li>
<li>ACK<ul>
<li>connect返回</li>
<li>一旦连接成功开始发送缓冲队列里的包</li>
</ul>
</li>
<li>FIN<ul>
<li>连接断开</li>
</ul>
</li>
<li>MSG<ul>
<li>包体信息</li>
</ul>
</li>
</ul>
<h5 id="Conn"><a href="#Conn" class="headerlink" title="Conn"></a>Conn</h5><p>一条消息会带自己的连接号和对面的连接号，保证无法被攻击。第三方无法读到这两个连接号。每条消息回来都会进行校验。</p>
<h5 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h5><p>消息的内容</p>
<h4 id="KCP握手"><a href="#KCP握手" class="headerlink" title="KCP握手"></a>KCP握手</h4><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230727101932122.png" srcset="/img/loading.gif" lazyload alt="image-20230727101932122"></p>
<ol>
<li>连接方发送握手请求，发送自己的LocalConn。被连接方，收到请求后创建自己的LocalConn并且记录RemoteConn(对方的连接号)</li>
<li>ack回复，带上双方的Conn。连接方校验自己的连接号后创建连接<ol>
<li>ack也可能会丢包，连接方会重复发送syn请求连接</li>
</ol>
</li>
<li>为什么少了一次连接方的ack？因为等被连接方发送第一条msg就能表示连接成功</li>
</ol>
<h4 id="KCP收消息流程"><a href="#KCP收消息流程" class="headerlink" title="KCP收消息流程"></a>KCP收消息流程</h4><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230727103406008.png" srcset="/img/loading.gif" lazyload alt="image-20230727103406008"></p>
<h5 id="kcp-lib"><a href="#kcp-lib" class="headerlink" title="kcp lib"></a>kcp lib</h5><p>c编写的Kcp库，收到的消息会丢到kcp库执行</p>
<p>可能会做排序、可靠性检查等操作(与TCP类似)</p>
<ol>
<li>KcpInput <ul>
<li>接受到消息后输入到kcp lib库内执行 排序、检查等操作</li>
</ul>
</li>
<li>KcpPeeksize <ul>
<li>扔进库后，马上查询kcp lib有没有拼装出完整的包，如果有完整包则读取到应用层</li>
</ul>
</li>
<li>KcpRecv <ul>
<li>应用层 通过 kcp lib中返回的数据包，在通过kcp lib读取消息</li>
</ul>
</li>
</ol>
<h4 id="KCP发消息流程"><a href="#KCP发消息流程" class="headerlink" title="KCP发消息流程"></a>KCP发消息流程</h4><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230727110904752.png" srcset="/img/loading.gif" lazyload alt="image-20230727110904752"></p>
<ol>
<li>KcpWaitSend<ul>
<li>发送之前的检查，可能网络问题不断重试。或者等待消息超过上限，可能判断连接超时有断开连接的操作。</li>
</ul>
</li>
<li>KcpSend<ul>
<li>发送检查正常时则把需要发送的数据写入到kcp lib中。</li>
<li>kcp lib会把数据拆分成多个片段，判断大小根据设置走。<strong>有些路由限制了udp包的大小，超过500字节的到不了，所以et kcp外网每个udp消息限制是470大小。</strong></li>
</ul>
</li>
<li>KcpSetOutPut<ul>
<li>应用层通过KcpOutPut设置好回调，将回调设置到kcp lib库中。</li>
<li>KcpOutPut用udp协议，回调设置好通过upd发送到kcp lib中。</li>
<li>回调包含一些 发送状态的信息</li>
</ul>
</li>
</ol>
<h4 id="KService-KChannel"><a href="#KService-KChannel" class="headerlink" title="KService KChannel"></a>KService KChannel</h4><h5 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h5><p>KService内有一个Socket，用来收发udp消息。</p>
<p>同步读socket消息时判断<code>Socket.Available&gt;0</code>。当缓冲队列数据量&gt;0时才进行真正读取，虽然是同步的但是不会造成阻塞。</p>
<p>PS:如果当前使用的是非阻止 <a href="https://msdn.microsoft.com/zh-cn/library/system.net.sockets.socket(v=vs.110).aspx">Socket</a>，一种较好的做法是在调用 <a href="https://msdn.microsoft.com/zh-cn/library/26f591ax(v=vs.110).aspx">Receive</a> 之前使用 Available 来确定数据是否排队等待读取。可用的数据即网络缓冲区中排队等待读取的全部数据。如果在网络缓冲区中没有排队的数据，则 Available 返回 0。</p>
<h5 id="KService计时器"><a href="#KService计时器" class="headerlink" title="KService计时器"></a>KService计时器</h5><p>独立的计时器，因为是在网络线程</p>
<h5 id="InitKcp"><a href="#InitKcp" class="headerlink" title="InitKcp"></a>InitKcp</h5><p>具体参数需要结合文档</p>
<p><a href="https://github.com/skywind3000/kcp/wiki/KCP-Basic-Usage#%E5%8D%8F%E8%AE%AE%E9%85%8D%E7%BD%AE">KCP Basic Usage · skywind3000/kcp Wiki (github.com)</a></p>
<figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitKcp</span>()</span><br>{<br>   <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.Service.ServiceType)<br>   {<br>      <span class="hljs-keyword">case</span> ServiceType.Inner:<br>         <span class="hljs-keyword">this</span>.kcp.SetNoDelay(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">true</span>);<br>         <span class="hljs-keyword">this</span>.kcp.SetWindowSize(<span class="hljs-number">1024</span>, <span class="hljs-number">1024</span>);<br>         <span class="hljs-comment">//分片包大小</span><br>         <span class="hljs-keyword">this</span>.kcp.SetMtu(<span class="hljs-number">1400</span>); <span class="hljs-comment">// 默认1400</span><br>         <span class="hljs-keyword">this</span>.kcp.SetMinrto(<span class="hljs-number">30</span>);<br>         <span class="hljs-keyword">this</span>.kcp.InitArrayPool(<span class="hljs-number">1600</span>, <span class="hljs-number">10000</span>);<br>         <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> ServiceType.Outer:<br>         <span class="hljs-keyword">this</span>.kcp.SetNoDelay(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">true</span>);<br>         <span class="hljs-keyword">this</span>.kcp.SetWindowSize(<span class="hljs-number">256</span>, <span class="hljs-number">256</span>);<br>         <span class="hljs-keyword">this</span>.kcp.SetMtu(<span class="hljs-number">470</span>);<br>         <span class="hljs-keyword">this</span>.kcp.SetMinrto(<span class="hljs-number">30</span>);<br>         <span class="hljs-keyword">this</span>.kcp.InitArrayPool(<span class="hljs-number">600</span>, <span class="hljs-number">10000</span>);<br>         <span class="hljs-keyword">break</span>;<br>   }<br>}<br></code></pre></td></tr></tbody></table></figure>

<h5 id="大包的实现"><a href="#大包的实现" class="headerlink" title="大包的实现"></a>大包的实现</h5><p>超过大包设置的限定值时，进行分片处理</p>
<h6 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a>发送端</h6><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 先发分片信息</span><br><span class="hljs-comment">// 头部信息，和普通消息做区分，前4个字节是0则代表是分片的包。</span><br><span class="hljs-keyword">this</span>.sendCache.WriteTo(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 5-8字节 包体大小</span><br><span class="hljs-keyword">this</span>.sendCache.WriteTo(<span class="hljs-number">4</span>, count);<br><span class="hljs-keyword">this</span>.kcp.Send(<span class="hljs-keyword">this</span>.sendCache.AsSpan(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>));<br><br><span class="hljs-comment">// 分片发送</span><br><span class="hljs-built_in">int</span> alreadySendCount = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (alreadySendCount &lt; count)<br>{<br>    <span class="hljs-built_in">int</span> leftCount = count - alreadySendCount;<br>    <span class="hljs-built_in">int</span> sendCount = leftCount &lt; AService.MaxCacheBufferSize? leftCount: AService.MaxCacheBufferSize;<br>    <span class="hljs-keyword">this</span>.kcp.Send(memoryStream.GetBuffer().AsSpan((<span class="hljs-built_in">int</span>)memoryStream.Position + alreadySendCount, sendCount));<br><br>    alreadySendCount += sendCount;<br>}<br></code></pre></td></tr></tbody></table></figure>

<h6 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a>接收端</h6><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>{<br>    <span class="hljs-comment">//...一堆判断条件这里省略</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.needReadSplitCount &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 说明消息分片了</span><br>    {<br>        <span class="hljs-built_in">byte</span>[] buffer = readMemory.GetBuffer();<br>        <span class="hljs-built_in">int</span> count = <span class="hljs-keyword">this</span>.kcp.Receive(buffer.AsSpan((<span class="hljs-built_in">int</span>)(<span class="hljs-keyword">this</span>.readMemory.Length - <span class="hljs-keyword">this</span>.needReadSplitCount), n));<br>        <span class="hljs-keyword">this</span>.needReadSplitCount -= count;<br>        <span class="hljs-keyword">if</span> (n != count)<br>        {<br>            Log.Error(<span class="hljs-string">$"kchannel read error1: <span class="hljs-subst">{<span class="hljs-keyword">this</span>.LocalConn}</span> <span class="hljs-subst">{<span class="hljs-keyword">this</span>.RemoteConn}</span>"</span>);<br>            <span class="hljs-keyword">this</span>.OnError(ErrorCore.ERR_KcpReadNotSame);<br>            <span class="hljs-keyword">return</span>;<br>        }<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.needReadSplitCount &lt; <span class="hljs-number">0</span>)<br>        {<br>            Log.Error(<span class="hljs-string">$"kchannel read error2: <span class="hljs-subst">{<span class="hljs-keyword">this</span>.LocalConn}</span> <span class="hljs-subst">{<span class="hljs-keyword">this</span>.RemoteConn}</span>"</span>);<br>            <span class="hljs-keyword">this</span>.OnError(ErrorCore.ERR_KcpSplitError);<br>            <span class="hljs-keyword">return</span>;<br>        }<br><br>        <span class="hljs-comment">// 没有读完</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.needReadSplitCount != <span class="hljs-number">0</span>)<br>        {<br>            <span class="hljs-keyword">continue</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">else</span><br>    {<br>        <span class="hljs-keyword">this</span>.readMemory = <span class="hljs-keyword">this</span>.Service.Fetch(n);<br>        <span class="hljs-keyword">this</span>.readMemory.SetLength(n);<br>        <span class="hljs-keyword">this</span>.readMemory.Seek(<span class="hljs-number">0</span>, SeekOrigin.Begin);<br><br>        <span class="hljs-built_in">byte</span>[] buffer = readMemory.GetBuffer();<br><br>        <span class="hljs-built_in">int</span> count = <span class="hljs-keyword">this</span>.kcp.Receive(buffer.AsSpan(<span class="hljs-number">0</span>, n));<br>        <span class="hljs-keyword">if</span> (n != count)<br>        {<br>            <span class="hljs-keyword">break</span>;<br>        }<br><br>        <span class="hljs-comment">// 如果是8字节代表有可能是分片包</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">8</span>)<br>        {<br>            <span class="hljs-comment">// 如果前4个字节是0则代表是分片包</span><br>            <span class="hljs-built_in">int</span> headInt = BitConverter.ToInt32(<span class="hljs-keyword">this</span>.readMemory.GetBuffer(), <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (headInt == <span class="hljs-number">0</span>)<br>            {<br>                <span class="hljs-keyword">this</span>.needReadSplitCount = BitConverter.ToInt32(readMemory.GetBuffer(), <span class="hljs-number">4</span>);<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.needReadSplitCount &lt;= AService.MaxCacheBufferSize)<br>                {<br>                    Log.Error(<span class="hljs-string">$"kchannel read error3: <span class="hljs-subst">{<span class="hljs-keyword">this</span>.needReadSplitCount}</span> <span class="hljs-subst">{<span class="hljs-keyword">this</span>.LocalConn}</span> <span class="hljs-subst">{<span class="hljs-keyword">this</span>.RemoteConn}</span>"</span>);<br>                    <span class="hljs-keyword">this</span>.OnError(ErrorCore.ERR_KcpSplitCountError);<br>                    <span class="hljs-keyword">return</span>;<br>                }<br>                <span class="hljs-comment">//打包的长度</span><br>                <span class="hljs-keyword">this</span>.readMemory.SetLength(<span class="hljs-keyword">this</span>.needReadSplitCount);<br>                <span class="hljs-keyword">this</span>.readMemory.Seek(<span class="hljs-number">0</span>, SeekOrigin.Begin);<br>                <span class="hljs-keyword">continue</span>;<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<h5 id="代码实现细节"><a href="#代码实现细节" class="headerlink" title="代码实现细节"></a>代码实现细节</h5><h6 id="设置缓冲区"><a href="#设置缓冲区" class="headerlink" title="设置缓冲区"></a>设置缓冲区</h6><p>一个socket对应多条回调的连接监听，缓存区太小容易爆掉</p>
<p><strong>OSX平台无效</strong></p>
<figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">if</span> (!RuntimeInformation.IsOSPlatform(OSPlatform.OSX))<br>{<br>    <span class="hljs-keyword">this</span>.Socket.SendBufferSize = Kcp.OneM * <span class="hljs-number">64</span>;<br>    <span class="hljs-keyword">this</span>.Socket.ReceiveBufferSize = Kcp.OneM * <span class="hljs-number">64</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>

<h6 id="发送时的RemoteConn设置"><a href="#发送时的RemoteConn设置" class="headerlink" title="发送时的RemoteConn设置"></a>发送时的RemoteConn设置</h6><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Output</span>(<span class="hljs-params"><span class="hljs-built_in">byte</span>[] bytes, <span class="hljs-built_in">int</span> count</span>)</span><br>{<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.IsDisposed)<br>    {<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    <span class="hljs-keyword">try</span><br>    {           <br>        <span class="hljs-comment">// 没连接上 kcp不往外发消息, 其实本来没连接上不会调用update，这里只是做一层保护</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.IsConnected)<br>        {<br>            <span class="hljs-keyword">return</span>;<br>        }<br><br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>)<br>        {<br>            Log.Error(<span class="hljs-string">$"output 0"</span>);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        bytes.WriteTo(<span class="hljs-number">0</span>, KcpProtocalType.MSG);<br>        <span class="hljs-comment">// 每个消息头部写下该channel的id;</span><br>        bytes.WriteTo(<span class="hljs-number">1</span>, <span class="hljs-keyword">this</span>.LocalConn);<br>        <span class="hljs-comment">//这里只写入了LocalConn没有写入RemoteConn，是因为输入的bytes就带了RemoteConn</span><br>        <span class="hljs-keyword">this</span>.Service.Socket.SendTo(bytes, <span class="hljs-number">0</span>, count + <span class="hljs-number">5</span>, SocketFlags.None, <span class="hljs-keyword">this</span>.RemoteAddress);<br>    }<br></code></pre></td></tr></tbody></table></figure>

<h6 id="SetSioUdpConnReset"><a href="#SetSioUdpConnReset" class="headerlink" title="SetSioUdpConnReset"></a>SetSioUdpConnReset</h6><p>只在window平台存在的问题。设置屏蔽</p>
<p>a向b发送upd的包，a如果关闭了socket会通知b也需要关闭socket</p>
<h6 id="KChannel连接"><a href="#KChannel连接" class="headerlink" title="KChannel连接"></a>KChannel连接</h6><p>没连接成功前300毫秒发送一次请求连接。</p>
<figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> timeNow</span>)</span><br>{<br>    <span class="hljs-keyword">try</span><br>    {<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.IsConnected)<br>        {<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-comment">// 300毫秒后再次update发送connect请求</span><br>        <span class="hljs-keyword">if</span> (timeNow &lt; <span class="hljs-keyword">this</span>.lastConnectTime + <span class="hljs-number">300</span>)<br>        {<br>            <span class="hljs-comment">//加到Service的updateChannel里做轮询连接</span><br>            <span class="hljs-keyword">this</span>.Service.AddToUpdate(<span class="hljs-number">300</span>, <span class="hljs-keyword">this</span>.Id);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-comment">// 10秒连接超时</span><br>        <span class="hljs-keyword">if</span> (timeNow &gt; <span class="hljs-keyword">this</span>.CreateTime + KService.ConnectTimeoutTime)<br>        {<br>            Log.Error(<span class="hljs-string">$"kChannel connect timeout: <span class="hljs-subst">{<span class="hljs-keyword">this</span>.Id}</span> <span class="hljs-subst">{<span class="hljs-keyword">this</span>.RemoteConn}</span> <span class="hljs-subst">{timeNow}</span> <span class="hljs-subst">{<span class="hljs-keyword">this</span>.CreateTime}</span> <span class="hljs-subst">{<span class="hljs-keyword">this</span>.ChannelType}</span> <span class="hljs-subst">{<span class="hljs-keyword">this</span>.RemoteAddress}</span>"</span>);<br>            <span class="hljs-keyword">this</span>.OnError(ErrorCore.ERR_KcpConnectTimeout);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-built_in">byte</span>[] buffer = sendCache;<br>        buffer.WriteTo(<span class="hljs-number">0</span>, KcpProtocalType.SYN);<br>        buffer.WriteTo(<span class="hljs-number">1</span>, <span class="hljs-keyword">this</span>.LocalConn);<br>        buffer.WriteTo(<span class="hljs-number">5</span>, <span class="hljs-keyword">this</span>.RemoteConn);<br>        <span class="hljs-keyword">this</span>.Service.Socket.SendTo(buffer, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>, SocketFlags.None, <span class="hljs-keyword">this</span>.RemoteAddress);<br>        <span class="hljs-comment">// 这里很奇怪 调用socket.LocalEndPoint会动到this.RemoteAddressNonAlloc里面的temp，这里就不仔细研究了</span><br>        Log.Info(<span class="hljs-string">$"kchannel connect <span class="hljs-subst">{<span class="hljs-keyword">this</span>.LocalConn}</span> <span class="hljs-subst">{<span class="hljs-keyword">this</span>.RemoteConn}</span> <span class="hljs-subst">{<span class="hljs-keyword">this</span>.RealAddress}</span>"</span>);<br><br>        <span class="hljs-keyword">this</span>.lastConnectTime = timeNow;<br><br>        <span class="hljs-keyword">this</span>.Service.AddToUpdate(<span class="hljs-number">300</span>, <span class="hljs-keyword">this</span>.Id);<br>    }<br>    <span class="hljs-keyword">catch</span> (Exception e)<br>    {<br>        Log.Error(e);<br>        <span class="hljs-keyword">this</span>.OnError(ErrorCore.ERR_SocketCantSend);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<h2 id="第十八节-Network-4"><a href="#第十八节-Network-4" class="headerlink" title="第十八节 Network -4"></a>第十八节 Network -4</h2><h3 id="NetworkComponent"><a href="#NetworkComponent" class="headerlink" title="NetworkComponent"></a>NetworkComponent</h3><ol>
<li>处理收消息，接收连接，错误等回调<ul>
<li>NetClientComponent</li>
<li>NetServerComponent</li>
<li>NetInnerComponent<ul>
<li>内部进程通信</li>
</ul>
</li>
</ul>
</li>
<li>管理主动的连接跟accept的连接</li>
</ol>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><ol>
<li>发消息</li>
<li>rpc</li>
</ol>
<p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230727152954789.png" srcset="/img/loading.gif" lazyload alt="image-20230727152954789"></p>
<h3 id="配合主线程网络的组件"><a href="#配合主线程网络的组件" class="headerlink" title="配合主线程网络的组件"></a>配合主线程网络的组件</h3><h4 id="OpcodeTypeComponent"><a href="#OpcodeTypeComponent" class="headerlink" title="OpcodeTypeComponent"></a>OpcodeTypeComponent</h4><ol>
<li>记录外网消息</li>
<li>记录Request跟Response配对</li>
</ol>
<h4 id="MessageDispatcherComponent"><a href="#MessageDispatcherComponent" class="headerlink" title="MessageDispatcherComponent"></a>MessageDispatcherComponent</h4><p>协议消息的分发</p>
<p>根据Opcode管理具体的事件队列</p>
<figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> Dictionary&lt;<span class="hljs-built_in">ushort</span>, List&lt;MessageDispatcherInfo&gt;&gt; Handlers = <span class="hljs-keyword">new</span>();<br></code></pre></td></tr></tbody></table></figure>

<figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MessageDispatcherInfo</span><br>{<br>    <span class="hljs-keyword">public</span> SceneType SceneType { <span class="hljs-keyword">get</span>; }<br>    <span class="hljs-keyword">public</span> IMHandler IMHandler { <span class="hljs-keyword">get</span>; }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MessageDispatcherInfo</span>(<span class="hljs-params">SceneType sceneType, IMHandler imHandler</span>)</span><br>    {<br>        <span class="hljs-keyword">this</span>.SceneType = sceneType;<br>        <span class="hljs-keyword">this</span>.IMHandler = imHandler;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>程序启动时，根据Handler标签进行注册绑定。</p>
<h5 id="Handler划分"><a href="#Handler划分" class="headerlink" title="Handler划分"></a>Handler划分</h5><ul>
<li>AMHandler<ul>
<li>正常调用，没有返回值</li>
</ul>
</li>
<li>AMRpcHandler<ul>
<li>Rpc调用会创建Response返回并发送给对面</li>
</ul>
</li>
</ul>
<h4 id="SessionAcceptTimeoutComponent"><a href="#SessionAcceptTimeoutComponent" class="headerlink" title="SessionAcceptTimeoutComponent"></a>SessionAcceptTimeoutComponent</h4><p>连接长时间占用消耗资源</p>
<p><code>SessionAcceptTimeoutComponent</code>维护连接的时长，持有该组件并且超过限定时间则进行断开连接。</p>
<p>一些外挂会长时间连接只监听消息</p>
<h4 id="PingComponent"><a href="#PingComponent" class="headerlink" title="PingComponent"></a>PingComponent</h4><p>心跳包组件，与SessionIdleCheckerComponent对应</p>
<p>客户端挂上PingComponent，每固定时间发送消息。保持连接</p>
<h4 id="SessionIdleCheckerComponent"><a href="#SessionIdleCheckerComponent" class="headerlink" title="SessionIdleCheckerComponent"></a>SessionIdleCheckerComponent</h4><p>Session挂上SessionIdleCheckerComponent，超过时间没收到PingComponent判断为断开</p>
<h4 id="SessionMessageStatisticsComponent"><a href="#SessionMessageStatisticsComponent" class="headerlink" title="SessionMessageStatisticsComponent"></a>SessionMessageStatisticsComponent</h4><p>ET里没有这个组件</p>
<p>记录一段时间内收了多少条客户端消息。判断是否被发起攻击或者写出bug。检测出异常。</p>
<h2 id="第十九节-软路由"><a href="#第十九节-软路由" class="headerlink" title="第十九节 软路由"></a>第十九节 软路由</h2><p>防止黑客攻击的功能</p>
<h3 id="黑客攻击"><a href="#黑客攻击" class="headerlink" title="黑客攻击"></a>黑客攻击</h3><h4 id="tcp连接攻击"><a href="#tcp连接攻击" class="headerlink" title="tcp连接攻击"></a>tcp连接攻击</h4><p>黑客创建很多肉鸡创建很多tcp连接，tcp连接消耗内存会把服务器挤爆。</p>
<h4 id="流量攻击"><a href="#流量攻击" class="headerlink" title="流量攻击"></a>流量攻击</h4><p>不停发消息，把流量吃满。接受不到正常玩家消息也发送不出去</p>
<h4 id="协议攻击"><a href="#协议攻击" class="headerlink" title="协议攻击"></a>协议攻击</h4><p>破解协议，发送莫名其妙的东西</p>
<h3 id="Http防攻击"><a href="#Http防攻击" class="headerlink" title="Http防攻击"></a>Http防攻击</h3><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230728163810320.png" srcset="/img/loading.gif" lazyload alt="image-20230728163810320"></p>
<p>http防攻击是每次http请求都通过cdn进行中介请求，实际上被攻击的会是cdn。一台崩了其他的还是正常运行。</p>
<h3 id="游戏跟http不同"><a href="#游戏跟http不同" class="headerlink" title="游戏跟http不同"></a>游戏跟http不同</h3><ul>
<li>实时性更高</li>
<li>交互性更多<ul>
<li>功能之间交互多，不像http可以拆分成各种服务</li>
</ul>
</li>
<li>逻辑更复杂</li>
<li>服务更集中</li>
<li>长连接</li>
</ul>
<h3 id="大部分游戏服务器的弱点"><a href="#大部分游戏服务器的弱点" class="headerlink" title="大部分游戏服务器的弱点"></a>大部分游戏服务器的弱点</h3><ul>
<li>TCP<ul>
<li>只同步协议一样要分配资源</li>
</ul>
</li>
<li>对外地址固定<ul>
<li>对外的地址是公布的，容易暴漏地址</li>
</ul>
</li>
<li>协议过于简单</li>
</ul>
<h3 id="大部分黑客的特点"><a href="#大部分黑客的特点" class="headerlink" title="大部分黑客的特点"></a>大部分黑客的特点</h3><ul>
<li>流量不多<ul>
<li>流量大不会攻击小游戏</li>
</ul>
</li>
<li>攻击单个地址<ul>
<li>成本问题</li>
</ul>
</li>
<li>比较少进行协议破解攻击<ul>
<li>技术含量比较高</li>
</ul>
</li>
</ul>
<h3 id="针对性解决"><a href="#针对性解决" class="headerlink" title="针对性解决"></a>针对性解决</h3><ul>
<li>使用UDP</li>
<li>多个对外地址</li>
<li>提高协议复杂性，提高破解难度</li>
</ul>
<h3 id="防攻击目标"><a href="#防攻击目标" class="headerlink" title="防攻击目标"></a>防攻击目标</h3><ul>
<li>服务器不能受影响</li>
<li>保持连接，不能让在线的玩家掉线</li>
<li>在线玩家无感</li>
</ul>
<h3 id="软路由方案，增加类似CDN的东西"><a href="#软路由方案，增加类似CDN的东西" class="headerlink" title="软路由方案，增加类似CDN的东西"></a>软路由方案，增加类似CDN的东西</h3><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230728171109863.png" srcset="/img/loading.gif" lazyload alt="image-20230728171109863"></p>
<h4 id="软路由设计"><a href="#软路由设计" class="headerlink" title="软路由设计"></a>软路由设计</h4><ul>
<li><p>使用UDP+KCP</p>
<ul>
<li>tcp可以吗？<ul>
<li>软路由如果与客户端用TCP连接，那攻击软路由一样会挂掉</li>
</ul>
</li>
<li>主要利用KCP的有序可靠性</li>
</ul>
</li>
<li><p>一个软路由被攻击，玩家客户端可以切换其它软路由转发</p>
<ul>
<li>客户端发现卡顿时，超过限定时间会切换路由，重新请求连接。gate发现ReConnect请求后会变更软路由的地址连接。</li>
<li>在切换软路由过程中，网关怎么知道发送给软路由的包没真正到达客户端？<ul>
<li>KCP的消息需要确认，收到会发确认包，没收到确认包则会重发。客户端如果收到两条相同的包也会剔除相同的。(KCP底层实现)</li>
</ul>
</li>
</ul>
</li>
<li><p>随时增加减少软路由进程</p>
</li>
<li><p>获取软路由服务，使用cdn保护</p>
<ul>
<li>软路由的地址通过cdn或缺</li>
</ul>
</li>
</ul>
<p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230728173529322.png" srcset="/img/loading.gif" lazyload alt="image-20230728173529322"></p>
<h4 id="RouterComponet"><a href="#RouterComponet" class="headerlink" title="RouterComponet"></a>RouterComponet</h4><p>本质就是校验安全性并且转发的过程</p>
<p>包含一个内网地址和一个外网地址</p>
<figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//正在连接，握手的节点</span><br><span class="hljs-keyword">public</span> Dictionary&lt;<span class="hljs-built_in">uint</span>, RouterNode&gt; ConnectIdNodes = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">uint</span>, RouterNode&gt;();<br><br><span class="hljs-comment">// 已经连接成功的，虽然跟id一样，但是没有经过验证的不会加到这里</span><br><span class="hljs-keyword">public</span> Dictionary&lt;<span class="hljs-built_in">uint</span>, RouterNode&gt; OuterNodes = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">uint</span>, RouterNode&gt;();<br></code></pre></td></tr></tbody></table></figure>

<figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//update轮询查询，内网和外网的监听</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params">RouterComponent self</span>)</span><br>{<br>    <span class="hljs-built_in">long</span> timeNow = TimeHelper.ClientNow();<br>    self.RecvOuter(timeNow);<br>    self.RecvInner(timeNow);<br><br>    <span class="hljs-comment">// 每秒钟检查一次</span><br>    <span class="hljs-keyword">if</span> (timeNow - self.LastCheckTime &gt; <span class="hljs-number">1000</span>)<br>    {<br>        self.CheckConnectTimeout(timeNow);<br>        self.LastCheckTime = timeNow;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>连接与kcp连接不同的是需要告诉路由要连接的地址</p>
<figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">case</span> KcpProtocalType.RouterReconnectSYN:<br>{<br>    <span class="hljs-keyword">if</span> (messageLength &lt; <span class="hljs-number">13</span>)<br>    {<br>        <span class="hljs-keyword">break</span>;<br>    }<br><br>    <span class="hljs-built_in">uint</span> outerConn = BitConverter.ToUInt32(self.Cache, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">uint</span> innerConn = BitConverter.ToUInt32(self.Cache, <span class="hljs-number">5</span>);<br>    <span class="hljs-comment">//要连接路由的地址，后续不需要发送</span><br>    <span class="hljs-built_in">uint</span> connectId = BitConverter.ToUInt32(self.Cache, <span class="hljs-number">9</span>);<br>    <span class="hljs-built_in">string</span> realAddress = self.Cache.ToStr(<span class="hljs-number">13</span>, messageLength - <span class="hljs-number">13</span>);<br><br>    RouterNode routerNode;<br><br>    <span class="hljs-comment">// RouterAck之后ConnectIdNodes会删除，加入到OuterNodes中来</span><br>    <span class="hljs-keyword">if</span> (!self.OuterNodes.TryGetValue(outerConn, <span class="hljs-keyword">out</span> routerNode))<br>    {<br>        self.ConnectIdNodes.TryGetValue(connectId, <span class="hljs-keyword">out</span> routerNode);<br>        <span class="hljs-keyword">if</span> (routerNode == <span class="hljs-literal">null</span>)<br>        {<br>            Log.Info(<span class="hljs-string">$"router create reconnect: <span class="hljs-subst">{self.IPEndPoint}</span> <span class="hljs-subst">{realAddress}</span> <span class="hljs-subst">{connectId}</span> <span class="hljs-subst">{outerConn}</span> <span class="hljs-subst">{innerConn}</span>"</span>);<br>            routerNode = self.New(realAddress, connectId, outerConn, innerConn, self.CloneAddress());<br>            <span class="hljs-comment">// self.OuterNodes 这里不能add，因为还没验证完成,要在RouterAck中加入</span><br>        }<br>    }<br><br>    <span class="hljs-keyword">if</span> (routerNode.ConnectId != connectId)<br>    {<br>        Log.Warning(<span class="hljs-string">$"kcp router router reconnect connectId diff1: <span class="hljs-subst">{routerNode.SyncIpEndPoint}</span> <span class="hljs-subst">{(IPEndPoint) self.IPEndPoint}</span>"</span>);<br>        <span class="hljs-keyword">break</span>;<br>    }<br>    <br>    <span class="hljs-comment">// 不是自己的，outerConn冲突, 直接break,也就是说这个软路由上有个跟自己outerConn冲突的连接，就不能连接了</span><br>    <span class="hljs-comment">// 这个路由连接不上，客户端会换个软路由，所以没关系</span><br>    <span class="hljs-keyword">if</span> (routerNode.InnerConn != innerConn)<br>    {<br>        Log.Warning(<span class="hljs-string">$"kcp router router reconnect inner conn diff1: <span class="hljs-subst">{routerNode.SyncIpEndPoint}</span> <span class="hljs-subst">{(IPEndPoint) self.IPEndPoint}</span>"</span>);<br>        <span class="hljs-keyword">break</span>;<br>    }<br>    <br>    <span class="hljs-keyword">if</span> (routerNode.OuterConn != outerConn)<br>    {<br>        Log.Warning(<span class="hljs-string">$"kcp router router reconnect outer conn diff1: <span class="hljs-subst">{routerNode.SyncIpEndPoint}</span> <span class="hljs-subst">{(IPEndPoint) self.IPEndPoint}</span>"</span>);<br>        <span class="hljs-keyword">break</span>;<br>    }<br><br>    <span class="hljs-comment">// 校验ip，连接过程中ip不能变化</span><br>    <span class="hljs-keyword">if</span> (!Equals(routerNode.SyncIpEndPoint, self.IPEndPoint))<br>    {<br>        Log.Warning(<span class="hljs-string">$"kcp router syn ip is diff1: <span class="hljs-subst">{routerNode.SyncIpEndPoint}</span> <span class="hljs-subst">{(IPEndPoint) self.IPEndPoint}</span>"</span>);<br>        <span class="hljs-keyword">break</span>;<br>    }<br><br>    <span class="hljs-comment">// 校验内网地址</span><br>    <span class="hljs-keyword">if</span> (routerNode.InnerAddress != realAddress)<br>    {<br>        Log.Warning(<span class="hljs-string">$"router sync error2: <span class="hljs-subst">{routerNode.OuterConn}</span> <span class="hljs-subst">{routerNode.InnerAddress}</span> <span class="hljs-subst">{outerConn}</span> <span class="hljs-subst">{realAddress}</span>"</span>);<br>        <span class="hljs-keyword">break</span>;<br>    }<br>    <span class="hljs-comment">//大于40条连接请求则判断为是异常连接</span><br>    <span class="hljs-keyword">if</span> (++routerNode.RouterSyncCount &gt; <span class="hljs-number">40</span>)<br>    {<br>        self.OnError(routerNode.Id, ErrorCore.ERR_KcpRouterRouterSyncCountTooMuchTimes);<br>        <span class="hljs-keyword">break</span>;<br>    }<br><br>    <span class="hljs-comment">// 转发到内网</span><br>    self.Cache.WriteTo(<span class="hljs-number">0</span>, KcpProtocalType.RouterReconnectSYN);<br>    self.Cache.WriteTo(<span class="hljs-number">1</span>, outerConn);<br>    self.Cache.WriteTo(<span class="hljs-number">5</span>, innerConn);<br>    self.Cache.WriteTo(<span class="hljs-number">9</span>, connectId);<br>    self.InnerSocket.SendTo(self.Cache, <span class="hljs-number">0</span>, <span class="hljs-number">13</span>, SocketFlags.None, routerNode.InnerIpEndPoint);<br><br>    <span class="hljs-keyword">if</span> (!routerNode.CheckOuterCount(timeNow))<br>    {<br>        self.OnError(routerNode.Id, ErrorCore.ERR_KcpRouterTooManyPackets);<br>    }<br><br>    <span class="hljs-keyword">break</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>

<h5 id="路由重连"><a href="#路由重连" class="headerlink" title="路由重连"></a>路由重连</h5><p>路由繁忙重新选择路由时，软路由转发给网关，网关会进行remoteConn和localConn的校验，判断只有是链接过的没有造假。并且ip地址不能变化。</p>
<figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">KcpProtocalType.RouterReconnectSYN<br></code></pre></td></tr></tbody></table></figure>

<p>KService的网关校验</p>
<figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">case</span> KcpProtocalType.RouterReconnectSYN:<br>{<br>    <span class="hljs-comment">// 长度!=5，不是RouterReconnectSYN消息</span><br>    <span class="hljs-keyword">if</span> (messageLength != <span class="hljs-number">13</span>)<br>    {<br>        <span class="hljs-keyword">break</span>;<br>    }<br><br>    <span class="hljs-built_in">string</span> realAddress = <span class="hljs-literal">null</span>;<br>    remoteConn = BitConverter.ToUInt32(<span class="hljs-keyword">this</span>.cache, <span class="hljs-number">1</span>);<br>    localConn = BitConverter.ToUInt32(<span class="hljs-keyword">this</span>.cache, <span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">uint</span> connectId = BitConverter.ToUInt32(<span class="hljs-keyword">this</span>.cache, <span class="hljs-number">9</span>);<br><br>    <span class="hljs-keyword">this</span>.localConnChannels.TryGetValue(localConn, <span class="hljs-keyword">out</span> kChannel);<br>    <span class="hljs-keyword">if</span> (kChannel == <span class="hljs-literal">null</span>)<br>    {<br>        Log.Warning(<span class="hljs-string">$"kchannel reconnect not found channel: <span class="hljs-subst">{localConn}</span> <span class="hljs-subst">{remoteConn}</span> <span class="hljs-subst">{realAddress}</span>"</span>);<br>        <span class="hljs-keyword">break</span>;<br>    }<br><br>    <span class="hljs-comment">// 这里必须校验localConn，客户端重连，localConn一定是一样的</span><br>    <span class="hljs-keyword">if</span> (localConn != kChannel.LocalConn)<br>    {<br>        Log.Warning(<span class="hljs-string">$"kchannel reconnect localconn error: <span class="hljs-subst">{localConn}</span> <span class="hljs-subst">{remoteConn}</span> <span class="hljs-subst">{realAddress}</span> <span class="hljs-subst">{kChannel.LocalConn}</span>"</span>);<br>        <span class="hljs-keyword">break</span>;<br>    }<br><br>    <span class="hljs-keyword">if</span> (remoteConn != kChannel.RemoteConn)<br>    {<br>        Log.Warning(<span class="hljs-string">$"kchannel reconnect remoteconn error: <span class="hljs-subst">{localConn}</span> <span class="hljs-subst">{remoteConn}</span> <span class="hljs-subst">{realAddress}</span> <span class="hljs-subst">{kChannel.RemoteConn}</span>"</span>);<br>        <span class="hljs-keyword">break</span>;<br>    }<br><br>    <span class="hljs-comment">// 重连的时候router地址变化, 这个不能放到msg中，必须经过严格的验证才能切换</span><br>    <span class="hljs-keyword">if</span> (!Equals(kChannel.RemoteAddress, <span class="hljs-keyword">this</span>.ipEndPoint))<br>    {<br>        kChannel.RemoteAddress = <span class="hljs-keyword">this</span>.CloneAddress();<br>    }<br><br>    <span class="hljs-keyword">try</span><br>    {<br>        <span class="hljs-built_in">byte</span>[] buffer = <span class="hljs-keyword">this</span>.cache;<br>        buffer.WriteTo(<span class="hljs-number">0</span>, KcpProtocalType.RouterReconnectACK);<br>        buffer.WriteTo(<span class="hljs-number">1</span>, kChannel.LocalConn);<br>        buffer.WriteTo(<span class="hljs-number">5</span>, kChannel.RemoteConn);<br>        buffer.WriteTo(<span class="hljs-number">9</span>, connectId);<br>        <span class="hljs-keyword">this</span>.socket.SendTo(buffer, <span class="hljs-number">0</span>, <span class="hljs-number">13</span>, SocketFlags.None, <span class="hljs-keyword">this</span>.ipEndPoint);<br>    }<br>    <span class="hljs-keyword">catch</span> (Exception e)<br>    {<br>        Log.Error(e);<br>        kChannel.OnError(ErrorCore.ERR_SocketCantSend);<br>    }<br><br>    <span class="hljs-keyword">break</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>

<h5 id="客户端登录时的操作"><a href="#客户端登录时的操作" class="headerlink" title="客户端登录时的操作"></a>客户端登录时的操作</h5><p><code>RouterAddressComponent</code>登陆时获取软路由列表</p>
<p>localConn为软路由创建并返回客户端，因为如果都由客户端随机也有可能重复。</p>
<h2 id="第二十节-Actor"><a href="#第二十节-Actor" class="headerlink" title="第二十节 Actor"></a>第二十节 Actor</h2><p>传统意义的多线程写法，需要加各种锁做限制，逻辑复杂后锁容易被遗漏，或者多加了锁造成难以维护，变量膨胀。</p>
<h3 id="why-Actor？"><a href="#why-Actor？" class="headerlink" title="why Actor？"></a>why Actor？</h3><p>每个线程都有自己的变量，每个线程都维护自己的变量。当线程需要访问其他线程的变量时，实际是告诉其他线程自己要执行什么操作。</p>
<h3 id="Erlang对Actor的进阶设计"><a href="#Erlang对Actor的进阶设计" class="headerlink" title="Erlang对Actor的进阶设计"></a>Erlang对Actor的进阶设计</h3><p>如果只对线程进行actor的操作，实际上还是可以访问到其他线程的变量。如果使用不规范还是会造成bug。</p>
<p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230731095715561.png" srcset="/img/loading.gif" lazyload alt="image-20230731095715561"></p>
<p>不同进程之间进行调度，只需要把需要使用到的进程processid和参数传递到消息通道内，等消息通道执行到时对应进程再从消息通道中取出数据进行执行。</p>
<p>Erlang对Actor抽象出进程的概念，不同进程之间是不共享内存的所以无法直接访问到其他进程的变量，只通过消息通道进行传递。</p>
<p>每个虚拟进程都只会通过一个线程进行调度，进程变量通过一个线程进行访问。</p>
<p>Erlang的虚拟进程使用成本较低，只是数据结构包装成的进程。不需要到内核态进行创建进程，并且能够进行访问地址的有效隔离。</p>
<h3 id="ET-Actor"><a href="#ET-Actor" class="headerlink" title="ET Actor"></a>ET Actor</h3><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230731101934132.png" srcset="/img/loading.gif" lazyload alt="image-20230731101934132"></p>
<p>每个进程都有很多个Entity，每个Entity都有一个Id，Id带有进程的信息。发消息的时候只需要知道id就能够进行通信。</p>
<p>ET的Actor进一步的扩展，可以直接通知到进程中的对象上。而Erlang只能通知到进程，进程再一步通知给对象。</p>
<p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230731102622947.png" srcset="/img/loading.gif" lazyload alt="image-20230731102622947"></p>
<h4 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h4><ul>
<li>InstanceId<ul>
<li>每个Scene在配置中都有自己的id，在配置AfterEndInit时构造出InstanceId。</li>
</ul>
</li>
<li>StartSceneConfig Scene的InstanceId</li>
<li>服务器所有内部消息发送，gate转发<ul>
<li>服务器所有内部信息都用Actor发送</li>
</ul>
</li>
<li>MailboxComponent 三种MailboxType<ul>
<li><code>MessageDispatcher</code>:队列处理，后续消息都需要进行等待处理完成。</li>
<li><code>UnOrderMessageDispatcher</code>:不等待，每次消息收到都新开一个协程处理</li>
<li><code>GateSession</code>:把SessionId缓存在unit上，当收到消息时直接通过SessionId返回给客户端。<ul>
<li>Session可能会断开。需要额外管理</li>
</ul>
</li>
</ul>
</li>
<li>Actor死锁<ul>
<li>当两个unit消除处理的mailBox都是队列类型时，当A处理完成后会返回一个rpc消息，当是这时候B又发送了一个消息需要A处理。这时候A在等待B的rpc消息处理，B在等待A的消息处理造成了相互等待。在有队列的maiBox中才会发生。</li>
</ul>
</li>
</ul>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><ul>
<li><p>ActorHandleHelper</p>
<ul>
<li>```c#<br>public static async ETTask HandleIActorRequest(long actorId, IActorRequest iActorRequest)<br>{<br>InstanceIdStruct instanceIdStruct = new(actorId);<br>//这里的进程号不是收到的进程号，而是来源的进程号。<br>//因为要response,需要知道从哪个进程来的,回复到哪里取。<br>int fromProcess = instanceIdStruct.Process;<br>instanceIdStruct.Process = Options.Instance.Process;<br>long realActorId = instanceIdStruct.ToLong();<br><br>Entity entity = Root.Instance.Get(realActorId);<br>if (entity == null)<br>{<br>    IActorResponse response = ActorHelper.CreateResponse(iActorRequest, ErrorCore.ERR_NotFoundActor);<br>    Reply(fromProcess, response);<br>    return;<br>}<br><br>MailBoxComponent mailBoxComponent = entity.GetComponent<mailboxcomponent>();<br>if (mailBoxComponent == null)<br>{<br>    Log.Warning($”actor not found mailbox: {entity.GetType().Name} {realActorId} {iActorRequest}”);<br>    IActorResponse response = ActorHelper.CreateResponse(iActorRequest, ErrorCore.ERR_NotFoundActor);<br>    Reply(fromProcess, response);<br>    return;<br>}<br><br>switch (mailBoxComponent.MailboxType)<br>{<br>    case MailboxType.MessageDispatcher:<br>        {<br>            using (await CoroutineLockComponent.Instance.Wait(CoroutineLockType.Mailbox, realActorId))<br>            {<br>                if (entity.InstanceId != realActorId)<br>                {<br>                    IActorResponse response = ActorHelper.CreateResponse(iActorRequest, ErrorCore.ERR_NotFoundActor);<br>                    Reply(fromProcess, response);<br>                    break;<br>                }<br>                await ActorMessageDispatcherComponent.Instance.Handle(entity, fromProcess, iActorRequest);<br>            }<br>            break;<br>        }<br>    case MailboxType.UnOrderMessageDispatcher:<br>        {<br>            await ActorMessageDispatcherComponent.Instance.Handle(entity, fromProcess, iActorRequest);<br>            break;<br>        }<br>    case MailboxType.GateSession:<br>    default:<br>        throw new Exception($”no mailboxtype: {mailBoxComponent.MailboxType} {iActorRequest}”);<br>}<br>}<figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span> ActorHelper<br><br><span class="hljs-bullet">-</span> ActorMessageDispatcherComponentSystem<br><br><span class="hljs-bullet">-</span> ActorMessageSenderComponentSystem<br><br><span class="hljs-bullet">  -</span> 有个超时的设计，Awake时启动定时器每秒钟检查requestCallback内有哪些消息还没返回。方便检查性能。<br><br><span class="hljs-bullet">-</span> AMActorHandler<br><br><span class="hljs-bullet">-</span> AMActorRpcHandler<br><br><span class="hljs-bullet">-</span> MailBoxComponentSystem<br><br><span class="hljs-bullet">-</span> 为什么用两条Session？<br><br><span class="hljs-bullet">  -</span> <span class="hljs-code">`ActorMessageSenderComponentSystem.Call()`</span>为什么调用两个Session来传递，而不是直接用单个Session的call方法？<br><span class="hljs-bullet">  -</span> ![<span class="hljs-string">image-20230731115309727</span>](<span class="hljs-link">网络游戏架构设计/image-20230731115309727.png</span>)<br><span class="hljs-bullet">  -</span> 如果用call返回，这时候再发消息就会有问题。保证Session的单一职责。<br><br><span class="hljs-section">## 第二十一节 ActorLocation</span><br><br>TODO：这部分有点复杂，客户端用不到先简单看下<br><br>LocationComponent<br><br>对Actor基础上的封装，在某些特定场景使用<br><br><span class="hljs-bullet">-</span> 比如Unit <br><span class="hljs-bullet">-</span> InstanceId不固定<br><span class="hljs-bullet">-</span> 只知道Id，并且想通过Id发消息<br><span class="hljs-bullet">  -</span> InstanceId不固定，Id是固定的<br><br><span class="hljs-section">### 设计思路</span><br><br>ActorLocation的概念就像是一个<span class="hljs-code">`中央管理区`</span>，管理所有人的InstanceId，当Id持有的InstanceId需要变更时需要通知给中央管理区，并且锁住状态。当一个actor需要通知到具体对象时，会派出一个<span class="hljs-code">`高级邮递员`</span>向中央管理区请求InstanceId信息，并进行投递。但是在进行投递的过程中，InstanceId还是有可能会变更，<span class="hljs-code">`高级邮递员`</span>还是会发生投递失败的情况，这时候就会重新执行这个流程。需要注意的是，如果InstanceId一直在变更<span class="hljs-code">`高级邮递员`</span>不可能一直处于投递状态，还是需要给个限定时间。<br><br><span class="hljs-section">### 回执</span><br><br>无论有没有回调都需要有一个回执。<br><br><span class="hljs-bullet">-</span> 有内容的回执<br><span class="hljs-bullet">-</span> 没有内容的回执<br><span class="hljs-bullet">  -</span> 只告诉发送者接收者收到了消息。<br><br><span class="hljs-section">### Location作用</span><br><br><span class="hljs-bullet">-</span> zookeeper<br><span class="hljs-bullet">-</span> 分布式锁服务<br><span class="hljs-bullet">-</span> 存键值对<br><br><span class="hljs-section">## 第二十二节 机器人与测试用例</span><br><br><span class="hljs-section">### 机器人的作用</span><br><br><span class="hljs-bullet">-</span> 功能开发的辅助<br><span class="hljs-bullet">-</span> 单元测试<br><span class="hljs-bullet">-</span> 性能压测<br><span class="hljs-bullet">-</span> 逻辑压测<br><span class="hljs-bullet">-</span> 模拟玩家<br><br><span class="hljs-section">### 共享逻辑代码</span><br><br>放在share层，双端可以共享机器人的逻辑代码。<br><br><span class="hljs-section">#### 宏的处理方式</span><br><br>因为是All in one的设计。逻辑层是动态加载出来的，都是编译出来的dll。直接代码里只加客户端的宏就没用了。<br><br><span class="hljs-section">#### ET的宏处理</span><br><br>在<span class="hljs-code">`Define.cs`</span>文件中统一管理宏逻辑，通过宏定义来设置变量的值。通过变量的值来获取状态。<br><br>在逻辑里定义一堆宏反而更麻烦。<br><br><span class="hljs-section">### 测试用例</span><br><br><span class="hljs-bullet">-</span> 测试驱动<br><span class="hljs-bullet">  -</span> 传统概念，写逻辑先写测试用例，先让测试用例测试功能<br><span class="hljs-bullet">  -</span> 但是在游戏中逻辑变化太快，测试用例很容易被推翻。<br><span class="hljs-bullet">-</span> 函数级单元测试<br><span class="hljs-bullet">-</span> 类级别单元测试<br><span class="hljs-bullet">-</span> 协议级的单元测试<br><span class="hljs-bullet">  -</span> 游戏中的测试用例基本都是面向于协议，因为协议较于稳定。<br><br><span class="hljs-section">### 写测试用例的技巧</span><br><br><span class="hljs-bullet">-</span> 利用协程<br><br><span class="hljs-bullet">  -</span> 用协程，发送协议然后等待协议返回，判断结果。当成同步方法来写。<br><br><span class="hljs-bullet">  -</span> 部分协议不是rpc，这时候需要等待其他协议返回时，使用ObjectWait把没有关系的消息进行代码逻辑上的串行。<br><br><span class="hljs-code">    ```c#</span><br><span class="hljs-code">    namespace ET.Server{</span><br><span class="hljs-code">    	//虽然协议响应的场景是Client但是是Server命名空间下，所以编译成程序集时是在Server内。</span><br><span class="hljs-code">        //具体协议Handler</span><br><span class="hljs-code">        [MessageHandler(SceneType.Client)]</span><br><span class="hljs-code">        public class xxxHandler:AMHandler&lt;xxx协议&gt;{</span><br><span class="hljs-code">            protected override async ETTask Run(Session session,xxx协议 message){</span><br><span class="hljs-code">                ObjectWait objectWait = session.clientScene().GetComponent&lt;ObjectWait&gt;();</span><br><span class="hljs-code">                objectWait.Notify(new RobotCase_xxx(){});</span><br><span class="hljs-code">            }</span><br><span class="hljs-code">        }</span><br><span class="hljs-code">        public class RobotCase_xxx:ARobotCase{</span><br><span class="hljs-code">            protected override async ETTask Run(RobotCase robotCase){</span><br><span class="hljs-code">                ObjectWait objectWait = robotScene.GetComponent&lt;ObjectWait&gt;();</span><br><span class="hljs-code">                await objectWait&lt;RobotCase_xxx&gt;();</span><br><span class="hljs-code">            }</span><br><span class="hljs-code">        }</span><br><span class="hljs-code">    }</span><br><span class="hljs-code">    </span><br></code></pre></td></tr></tbody></table></figure></mailboxcomponent></li>
</ul>
</li>
<li><p>利用消息事件回调</p>
</li>
<li><p>不要用时间来卡逻辑</p>
</li>
</ul>
<h2 id="第二十三节-AI"><a href="#第二十三节-AI" class="headerlink" title="第二十三节 AI"></a>第二十三节 AI</h2><h3 id="AI的用处"><a href="#AI的用处" class="headerlink" title="AI的用处"></a>AI的用处</h3><ol>
<li>怪物、NPC等行为</li>
<li>子弹</li>
<li>机器人</li>
<li>托管</li>
</ol>
<h3 id="AI常用实现方案"><a href="#AI常用实现方案" class="headerlink" title="AI常用实现方案"></a>AI常用实现方案</h3><ul>
<li>状态机<ul>
<li>每两个状态都可能发生转换，复杂度是N的平方</li>
<li>节点与节点之间耦合会很严重</li>
</ul>
</li>
<li>行为树<ul>
<li>每个方法都要包装成节点，节点太多</li>
<li>树太大不好编辑</li>
<li>牵一发而动全身，一个变量的调整可能会导致顺序的调整</li>
<li>表达弱，难以阅读，难以重构</li>
<li>协程的支持比较原始，等待的操作会被包装成节点</li>
</ul>
</li>
<li>深度学习</li>
</ul>
<h3 id="AI的本质"><a href="#AI的本质" class="headerlink" title="AI的本质"></a>AI的本质</h3><p>根据当前的状态，执行一个行为。</p>
<h3 id="ET改进"><a href="#ET改进" class="headerlink" title="ET改进"></a>ET改进</h3><p>直接用代码编写AI</p>
<p>​	复用节点改为复用函数。一个行为由多个函数组成。</p>
<p>协程化，每个节点是一个协程</p>
<p>​	在行为内隔一段时间进行条件的判定，当条件满足时打断其他的行为，并执行满足条件的行为。</p>
<p>节点包含条件跟行为</p>
<p>​	把行为进行抽象，而不是把状态进行抽象。</p>
<h2 id="第二十四节-架构设计细节"><a href="#第二十四节-架构设计细节" class="headerlink" title="第二十四节 架构设计细节"></a>第二十四节 架构设计细节</h2><ul>
<li>推图游戏<ul>
<li><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230731195658960.png" srcset="/img/loading.gif" lazyload alt="image-20230731195658960"></li>
<li>主要就是房间管理的设计，如果有单人和多人的玩法。双端共享代码带来的优势。<ul>
<li>多人玩法的代码可以通过服务器请求，房间在服务器上，通过协议驱动view表现。</li>
<li>单人玩法则可以在本地创建一个Scene当作逻辑层模拟服务器房间，驱动view层。</li>
</ul>
</li>
</ul>
</li>
<li>帧同步 状态帧<ul>
<li><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230731195658960.png" srcset="/img/loading.gif" lazyload alt="image-20230731200542296"></li>
<li>逻辑层和表现层分离，逻辑层可以优化成单独一个线程运行</li>
<li>可以客户端计算服务器做转发，然后多个客户端投票机制判定结果是否正常。</li>
<li>或者状态同步，客户端发送操作，服务器计算结果并转发</li>
<li>或者只搞结算服，游戏结束把每一帧结果都发送到结算服，判定结果再进行返回。或者改为仲裁机制，有人投诉再进行结果判定。</li>
</ul>
</li>
<li>mmo slg<ul>
<li><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230731203603381.png" srcset="/img/loading.gif" lazyload alt="image-20230731203603381"></li>
<li>逻辑都在服务器，客户端只做表现。</li>
<li>在登录时，网关会先从player取出数据，在player上挂载一个map，把unit临时挂在这个map上。然后进入游戏场景时，相当于一个传送的机制。可以减少登录时的逻辑。修改登录获取数据的get方法来实现，还可以减少map上的压力。</li>
<li>一个unit上可能会挂在上百个组件，当创建unit到map时如果一起反序列化上百个组件，退出map时又序列化上百个组件无疑会带来很大的性能负担。而有些组件实际并没有使用到造成性能浪费。<ul>
<li>ET对需要序列化的组件做了优化，会存在一个专门管理序列化组件的组件，只有在第一次GetComponent时会进行序列化并且进行标记为需要反序列化。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第二十五节-分析器"><a href="#第二十五节-分析器" class="headerlink" title="第二十五节 分析器"></a>第二十五节 分析器</h2><p><a href="https://www.yuque.com/u28961999/yms0nt">ET分析器介绍 (yuque.com)</a></p>
<ul>
<li><strong>HotfixProjectFieldDeclarationAnalyzer</strong><ul>
<li>Hotfix程序集中只能携带无状态的代码。如果定义了Const变量在热更新时会产生变量参数的变更，造成代码的不稳定。</li>
</ul>
</li>
<li><strong>ClassDeclarationInHotfixAnalyzer</strong><ul>
<li>数据结构也不能在Hotfix程序集定义，数据结构的变更也会造成热更新的不稳定性。</li>
</ul>
</li>
<li><strong>EntityMethodDeclarationAnalyzer</strong><ul>
<li>实体类禁止声明方法。</li>
<li>EnableMethod开后门可以绕过约束</li>
</ul>
</li>
<li><strong>StaticClassCircularDependencyAnalyzer</strong><ul>
<li>静态类之间不能相互调用</li>
<li>静态类之间如果互相调用就会造成依赖</li>
</ul>
</li>
<li><strong>UniqueIdAnalyzer</strong><ul>
<li>避免定义的const int变量参数重复</li>
<li>框架定义枚举会有侵入性，上层可能会修改到底层的枚举</li>
</ul>
</li>
<li><strong>EntityDelegateDeclarationAnalyzerEntityDelegateDeclarationAnalyzer</strong><ul>
<li>避免声明Action，避免回调写法</li>
</ul>
</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%A1%86%E6%9E%B6%E7%AF%87/" class="category-chain-item">框架篇</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Manager-%E6%A1%86%E6%9E%B6-ET%E6%A1%86%E6%9E%B6/">#Manager 框架 ET框架</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>网络游戏架构设计</div>
      <div>http://ysich.github.io/2023/03/17/网络游戏架构设计/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>ysich</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年3月17日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/07/14/%E7%BA%B9%E7%90%86%E8%AF%A6%E8%A7%A3/" title="纹理详解">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">纹理详解</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/01/31/%E5%85%B3%E4%BA%8ECallBack/" title="关于CallBack">
                        <span class="hidden-mobile">关于CallBack</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/ysich" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
