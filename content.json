{"meta":{"title":"ysich'Blog","subtitle":"","description":"","author":"ysich","url":"http://ysich.github.io","root":"/"},"pages":[{"title":"三十六分热","date":"2023-01-16T12:19:47.112Z","updated":"2023-01-16T12:19:47.112Z","comments":false,"path":"about/index.html","permalink":"http://ysich.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"纹理详解","slug":"纹理详解","date":"2023-07-14T01:52:31.000Z","updated":"2023-07-14T01:53:36.556Z","comments":true,"path":"2023/07/14/纹理详解/","link":"","permalink":"http://ysich.github.io/2023/07/14/%E7%BA%B9%E7%90%86%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"纹理详解图像容量大小bpp每个像素的内存消耗 总图像存储大小 = width * height * bpp Non Power of 2长、宽不全是2的幂次尺寸的图片称为 NPOT（Non Power Of Two）格式的图片。 对于项目中需要压缩的贴图，需要尽量做成POT NPOT转成POT后，进行ToNearest操作可以压缩到六分之一大小。压缩比1：6 图片格式jpg有损压缩 不带Alpha通道 不可编辑，读取时需要先读取整张图片，再读取具体内容 png无损压缩 带Alpha通道 可编辑，可以直接读取具体内容 纹理格式对于所有平台RGBA 32Bit一个像素由红、绿、蓝三个色彩通道都由8位色彩深度组成，加上Alpha通道的8位，共计32位Bit。 Alpha通道8bit可以表示256级灰度，即透明度。 优点：适用所有设备 缺点：内存占用太高，移动平台基本不会直接使用 适用平台：Android、IOS RGBA 16Bit红色通道、绿色通道、蓝色通道和alpha 通道各4位。 Alpha8 只有透明度，没有颜色。 ASTC要求：iOS A8 处理器(iPhone6及iPad mini 4以上iOS设备)、Android 需要设备GPU支持 OpenGL ES 3.1及以上即部分 ES 3.0 优点：压缩后图片画质好、自由度高，有多种格式可以选择4x4~12x12、不要求图片尺寸 缺点：需要考虑支持的设备市场普及率，看了相关的几篇机型调查文章。不支持ES3.1的Android机型大概为1.5%，IOS基本没有。 适用平台：Android、IOS 注意：在不支持的设备上，贴图会解压成RGB(A)，然后与压缩的贴图一起存储在内存中，会增加纹理加载时间和增加额外内存 关于法线贴图法线贴图要求的质量会高一些，压缩度越高失真越严重，一般为 5 x 5 或 6 x 6 对于Android平台ETC1要求：贴图的长宽为2次幂 优点：适用所有的Android设备、压缩率较高 缺点：不支持带 Alpha 通道的贴图、肉眼可见失真，图集需要一张额外的Alpha通道的贴图。 适用平台：Android 压缩的RGB纹理。这是Android工程默认的纹理格式。ETC1是OpenGL ES 2.0标准的一部分，并且支持所有的OpenGL ES 2.0 GPU，但它不支持Alpha。 ETC2要求：贴图的长宽要能被4整除、OpenGL ES 3.0及以上 优点：支持Alpha通道的贴图 缺点：内存占用大于ETC1格式 适用平台：Android 注意：在不支持 ETC2 的 Android 平台上，纹理在运行时解压缩为 Build Settings 中的 ETC2 fallback 指定的格式，默认自动转成RGBA32/ARGB32的格式 对于IOS平台PVRTC要求长宽相等。且为2的幂次方 有些GUP不支持NPOT，遇到NPOT会有一个转换POT的过程，浪费性能 Texture Cache小结PS：在图集在纹理采样时，如果尺寸不是2次幂会被引擎层拉伸成2次幂，因为GPU光栅化需要对纹理采样进行快速取值。所以存储时如果非2次幂则节省内存，但是采样时会消耗额外性能；存储时如果拉伸为2次幂存储则费内存，采样时则节省性能。 TexturePacker工具TP工具打图集流程 调用TexturePacker 命令行打图集 下载TexturePacker工具，然后用命令行调用tp打图集，完成之后会生成2个文件，一张打好的图集，一份保存了真实图片的位置信息.txt文件 拆分alpha通道 texture导入精灵图(spritesheet) 生成材质球 生成预制，将padding信息保存在so里【atlas_tp_padding.asset】，游戏运作中需要用到 Padding信息存储和读取在打图集的时候，保存图片的位置信息，然后在图片绘制网格的时候，读取这些信息，计算出真实的位置信息，再将像素绘制上去 Image一些接口说明UGUI的OnPopulateMesh函数UGUI中与显示相关的控件，例如Image、Text、RawImage等都继承自MaskableGraphic类，MaskableGraphic类继承自Graphic类。 控件在画面中的形状、颜色、法线等信息都是由Graphics类中的OnPopulateMesh函数所控制每当改变了顶点或者纹理后，会调用OnPopulateMesh函数其中VertexHelper是一个顶点辅助类，保存着生成Mesh的基本信息 绘制图形 AddVert 添加顶点(第一个添加的顶点索引为0，第二个添加的顶点为1，依次…..) AddTriangle 绘制三角形(GPU绘制时会按照输入的顶点下标的顺序绘制一个三角形) 绘制四边形时，就是绘制两个三角形。 currentIndexCount VertexHelper结构中有几个顶点索引(重合的顶点被计为2个顶点，例如一个三角形最少有3个顶点，一个正方形最少有6个顶点) currentVertCount VertexHelper结构中有几个顶点(AddVert添加了几个顶点就有几个) PopulateUIVertex 获取某个索引的顶点数据 SetUIVertex 设置某个索引的顶点数据 AddUIVertexQuad 把AddVert和AddTriangle封装到一个函数中 AddUIVertexStream 把AddVert和AddTriangle封装到一个函数中 sprite和overrideSprite的区别官方的说法，overrideSprite 用于临时修改图片，sprite 用于永久修改图片。 overrideSprite 用于修改图片，但是不会把原来的图片给消除掉，直接的效果是如果 overrideSprite 是 null 的话，会变回原本的图片。可以理解为 overrdieSprite 是覆盖在 sprite 上的一层图片。所以，若使用 overrideSprite 更换图片，接下来要更换也只能用overrideSprite再覆盖掉，除非把它置为 null，不然用 sprite 更换是显示不出来的。 写入padding信息 spriteSourceSize为真实图片的位置信息。 sourceSize为原本的图片信息。 padding为 1234float left = frame.spriteSourceSize.x;float top = frame.spriteSourceSize.y;float right = frame.sourceSize.x - frame.spriteSourceSize.x - frame.spriteSourceSize.width;float bottom = frame.sourceSize.y - frame.spriteSourceSize.y - frame.spriteSourceSize.height; 运行时设置padding信息SpriteAssetMoudle初始化Init时，设置SDImage的静态对象`m_spritePaddingMap m_spritePaddingMap&lt;string,Vector4&gt;spriteName为key，padding参数为value。 重写OnPopulateMesh接口123456789101112131415161718192021222324252627282930313233343536373839404142434445protected Vector4 GetDrawingDimensions(bool shouldPreserveAspect){ Sprite overrideSprite = this.overrideSprite; var padding = GetPadding(); var size = overrideSprite == null ? Vector2.zero : new Vector2(overrideSprite.rect.width, overrideSprite.rect.height); Rect r = GetPixelAdjustedRect(); int spriteW = Mathf.RoundToInt(size.x); int spriteH = Mathf.RoundToInt(size.y); float width = spriteW + padding.z + padding.x; float height = spriteH + padding.w + padding.y; var v = new Vector4( padding.x / width, padding.y / height, (width - padding.z) / width, (height - padding.w) / height); if (shouldPreserveAspect &amp;&amp; size.sqrMagnitude &gt; 0.0f) { var spriteRatio = size.x / size.y; var rectRatio = r.width / r.height; if (spriteRatio &gt; rectRatio) { var oldHeight = r.height; r.height = r.width * (1.0f / spriteRatio); r.y += (oldHeight - r.height) * rectTransform.pivot.y; } else { var oldWidth = r.width; r.width = r.height * spriteRatio; r.x += (oldWidth - r.width) * rectTransform.pivot.x; } } //根据padding值换算出来的比例来计算新的 image顶点位置 v = new Vector4( r.x + r.width * v.x, r.y + r.height * v.y, r.x + r.width * v.z, r.y + r.height * v.w ); return v;} 获取Padding信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354protected Vector4 GetPadding(){ if (GameMain.Instance != null &amp;&amp; GameMain.Instance.enabled) { if (m_IsUrl || string.IsNullOrEmpty(SpriteName)) { return Vector4.zero; } if (m_spritePaddings == null) { //Debug.LogError(\"SpritePadding error\"); return Vector4.zero; } if (m_spritePaddings.ContainsKey(SpriteName)) { return m_spritePaddings[SpriteName]; } return Vector4.zero; } #if UNITY_EDITOR if (!overrideSprite) return Vector4.zero; if (UseSpritePacker) { return DataUtility.GetPadding(overrideSprite); } if (m_spritePaddings == null) { string path = PathDef.UI_ASSETS_PATH + \"/atlas_tp_padding.asset\"; PaddingData paddingData = AssetDatabase.LoadAssetAtPath&lt;PaddingData&gt;(path); m_spritePaddings = new Dictionary&lt;string, Vector4&gt;(); foreach (var atlas in paddingData.atlas) { foreach (var spriteInfo in atlas.spritesHavePadding) { if (m_spritePaddings.ContainsKey(spriteInfo.name)) continue; m_spritePaddings.Add(spriteInfo.name, spriteInfo.padding); } } } Vector4 v; if (!m_spritePaddings.TryGetValue(overrideSprite.name, out v)) { //Debuger.LogError(\"图集错误. 白边信息缺失: sprite:\" + overrideSprite.name); return Vector4.zero; } return v; #else return Vector4.zero; #endif} Texture相关TextureImporter此类中的设置与 Texture Import Settings 中显示的设置相匹配。 UnityEditor.TextureImporter - Unity 脚本 API TextureImporterPlatformSettings存储 TextureImporter 的平台特定设置。 UnityEditor.TextureImporterPlatformSettings - Unity 脚本 API SpriteMetaDataUnityEditor.SpriteMetaData - Unity 脚本 API EditorUtilityUnityEditor.EditorUtility - Unity 脚本 API Generate Mip Maps 属性开启Mipmaps可以使远离相机的物体使用较小的纹理版本，这样渲染时，显存带宽压力比较小，同时避免显示效果产生噪点（pix fight）。 Read/Write Enabled 属性Read/Write Enabled选项打开的时候主要是为了外部可以通过脚本进行一个修改，例如通过Texture2D.SetPixels、Texture2D.GetPixels和其他一些方法进行问理数据的访问。但是内部的话，unity并不是直接在原有的纹理上去做这些操作的，毕竟一个贴图可能用在很多地方，直接在原纹理图上进行修改的话，那么所有使用这个纹理的地方都会受到影响。所以内部unity会对原纹理进行一个拷贝产生一个副本，所有的读写操作都是在副本上进行完成的。所以产生一个副本的话，自然内存是会加倍的。","categories":[],"tags":[]},{"title":"网络游戏架构设计","slug":"网络游戏架构设计","date":"2023-03-17T06:07:03.000Z","updated":"2023-03-17T06:09:19.444Z","comments":true,"path":"2023/03/17/网络游戏架构设计/","link":"","permalink":"http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"网络游戏架构设计第一节 代码结构项目代码结构需要满足的需求热更新需要把Unity的MonoBehaviour等等这些和Unity交互较深的脚本进行分离 至少有一个热更新的程序集 数据跟方法分离，热重载热重载​ 热重载只是数据跟方法分离后得到的好处 ​ 热重载便于改bug，节省重现环节。 数据跟方法分离​ 在C语言中叫做data + function的设计。数据就是定义数据结构，方法则是面向过程的方法。 ​ 相比于面向对象而已没有类与类之间的关联，只有方法和方法的关联，便于重构。 逻辑跟表现分离数据是同步的，而表现可能是异步的情况。在表现过程中可能会有一些资源加载的操作，在这个过程中逻辑发生了变化，表现也需要发生变化。 预表现。表现层可能提前做出一些表现比如一些战斗前摇，但是对逻辑层没有什么影响。等逻辑层同步了命中逻辑后，再播放命中的表现。 在MMO的切换场景中，服务器通知场景切换后，客户端逻辑层加载数据，表现层则在数据加载完成后开始异步加载场景。服务器再通知单位模型的数据后，客户端逻辑层整理数据后，表现成开始异步加载单位模型。 帧同步。帧同步两端的逻辑层的逻辑是一样的。而状态同步逻辑在服务端，两端的逻辑层实际上也是一样的。区别只在于一个是客户端计算一个是服务端计算。 帧同步如果把逻辑层看做是一个服务端，看起来就像是逻辑层在给表现层发消息。逻辑是离散的，表现是要做插值的。 ECS数据驱动数据变化是通过事件通知的。逻辑和表现监听事件产生变化。 ET版本变更1.0客户端 Hoxfix 热更层 Main 主工程 服务端 Hoxfix 纯逻辑 Main 纯数据 中间版本客户端 asmdef功能，多个程序集提升编译速度 Hoxfix 热更层 Loader 游戏入口，可放Unity脚本 Core 框架核心 ThirdParty 第三方库 服务端 Hoxfix Model Loader Core ThirdParty 热重载需求客户端 Hoxfix 热更层的逻辑层 纯逻辑改变时不用关闭游戏，直接重载这个程序集 Model 热更层的数据层 Loader 游戏入口，可放Unity脚本 Core 框架核心 ThirdParty 第三方库 另一种划分 HoxfixView 表现层 Hoxfix 逻辑层 抛事件通知表现层 Loader ThridParty Core 结合前面两个版本客户端 HoxfixView 表现层的方法 ModelView 表现层数据结构 Hofix 逻辑层方法 Model 逻辑层数据 Loader Core ThridParty 前四个程序集编译在一起做热更新。HofixView和Hofix编译在一起做热重载。 并且逻辑和表现分离 Robot Hofix 逻辑层方法 Model 逻辑层数据 Loader Core ThridParty 去掉客户端的表现层，就是机器人的程序集了。 Hofix和Model共用客户端的程序集。 第二节 All In One各类服务器进程合并 很多多进程的设计，都把一个服务整理成一个exe。多个服务就有多个exe，代码可能是高度相似的，或者基本一样的。只是启动时环境变量不同。合并成一个exe并设置环境变量。 发布部署简单、配置资源方便、多种服务共用进程。 结构调整容易，比如两种或多种服务要合并，拆分 多个exe会有多个进程，当其中一部分逻辑压力过大时（比如一个中心服有好友和组队功能，好友功能压力过大时 ）不好拆分，需要再拆成多个exe。 无限增加app类型，千古风流有几十种SceneType 根据配置需要什么服务，就配置什么类型。多个服务配置在一个进程内。 后端和机器人合并 机器人和服务器的代码基本一样。也引用了大部分的后端代码。还引用了客户端的逻辑代码。代码引用很乱。 机器人要单独起一个exe很不方便，跑测试需要起两个进程。 server和机器人合并带来的问题 代码类重名 合并后分别引用了客户端和服务端的代码。两端代码的类名重名（item、buff）。 用命名空间隔离解决重名冲突，带来的好处只需要检查目录下的命名空间就能保证不会调用到错误的代码。 ET.Server、ET.Client 事件订阅怎么区分前后端 有些工具类，或数值组件这种两端共用的代码就不用隔离。ET 比如单位组件，前后端都有抛出的事件很难做区分。需要区分订阅。 通过场景类型做区分SceneType 配置文件结构不同怎么共享 问题也不大，大不了两端配置都存在。 机器人在写组队逻辑时很有用。 前端跟后端合并 不需要单独起服务端，前后端代码共享更方便不需要单独启动服务器，unity一启动就启动前后端代码。 前后端代码的共享，前端可以包含一个服务器，后端可以包含前端的逻辑做个机器人。 后端可以更方便做Unity可视化工具，可视化树ENABLE_VIEW后端如果是命令行程序，做数据可视化很困难。 写后端就像写前端一样简单，比如写个行为树，后端可以直接调试，前端可以直接拿到后端数据。 ET7加上ENABLE_VIEW宏开启可视化树 更方便做插件机制用unity的导入导出做插件机制。 各种游戏代码合并的需求分析竞技游戏比如守望先锋，用的状态帧同步。本地先预测下一帧行为，服务器同步下来如果结果不符合则进行回滚。那么两端肯定有相同代码，否则产生结果肯定是不一致的。 MMO游戏、MOBA游戏模拟机器人的需求，充当普通玩家。 机器人压测需求。 状态同步客户端预测和服务器权威数据跑的代码基本一致。 帧同步逻辑都在客户端，但是在结算结果的时候数据不权威。后期帧同步，很多是依靠服务器也跑一份逻辑，根据跑出来的结果判定结算。也是防作弊很重要的内容。 前端和后端合并的细节问题怎么区分编译前端代码跟后端代码，还有双端编译搞一个编译工具，按照需求选择编译 配置要区分前端跟后端，以及双端，configpatial的处理有些配置不需要双端都知道的，比如前端的特效，或后端比较权威计算的数值。 这就需要导出三份配置。C、CS、S config patial就是把配置反序列化成需要的类对象的工具 config patial不能共享，需要写三份。 消息要区分前后端，以及双端。 总结 把服务器逻辑代码也写在客户端程序集内，直接引用。 第三节 单间管理器为什么需要单间管理器？统一管理单间类。单间类的问题？单间类生命周期的问题，创建了什么时候释放的问题。 内存随着生命周期清理的问题。 统一管理基础库，灵活引入基础库消除静态字段static Dictionary这种静态变量，生命周期清理的问题。 Unity domain模式domain模式为了提升性能不清理静态字段，需要自己清理。 为什么不用组件？组件本身需要一些额外的东西，比如创建的时候需要对象池。对象池又是谁管理。就可以使用单间管理器创建对象池。 为什么用Game.AddSingleton 创建单间Game.AddSingleton&lt;TimeInfo&gt;(); 代码可读性，明确知道单间初始化的地方。如果都是Instance很难找到哪里是初始化的地方。 明确知道初始化顺序，方便调整好释放，相反的顺序释放明确知道了初始化顺序，能更明确释放的顺序。 123456789public interface ISingleton: IDisposable{ void Register(); void Destroy(); bool IsDisposed();}public class Singleton&lt;T&gt;: ISingleton where T: Singleton&lt;T&gt;, new(){} 通过接口创建生命周期ISingletonAwake 、ISingletonUpdate 、ISingletonLateUpdate AddSingleton时判断是否有生命周期接口，如果有添加对应生命周期。 1234567891011121314151617181920212223242526272829public static void AddSingleton(ISingleton singleton){ Type singletonType = singleton.GetType(); if (singletonTypes.ContainsKey(singletonType)) { throw new Exception($\"already exist singleton: {singletonType.Name}\"); } singletonTypes.Add(singletonType, singleton); //管理单间加载顺序，做卸载时可用 singletons.Push(singleton); singleton.Register(); if (singleton is ISingletonAwake awake) { awake.Awake(); } if (singleton is ISingletonUpdate) { updates.Enqueue(singleton); } if (singleton is ISingletonLateUpdate) { lateUpdates.Enqueue(singleton); }} 第四节 多线程、单线程、Task await async的关系多线程使用多线程去执行复杂逻辑时，callback会在执行线程继续执行进行响应。 比如寻路的逻辑比较复杂抛给其他线程去处理，响应回调时也是会在寻路线程进行响应。 遇到的问题当遇到框架内的api都是单线程的api时，必须在主线程完成回调。在其他线程响应回调会导致线程竞争。 解决方法也很简单，在其他线程响应回调时把回调放到一个缓存队列中（需要同步上下文），在主线程的update里不断去取缓存队列中的响应，并去执行它。就能把回调丢回到主线程执行。(C++中的没有task而使用的手法) 详情看看MainThreadSynchronizationContext这个类 Task线程消耗比较大，创建的时候一般都使用线程池。Task就是线程池封装的结果。 Task 执行的线程和响应回调的线程不一致，回调的响应会丢到其他线程执行。 Task本质就是个状态机，当设置了同步上下文时，回调会被自动调整到主线程执行。 编译器帮我们做了这一步 12345678910111213public static async void StartTask(){ SynchronizationContext synchronizationContext = SynchronizationContext.Current; await Task.Run(FindPath); if(synchronizationContext == null){ //没设置同步上下文会在当前线程响应。 SendMessage(); }else{ //设置了同步上下文实际会在设置的线程响应。 synchronizationContext.post(()=&gt;{ SendMessage(); },null); }} 自己实现个TaskRun123456789101112131415 public static async Task Run(Action action) { TaskCompletionSource tcs = new TaskCompletionSource(); ThreadPool.QueueUserWorkItem((_) =&gt; { action.Invoke(); tcs.SetResult(); }); await tcs.Task; }public static async void StartTask(){ await Run(FindPath); //这里把回调和多线程的调用放在同个方法执行 SendMessage();} 使用Task.Factory.StartNew创建可以自由调度的线程 12345public static async void StartTask() { //MyTaskScheduler是自己实现的线程调度器 await Task.Factory.StartNew(FindPath,new CancellationToken(),TaskCreationOptions.None,new MyTaskScheduler()); } 自定义线程调度器继承TaskScheduler实现自己的线程调度器 123456789101112131415161718public class MyTaskScheduler:TaskScheduler { protected override IEnumerable&lt;Task&gt; GetScheduledTasks() { return null; } protected override void QueueTask(Task task) { //执行完回收到线程池 ThreadPool.QueueUserWorkItem((_) =&gt; TryExecuteTask(task)); } protected override bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued) { throw new NotImplementedException(); } } 第五节 ETTask回调地狱 Callback HellTask主要是为了解决回调地狱 在没有协程和await之前，cpp主要靠函数对象模拟Lambda。 后续谷歌推出NewCallback C# 5.0 推出了 await async 关键字 await难以维护的操作while await，await all 所有任务才执行回调。 go python js ts cpp后续也推出了await关键字，但是go的await不完善，是通过线程的方式去执行。比如玩家有的操作是需要单线程等待一段事件再执行的，回调则会执行在其他线程中。而好的设计则应该是只把回调拉直，而不关心你后续实现是在多线程还是单线程。 回调转成TaskTaskCompleteSource 12345678public async ETTask FindPath(){ TaskCompletionSource tcs = TaskCompletionSource(); ThreadPool.QueueUserWorkItem( state=&gt;{ Consle.WriteLine(\"FindPATH\"); tcs.SetResult(); }); await tcs.Task;} CancellationTokenSource await的取消操作 传入token，通过token状态来判断后续代码是否执行。 ETTask的好处生成代码极简，去除了多线程的支持，性能最好。 对象池消除了Task GC TaskCompleteSource和CancellationTokenSource这两个类比较庞大并且没有入池，gc问题比较严重。 去掉了ETVoid ETVoid对应 async void。任何异步都返回ETTask。不需要等待则直接Coroutine。操作简单。 线程取消 超级简单的ETCancelToken ETCancelToken替换CancellationTokenSource 协程取消判断 12345if(cancellationToken.IsCancel()){ Console.WriteLine(\"Start cancel\"); return;}Console.WriteLine(\"Start finish\"); 在ETTask中判断ETCanelToken是否取消然后继续执行后面操作。而Task在取消后则抛出异常。 ETCancelToken取消多个协程 多个ETTask判断同一个ETCancelToken ETCancelToken的必要性 尽可能设计一个await的取消方式，否则后续维护扩展非常困难。 awaitableGetAwaiterc#提供的GetAwaiter的机制，只要对象有一个成员方法或者静态方法名为GetAwaiter，就可以使用await的语法。 Unity yield转换本质上也是回调操作，把yield用await的形式更加简单。 1234567//unity中yield都会返回AsyncOperation的子类public static async ETTask GetAwaiter(this AsyncOperation asyncOperation){ ETTask task = ETTask.Create(true); //SetResult执行后会回到await后的操作。 asyncOperation.completed += _=&gt;{ task.SetResult();}; await task;} 1234567891011public static async ETTask&lt;string&gt; HttpGet(string link){ try{ UnityWedRequest req = UnityWebRequest.Get(link); //req.SendWebRequest()会返回UnityWebRequestAsyncOperation，继承于AsyncOperation await req.SendWebRequest(); return req.downloadHandler.text; } catch{ throw new Exception(); }} 第五节 -2 ETTask源码分析用反编译工具.NET Reflector查看ETTask实现。 这里需要反复看生成概念。 本质上是基于状态机的实现，执行时通过判断ETTaskCompleted的值来判断是否走到后面的逻辑，如果需要等待则将状态机的MoveNext方法传到ETTask的CallBack中。通过状态机的状态变化继续后面的逻辑。 ETTask的SetResult操作会触发回调，执行状态机的MoveNext。 实际上是把await前的代码和await后的操作，各放在一个状态中，通过状态机切换来执行。保证了上下文的统一。 多个await会生成多个状态机 ETTask只要用了ettask.Coroutine()在编译后会生成一个ETAsyncTaskMethodBuilder.Create() ETAsyncTaskMethodBuilderstruct类型，包含一个ETTask。 在方法执行了Coroutine编译后会对应生成一个相对的struct，继承于IAsyncStateMachine。生成一个状态机，根据state参数执行相对应阶段的代码。 ETVoidETAsyncVoidMethodBuilderETTaskCompleted返回完成状态，基本是true ETAsyncTaskCompletedMethodBuilder协程的使用用协程简化工作流程。 int result = await OpenBox();弹窗时返回点击按钮的type做相应的判断，简化在窗口里写逻辑，逻辑上更清晰。(有点像VB的弹窗返回值 await MoveTo(); await ChangeScene(); 切换场景的操作写成一个方法，await后执行切换场景完成后的代码。 await CastSpell(); 释放技能，技能成功或失败后的操作。比如失败时使用道具，成功后捡道具。如果用事件则会变得很复杂。 熊猫哥举了个例子，比如自动寻路时，需要通过几个场景的传送门才能到达最终场景。先把场景选出来，给每个场景写一个最短路径的寻路方法。根据读配置去执行相应的寻路方法。只需要通过一个while循环就能到达最终目标位置。 把逻辑异步化后，逻辑更清晰，只需要对内容进行封装抽象不需要再关心后续的逻辑了。 第六节 计时器TimerComponent 需求场景 UI倒计时 网络超时 技能释放 buff超时删除，定时事件 Task.Delay的问题C#提供的定时器Task.Delay。 跨线程 Task.Delay是跨线程的，会把await的回调放在其他线程执行。 性能 如果需要把回调设置到主线程，就需要设置同步上下文SynchronizationContext synchronizationContext = SynchronizationContext.Current;。把action post到主线程，性能很糟糕 CancleToken抛异常 抛异常的性能问题 不执行后续操作 GC 基于Task实现 有GC 实现代码实现相对时间public async ETTask WaitAsync(long time,ETCancellationToken cancellationToken = null) unix绝对时间public async ETTask WaitTillAsync(long tillTime,ETCancellationToken cancellationToken = null) 相对时间的会跟随帧率 或 线程情况受影响。而绝对时间则是跟随unix时间。在时间达到时，无论什么情况都会执行。 计时器public long NewOnceTimer(long tillTime,int type,object args) 为什么不用callback？ 计时器里可能会有泄露，方便查找泄露。callback没法热重载，基本不用callback。 跟WaitAsync的区别？ 时间长时，用NewOnceTimer，可以热重载。而WaitAsync不能热重载。 数据结构MultMap 管理时间线，在每个时间点插入一个list管理多个计时器。插入list的操作有gc，用对象池创建的话会有回收问题，一直创建池子只会越来越大，在切换场景的时候回收。 Remove细节，只从timerActions中删除。不删除MultMap 管理的计时器，MultMap管理的List插入删除都会影响性能。时间到了从MultMap 取出执行时，判断是否在timerActions中，如果在再执行。 WaitAsync ETCancellationToken怎么判断去取消。 第七节 协程锁CoroutineLockComponent 使用场景 协程并发造成协程竞争，类比于线程竞争 unity资源加载 同时异步加载同一个资源会报错 如果打标记后续逻辑比较不好扩展，比如要做await操作。 加载mail数据 不同服务器玩家数据的竞争 unit消息队列，上线下线 玩家下线了，但是有些异步操作还没完成。 数据库查询保存队列，防止并发过多 mongodb数据的并发数量是有限的。 用了协程锁后，协程则是并列进行。 死锁协程锁中再次获得同一把锁 A B互相等待想象不到的死锁 两条没有关联的消息正好在同一时间请求，请求的内容都需要用到同一把锁。就造成了死锁。 这种情况比较罕见，要么改成请求锁的地方统一通过转发形式。要么干脆直接不处理了。 协程队列实现CoroutineLockComponent 协程锁划分类型 不同类型的锁没必要等，比如资源和数据。 同一个类型，再根据id划分协程锁队列。 同一个类型，并且id相同则在同一个队列中，并列执行。 CoroutineLockQueueType CoroutineLockQueue 对象池 问题为什么不用池？不用struct？ 超时实现 第八节 协程同步三件套ETTask、协程锁、WaitAll 在使用waitAll时需要考虑是否能并发，是否需要并发。 ETTaskHelper.WaitAll 使用场景资源加载并发ResourceComponent实现了并发加载资源 机器人登录并发 每个流程都可以实现并发 WaitAll实现线程同步barrier可以参考barrier 主协程要阻塞住 主协程wait 所有子协程执行完，要通知主协程往下执行 子协程执行完有个回调，至少有个setResult的操作 用计数形式，每执行完一个子协程，count-1，count=0时表示子协程都执行完毕。 主协程在所有子协程都执行完后才开始执行，就需要判断。 在主协程开始时，判断计数是否为0，为0时直接执行。不为0时创建个ETTask等待。 Cancel的判断 WaitAll取消的操作 WaitAny有任一一个协程执行完则返回。 实现计数设置为1，执行完一个-1，count&lt;=0返回 第九节 ID、TimeInfo、ObjectPoolID对应类IdGenerater ID跟InstanceIDID是逻辑上的，InstanceID是对象的ID可以重复，管理器管理，而InstanceID是全局唯一的为什么需要InstanceID？InstanceID表示对象的唯一性对象可能会被释放或者清除，通过InstanceID判断对象是否存在 InstanceID有位置信息InstanceID拥有时间、进程号 InstanceID能方便区分对象进入对象池再被使用在await等待时当持有的unit可能在某个操作被对象池回收，后再被创建。持有的unit已经变成了新的unit造成逻辑错误。 InstanceID被池回收后再创建，InstanceID发生变化。在await操作时判断前后InstanceID是否一致。 ID的构成long类型 64位 Time 30bit 34年 不用从1970开始，可以从项目发布时间开始，还能用34年 Process进程号 18bit 1024*256 一个区大概使用256个进程(根据游戏类型调整)，可以支持1024个区 自增 16bit 65535 当一秒内的自增id超过范围时，借用下一秒的 UnitID构成 Time 30bit 34年 Zone 10bit 1024个区 跨服用 当出现跨服活动时，很方便的通过zone来做区分 ProcessMode 8bit Process % 256 自增 16bit 65535 InstanceID构成 Time 28bit 当年开始的tick 生命周期比较短，不需要那么长的 time Process进程号 18bit 1024*256 一个区大概使用256个进程(根据游戏类型调整)，可以支持1024个区 自增 18bit 65535 *4 数量比较多，增加自增率 TimeInfo对应类TimeInfo Unix Time 自1970年1月1日以来的毫秒 ServerMinusClientTime 服务器时间 - 客户端时间得到的时间差。在 ping的过程中获取。 客户端时间 + 与服务器的时间差 = 服务器时间 ServerTime、ClientTime 对于服务器而言，ServerTime和ClientTime是一样的，对服务器而言不需要考虑客户端时间。 对客户端而言，ServerTime就是 客户端时间 加上 与服务器的时间差获得的。 性能优化 在ClientNow中 计算时间用到Ticks，Ticks的操作非常耗时。 ObjectPoolmono的垃圾回收很垃圾。 在异步代码里，处处使用对象池很有问题。在每个操作都要判断是不是新的对象，漏了一个就有很大的问题。 有些对象池有定时回收的功能，这个功能的缺陷在于，在某一帧可能会回收大量对象，加深了那一帧的时间。 ET的设计则是将对象池设置个最大容量，超过最大容量时则不入池，避免内存占用过大。 在一些场景切换中也可以对对象池进行清理，避免没有意义的内存占用。","categories":[{"name":"框架篇","slug":"框架篇","permalink":"http://ysich.github.io/categories/%E6%A1%86%E6%9E%B6%E7%AF%87/"}],"tags":[{"name":"Manager 框架 ET框架","slug":"Manager-框架-ET框架","permalink":"http://ysich.github.io/tags/Manager-%E6%A1%86%E6%9E%B6-ET%E6%A1%86%E6%9E%B6/"}]},{"title":"关于CallBack","slug":"关于CallBack","date":"2023-01-31T02:36:16.000Z","updated":"2023-07-14T01:49:20.038Z","comments":true,"path":"2023/01/31/关于CallBack/","link":"","permalink":"http://ysich.github.io/2023/01/31/%E5%85%B3%E4%BA%8ECallBack/","excerpt":"","text":"关于CallBackCallback提高cpu利用率不会造成阻塞。做一件事不会等待，等需要时再call back处 应用场景 DMA控制器 cpu做数据复制时会阻塞cpu，cpu 通知硬件进行复制完成后通知回来。不会阻塞整个cpu 网络多路复用 Socket读写过程中，等待数据发送或接收过程cpu的阻塞。等数据过来后再进行通知。 多线程 时间 比如等待5秒后执行一个函数，不需要阻塞线程5秒后再执行。 CallBack历史函数指针C语言内通过函数指针的方式，在callback 后用指针执行函数，但是不方便同步上下文且类型不安全（可以传递任意指针） 函数对象C++通过函数对象的方式，类型安全、构造时传递函数指针、构造时传递上下文、绑定上下文 将上下文和回调函数封装成一个类（闭包），做到延迟调用。闭包比较繁琐，当需要上下文对象类型不满足已有扩展的闭包支持的类型时就要进行 闭包类型的扩展。 谷歌的NewCallBack上下文只能绑定前面的参数不能绑定后面的参数、返回的是指针（本质是new一个函数对象执行）如果没有调用会造成内存泄漏（解决方案：使用智能指针包裹） Callback Hell（回调地狱）在处理回调时，我们的逻辑会被截成两段，一段是发起callback 一段是响应callback 。在Callback调用Callback的过程中，代码相应会像波浪一样越推越远。 易出错、难修改。在callback 中难插入。 async await Task把int Func() (回调) 转成await Func() 在C#中通过转换工具TaskCompletionSource 转换 ETTask 简化的Task 生成代码简单 (.Net Reflector 可以.net stand 2.0反编译) 解决了GC问题 Task 使用TaskCompletionSource工具类转换成await Func 时会new 工具类 ETTask在确保安全的时候使用池消除gc，Set Result (true)时回收 TaskCompletionSource和Task合并 不提供多线程处理 并行ET提供WaitAll WaitAny，类比线程同步barrier 当多个回调同时发起，等所有回调执行完再往下执行 场景： 切换场景资源,不需要一个个加载，可以同时加载，等所有加载完再往下执行。 机器人登录50个，不需要一个个登录。 协程锁应用场景： 两个逻辑同时加载同一个ab包 服务器玩家异步加载处理到一半，这时收到下线消息。 实现： CoroutineComponent实现思路： 同一种锁，同一个key放入同一个队列 一个协程执行完后从自己队列中取出下一个执行 问题: 协程执行取出下一个执行时，如果消息处理不过来会产生队列内的处理逻辑的堆积。队列很多时，堆栈的层级也会很多(因为逐层调用)，导致堆栈爆掉。 改进： 取出下一个执行时，不直接执行而是放入update中执行。 问题： 协程锁死锁情况，await互相等，永远等不到 改进： ET协程锁添加时间限制，时间到了解锁(超时机制)。","categories":[{"name":"框架篇","slug":"框架篇","permalink":"http://ysich.github.io/categories/%E6%A1%86%E6%9E%B6%E7%AF%87/"}],"tags":[{"name":"CallBack","slug":"CallBack","permalink":"http://ysich.github.io/tags/CallBack/"}]},{"title":"ManagerOfManager","slug":"ManagerOfManager","date":"2023-01-17T06:14:51.000Z","updated":"2023-01-17T08:48:13.113Z","comments":true,"path":"2023/01/17/ManagerOfManager/","link":"","permalink":"http://ysich.github.io/2023/01/17/ManagerOfManager/","excerpt":"","text":"框架搭建随笔版本号使⽤版本号命名的⽂件格式为: Framework_vX.Y.Z X 是主版本号，⽤于不向前兼容的更新。 Y 是中间版本，⽤于可向前兼容的功能性更新。 Z 是⼩版本号，⽤于功能完善和 bug 修复的更新 ⼀般都是从 v0.1.1 这个版本开始发布的，但是这个版本呢叫做 mvp 版本，也就是最⼩可验证版本。后续发布版本都需要向前兼容 Obsolete 标签使用Obsolete标签标记方法已弃用，使用其他方法。 添加弃用标签后会报警报提醒 12345[Obsolete(\"方法已过时，请使用xx方法\")]public static void OpenInFolder(string folderPath){ Application.OpenURL(\"file://\" + folderPath);} Partial关键字当类后续可能增长的时候使用，各个部分类需要用相同的访问权限。而且每个部分类都需要加partial关键字。 方法结构重复 解决方案当一个方法的的参数类型不同时，如果有共同父类可以将类型设置为父类，子类可以进行使用 123456789101112public static int GetRandomValueFrom(int[] values){ return values[Random.Range(0, values.Length)];}public static float GetRandomValueFrom(float[] values){ return values[Random.Range(0, values.Length)];}public static string GetRandomValueFrom(string[] values){ return values[Random.Range(0, values.Length)];} 可以将类型设置为object 1234public static object GetRandomValueFrom(object[] values){ return values[Random.Range(0, values.Length)];} 泛型实现结构复用使用泛型实现方法复用 1234public static T GetRandomValueFrom&lt;T&gt;(params T[] values){ return values[Random.Range(0, values.Length)];} params关键字修饰形参必须为一维数组，并且方法声明只能有一个params，如果不是一维数组编译器将报错。 使用 params 参数调用方法时，可以传入： 数组元素类型的参数的逗号分隔列表。 指定类型的参数的数组。 无参数。 如果未发送任何参数，则 params 列表的长度为零。 12345678910//数组元素类型的参数的逗号分隔列表public void Get(){ GetRandomValueFrom&lt;int&gt;(1, 2, 3);}//无参数public void Get(){ GetRandomValueFrom&lt;int&gt;();} 消息机制Unity内置消息机制方法调用使用字符串，可能用到反射，尽量不用。 1this.SendMessageUpward(\"MethedName\"); 通过委托通知A注册特定方法，B声明委托。当B想调用A的方法时，通过委托通知。 消息机制提供的功能 注册事件 注销事件 发送事件 123MsgDispatcher.Register(\"消息名\",(obj)=&gt;{ /* 处理消息 */ });MsgDispatcher.Send(\"消息名\",\"消息内容\");MsgDispatcher.UnRegister(\"消息名\"); new Class的优化当一个class作为存储数据时，为了减少new的次数可以做一个对象池进行存储 123456789101112131415161718192021222324252627282930313233private class MsgRecord{ //私有构造函数后，class无法被new private MsgRecord() { } //对象池 static Stack&lt;MsgRecord&gt; mMsgRecordPool = new Stack&lt;MsgRecord&gt;(); //创建对象 public static MsgRecord Allocate(string msgName, Action&lt;object&gt; onMsgReceived) { MsgRecord msgRecord; if (mMsgRecordPool.Count &gt; 0) { msgRecord = mMsgRecordPool.Pop(); } else { msgRecord = new MsgRecord { }; } msgRecord.Name = msgName; msgRecord.OnMsgReceived = onMsgReceived; return msgRecord; } //移除对象 public void Recycle() { Name = null; OnMsgReceived = null; mMsgRecordPool.Push(this); } public string Name; public Action&lt;object&gt; OnMsgReceived;} 框架的定义框架：提供⼀个架构（⽂件结构、约定等等），你必须遵守它，只要你遵守，那剩下的就 全部处理通⽤需求了。 好架构=好规则 库的定义库，插到既有 架构上，补充特定功能。 Unity常用架构1.EmptyGo 在 Hierarchy 上创建⼀个空的 GameObject,然后挂上所有与 GameObject ⽆关的逻辑控制的脚 本。使⽤GameObject.Find() 访问对象数据。 缺点:逻辑代码散落在各处,不适合⼤型项⽬。 2.Simple GameManager所有与 GameObject ⽆关的逻辑都放在⼀个单例中。 缺点:单⼀⽂件过于庞⼤ 3.Manager Of Managers将不同的功能单独管理。 如下: MainManager: 作为⼊⼝管理器。 EventManager: 消息管理。 GUIManager: 图形视图管理。 AudioManager: ⾳效管理。 PoolManager: GameObject管理（减少动态开辟内存消耗,减少GC)。 存储各类型的spawnPool，spawnpool存储各prefabPool。删除和添加时如果不需要立即操作，可以分步进行添加删除。(最基本拥有) LevelManager: 关卡管理。 (最基本拥有) GameManager: 游戏管理。 SaveManager: 配置&amp;存储管理。(最基本拥有) Easy save2插件使用二进制操作 ，对数据加密 MenuManager 菜单管理。 4.将 View 和 Model 之间增加⼀个媒介层UI和逻辑分离 MVCS: ​ StrangeIOC 插件。 ​ IBinder.Bind&lt;Key&gt;().To&lt;Value&gt;(); ​ IBinder.Bind&lt;Key&gt;().To&lt;Value&gt;().ToName(name);当key和value都相同时，根据name区分 ​ 通过event和listener来触发按键的操作 ​ 机制依赖于C#的Reflection(反射)，效率慢，模式、思想和理念可借鉴 MVVM: ​ uFrame 插件 5.ECS (Entity Component Based System) Unity 是基于 ECS,⽐较适合 GamePlay 模块使⽤ Manager Of Managers架构模式LevelManagerUnity里的LoadScene方法只能传递scene名字或index。改名或者变换顺序时变得非常麻烦。通过配置表配置，读取level时按顺序读取配置表即可。 PoolManager两个经典操作，Spawn、Despawn Spawn在创建新资源时，对象池有则直接调用，没有则需要初始化。 DeSpawn当池子容量达到指定上限时，将第一个第二个按照队列顺序进行销毁，先进先出。 对象池优化一个PoolManager下有若干个SpawnPool来管理一类的物体。比如NPC一个Pool，物品一个Pool。一个SpawnPool有若干个PrefabPool，一个PrefabPool只能存储一个Prefab，可以进行单个Prefab的加载和卸载。 对于每一个PrefabPool可以管理两个List，一个是ActivetedList，一个是DeactivateList，并管理所有Prefab的加载和卸载过程。 在删除时对数量要严格控制，一帧内不能同时删除太多物体，否则会触发GC。需要PoolManager管理时能够缓释，一帧只删除少量对象。 SaveManagerEasy Save2二进制进行Load和Save，与Unity很好的结合，Unity类型基本都能Serialized。比Json的一些方案快。 MainManager入口管理器，如资源加载流程、第三方SDK启动流程、热更新检测，都是在入口处完成的。 在开发阶段不同流程会有不同的log或调试需要进行阶段划分进行屏蔽。 职责： 管理多个入口 负责游戏的启动流程。 阶段划分 开发阶段:不断编码-&gt;验证结果-&gt;编码-&gt;验证结果-&gt;…. 出包/真机阶段：跑完整流程，QA测试 发布阶段：上线 对应的枚举 12345public enum EnvironmentMode{ Developing, QA, Release} 根据枚举执行抽象方法 123456789101112131415161718192021222324252627282930313233public abstract class MainManager : MonoBehaviour{ public EnvironmentMode mode; private static EnvironmentMode mSharedMode; private static bool mModeSetted = false; private void Start() { //不同场景不同mode时只会有一个唯一mode if (!mModeSetted) { mSharedMode = mode; mModeSetted = true; } switch (mSharedMode) { case EnvironmentMode.Developing: LaunchInDevelopingMode(); break; case EnvironmentMode.Test: LaunchInTestMode(); break; case EnvironmentMode.Production: LaunchInProductionMode(); break; } } protected abstract void LaunchInDevelopingMode(); protected abstract void LaunchInTestMode(); protected abstract void LaunchInProductionMode();} GuiManager加载卸载通过字典管理，加载和卸载通过存储Panel名字为key，GameObject为Value 123456789101112131415161718192021222324252627282930private static Dictionary&lt;string, GameObject&gt; mPanelDict = new Dictionary&lt;string, GameObject&gt;(); public static void UnLoadPanel(string PanelName) { if (mPanelDict.ContainsKey(PanelName)) { var gObj = mPanelDict[PanelName]; Destroy(gObj); } } public static GameObject LoadPanel(string PanelName, UILayer uILayer) { var PanelPrefab = Resources.Load&lt;GameObject&gt;(PanelName); var PanelObj = Instantiate(PanelPrefab, UIRoot.transform); PanelObj.name = PanelName; mPanelDict.Add(PanelName, PanelObj); switch (uILayer) { case UILayer.Bg: PanelObj.transform.SetParent(UIRoot.transform.Find(\"Bg\")); break; case UILayer.Common: PanelObj.transform.SetParent(UIRoot.transform.Find(\"Common\")); break; case UILayer.Top: PanelObj.transform.SetParent(UIRoot.transform.Find(\"Top\")); break; } return PanelObj; } 层级管理通过枚举分级,在Scene中创建相对应的GameObject来管理对应Panel的层级关系 123456public enum UILayer{ Bg, Common, Top} 在加载时加载到对应层级的GameObject中 12345678910111213141516171819public static GameObject LoadPanel(string panelName, UILayer uILayer){ var canvasObj = GameObject.Find(\"Canvas\"); var PanelPrefab = Resources.Load&lt;GameObject&gt;(panelName); var PanelObj = Instantiate(PanelPrefab, canvasObj.transform); switch (uILayer) { case UILayer.Bg: PanelObj.transform.SetParent(canvasObj.transform.Find(\"Bg\")); break; case UILayer.Common: PanelObj.transform.SetParent(canvasObj.transform.Find(\"Common\")); break; case UILayer.Top: PanelObj.transform.SetParent(canvasObj.transform.Find(\"Top\")); break; } return PanelObj;} UIRoot将前面所描述的canvas结构，制作为Prefab，名字为UIRoot，管理所有的UIPanel。 在GUIManager中存储一份，在加载Panel时使用。 1234567891011121314private static GameObject mPrivateUIRoot;public static GameObject UIRoot{ get { //懒加载 if (mPrivateUIRoot == null) { mPrivateUIRoot = GameObject.Instantiate(Resources.Load&lt;GameObject&gt;(\"UIRoot\")); } mPrivateUIRoot.name = \"UIRoot\"; return mPrivateUIRoot; }} AudioManager播放音效1234567891011/// &lt;summary&gt;音效 &lt;/summary&gt;public void PlaySound(string soundName){ CheckAudioListener(); var doorClip = Resources.Load&lt;AudioClip&gt;(soundName); var audioSource = gameObject.AddComponent&lt;AudioSource&gt;(); audioSource.clip = doorClip; audioSource.Play();} 播放背景音 12345678910111213141516/// &lt;summary&gt;背景音 &lt;/summary&gt;public void PlayMusic(string soundName, bool IsLoop = true){ CheckAudioListener(); if (mMusicSource == null) { mMusicSource = gameObject.AddComponent&lt;AudioSource&gt;(); } var doorClip = Resources.Load&lt;AudioClip&gt;(soundName); var audioSource = gameObject.AddComponent&lt;AudioSource&gt;(); audioSource.loop = IsLoop; audioSource.clip = doorClip; audioSource.Play();} PoolManager对象池解决的问题 减少new时候寻址造成的消耗，该消耗的原因是内存碎片。 减少Object.Instantiate时内部进行序列化和反序列化而造成的CPU消耗。 简易对象池获取的操作一般为Allocate(分配)，放入为Recycle(回收)。也有叫Spawn和Despawn 定义池接口12345public interface IPool&lt;T&gt;{ T Allocate(); bool Recycle(T obj);} 在Allocate和Recycle时不在意对象顺序，只需要位置连续，使用stack容器来存储对象。 使用一个简单工厂接口来创建对象。1234public interface IObjectFactory&lt;T&gt;{ T Create();} 对象池12345678910111213141516171819202122232425262728public abstract class Pool&lt;T&gt; : IPool&lt;T&gt;{ protected Stack&lt;T&gt; mCachedStack = new Stack&lt;T&gt;(); protected IObjectFactory&lt;T&gt; mFactory; protected int MaxNum = 5; public int curCount { get { return mCachedStack.Count; } } public virtual T Allocate() { if (mCachedStack.Count == 0) { return mFactory.Create(); } return mCachedStack.Pop(); } public abstract bool Recycle(T obj); //public virtual bool Recycle(T obj) //{ // if (mCachedStack.Count &gt;= MaxNum) // { // return false; // } // mCachedStack.Push(obj); // return true; //}} 基于工厂接口的简易工厂12345678910111213141516171819/// &lt;summary&gt;/// 基于工厂接口的简易工厂/// &lt;/summary&gt;/// &lt;typeparam name=\"T\"&gt;&lt;/typeparam&gt;public class CustomObjectFactroy&lt;T&gt; : IObjectFactory&lt;T&gt;{ /// &lt;summary&gt; /// 使用委托设置类内部信息 /// &lt;/summary&gt; private Func&lt;T&gt; mFactoryMethod; public CustomObjectFactroy(Func&lt;T&gt; factoryMethod) { mFactoryMethod = factoryMethod; } public T Create() { return mFactoryMethod(); }} 包含创建方法的简易对象池123456789101112131415161718192021222324252627/// &lt;summary&gt;/// 简易对象池/// &lt;/summary&gt;/// &lt;typeparam name=\"T\"&gt;&lt;/typeparam&gt;public class SimpleObjectPool&lt;T&gt; : Pool&lt;T&gt;{ //重置方法 Action&lt;T&gt; mResetMethod; public SimpleObjectPool(Func&lt;T&gt; factoryMethod, Action&lt;T&gt; ResetMethod = null, int initCount = 0) { mFactory = new CustomObjectFactroy&lt;T&gt;(factoryMethod); mResetMethod = ResetMethod; for (int i = 0; i &lt; initCount; i++) { mCachedStack.Push(mFactory.Create()); } } public override bool Recycle(T obj) { if (mResetMethod != null) { mResetMethod(obj); } mCachedStack.Push(obj); return true; }} 复盘设计一个比较复杂的模块结构时,可以先设计一个接口(规范)。描述内容有什么 在mFractroy.Create和Recycle(回收)时，更偏向于自定义的操作 LevelManager123456789101112131415161718192021222324public class LevelManager : MonoBehaviour{ //可换成配置表 private static List&lt;string&gt; mLevelNames; public static int Index { get; set; } public static void Init(List&lt;string&gt; levelNames) { mLevelNames = levelNames; Index = 0; } public static void LoadCurrent() { SceneManager.LoadScene(mLevelNames[Index]); } public static void LoadNext() { Index++; if (Index &gt;= mLevelNames.Count) { Index = 0; } SceneManager.LoadScene(mLevelNames[Index]); }} 单元测试Probject内-&gt;右键-&gt;Create-&gt;Testing 创建相对应的c#文件(test模板)在Test Runner 界面内可以看到所有的测试脚本和对应的方法 类似于自己编写测试用例进行测试 Assert.AreEqual叫做断言，在开发大项目时非常有用的工具。测试通不通过取决于断言通不通过。","categories":[{"name":"框架篇","slug":"框架篇","permalink":"http://ysich.github.io/categories/%E6%A1%86%E6%9E%B6%E7%AF%87/"}],"tags":[{"name":"Manager 框架","slug":"Manager-框架","permalink":"http://ysich.github.io/tags/Manager-%E6%A1%86%E6%9E%B6/"}]},{"title":"游戏资源管理","slug":"游戏资源管理","date":"2023-01-16T04:56:44.000Z","updated":"2023-02-01T09:32:57.671Z","comments":true,"path":"2023/01/16/游戏资源管理/","link":"","permalink":"http://ysich.github.io/2023/01/16/%E6%B8%B8%E6%88%8F%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/","excerpt":"","text":"游戏资源管理游戏运行就是一个接一个资源的展示，如何管理好这些展示的资源让游戏能够流畅运行在开发中非常重要。需要在合理的地方调用、加载资源，资源空闲时对其进行卸载以减少内存占用。当内存超出预算可能导致游戏闪退，所以对资源的管理实际就是对内存的优化！ 本文争取一文搞懂资源管理。PS：可能和一个视频学完c++差不多(一个视频一个多月) TODOLIST： 分包策略 依赖处理 AssetBundle详细 热更 断点续传 代码热更新/热重载 Lua重新将函数指针赋值的策略 HybridCLR 资源包和资源区分开 一些资源策略 整包只有基础内容，后续章节热更的形式(大资源情况) YooAsset扩展篇 资源管理主要的需求有哪些？ 为开发与正式版本提供资源的加载和卸载 支持远程更新资源 做好版本、平台、渠道的资源管理 内存优化 Unity中的两种加载方式Resources 资源必选放在Resources文件夹下；有容量上限(大概是2G)；重复加载和重复卸载操作，Unity做了容错处理不会报错。不支持热更，只能打整包 适合放游戏的启动逻辑需要的资源 可能会延长游戏启动时间 AssetBundle 可以理解成Unity内的资源压缩包，有不同的压缩方式，解压速度和包体大小也不同(LZMA 和 LZ4)。 适合做热更，以减少包体的初始大小。 已加载的资源不允许重复加载，会报错。而使用AssetDatabase则不需要考虑。需要使用引用计数。 这里还有一些开源的资源管理系统，如YooAsset。 同步加载与异步加载同步加载同步加载在加载资源时，会阻塞线程。等加载逻辑完成后才继续执行后续逻辑（图灵机） 异步加载同步加载在加载较大资源时阻塞明显，造成卡顿。因为Unity中所有的渲染都是放在主线程中的，所以主线程阻塞非常致命不能进行任何玩家操作。 所以需要使用另外一种加载方式对较大资源进行加载。异步加载使用协程/线程进行加载逻辑，等资源加载完毕后触发资源加载后的callback。 在一些资源的加载会影响到游戏的展示时，可以在需要之前对资源进行预先加载，保证流程能够顺利进行。 异步加载的三种状态异步加载的逻辑由于执行完成的时间不确定，可能会导致其他逻辑的冲突。所以我们给异步加载按照逻辑划分状态，好让其他逻辑能够做区分，不同状态下处理相应的操作。 未加载 异步加载还没开始时可能需要准备的事情，比如资源包不在本地需要下载、解密、解压等等。 加载中 资源开始加载后，其他业务逻辑也加载了相同资源时，可以判断这个资源的状态。正在加载则不再进行加载前的准备操作，并把加载后的callback注册进去。 已加载 主要为加载后触发相应callback。 123456public enum LoaderState { NONE, // 默认 LOADING, // 加载中 FINISHED, // 完成 } 存在问题玩家在进入一个场景后，假设资源预加载需要10s，玩家却在未加载完资源的过程中退出场景。这时候就会引发资源状态的问题。 资源缓存池资源缓存池为统一存储和调用资源的地方。在加载资源后统一存入池子中，卸载时则将其从池子中删除。 加载时先判断池子中是否存在此资源包，如果已经加载过了直接则直接使用，未加载再进行加载逻辑。 以下内容主要以AssetBundle举例 123public class AssetBundlePool{ private Dictionary&lt;string,AssetBundleInfo&gt; m_LoadAssetBundle = new Dictionary&lt;string,AssetBundleInfo&gt;();} 引用计数基础概念引用技术的应用范围很广，很多引擎、框架、插件的底层都离不开引用计数。 简单思想：被引用+1，不被引用时-1，当为0时触发清空逻辑。 123456789101112131415161718192021public interface IRefCounter{ int RefCount { get; } void Retain(); void Release();}public class SimpleRC : IRefCounter{ public int RefCount { get; private set; } public void Retain() { RefCount++; } public void Release() { RefCount--; if (RefCount == 0){ OnZeroRef(); } } protected virtual void OnZeroRef(){}} 与资源管理结合的引用计数资源被使用时引用次数+1，资源解除使用时次数-1，当引用次数为0时则进行卸载逻辑。 1234567891011public class AssetBundleInfo{ private AssetBundle m_AssetBundle; //AB包引用 public AssetBundle AssetBundle { get { return m_AssetBundle; } } public int m_ReferencedCount; //引用计数 public AssetBundleInfo(AssetBundle assetBundle) { m_AssetBundle = assetBundle; m_ReferencedCount = 1; }} 与资源缓冲池结合的加载123456789101112131415161718192021222324252627public class AssetBundlePool{ private Dictionary&lt;string,AssetBundleInfo&gt; m_LoadAssetBundle = new Dictionary&lt;string,AssetBundleInfo&gt;(); public AssetBundle LoadAssetsFromAB(string abName) { AssetBundleInfo assetBundleInfo = null; if (m_LoadAssetBundle.TryGetValue(abName, out assetBundleInfo)) { //检查是否加载过 assetBundleInfo.m_ReferencedCount++;//这里可以使用封装好的引用计数，为了方便展示直接使用 } else { string loadPath = PathUnit.DataPath + PathUnit.ABRootPath + abName; var ab = AssetBundle.LoadFromFile(loadPath); if (ab is null) { Debug.Log(\"AB包加载失败！\"+ loadPath); } else { assetBundleInfo = new AssetBundleInfo(ab); m_LoadAssetBundle.Add(abName, assetBundleInfo); //assetBundleInfo.m_ReferencedCount++;这里不需要加了因为默认值为1 } } return assetBundleInfo.AssetBundle; }} 异步加载也是相同的操作，但有点不同。需要一个额外的队列记录加载中的文件。当加载中的文件又收到了加载请求时，则需要在列表中查找是否正在加载。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class AssetBundleCachePool{ public MonoBehaviour monoBehaviour; private Dictionary&lt;string, AssetBundleInfo&gt; m_LoadAssetBundle = new Dictionary&lt;string, AssetBundleInfo&gt;(); private Dictionary&lt;string, Action&lt;AssetBundle&gt;&gt; m_LoadingAssetBundle = new Dictionary&lt;string, Action&lt;AssetBundle&gt;&gt;(); public void LoadAssetsFormAbAsync(string abName, Action&lt;AssetBundle&gt; loadingABAction) { monoBehaviour.StartCoroutine(OnLoadAssetsFormAbAsync(abName, loadingABAction)); } IEnumerator OnLoadAssetsFormAbAsync(string abName, Action&lt;AssetBundle&gt; loadingABAction) { AssetBundleInfo assetBundleInfo = null; if (m_LoadAssetBundle.TryGetValue(abName,out assetBundleInfo)) { Debug.Log(\"已加载过\"); AssetBundle assetBundle = assetBundleInfo.AssetBundle; //引用计数+1 assetBundleInfo.m_ReferencedCount++; //触发回调 if (loadingABAction != null) { loadingABAction.Invoke(assetBundle); } yield break; } else { if (m_LoadingAssetBundle.TryGetValue(abName,out Action&lt;AssetBundle&gt; temploadingABAction)) { if (loadingABAction != null) { temploadingABAction += loadingABAction; } Debug.Log(\"正在被加载\"); yield break; } else { //这步需要执行，避免与其他逻辑冲突 m_LoadingAssetBundle.Add(abName, loadingABAction); string loadPath = PathUnit.DataPath + PathUnit.ABRootPath + abName; AssetBundleCreateRequest assetBundleCreateRequest = AssetBundle.LoadFromFileAsync(loadPath); AssetBundle resAB = assetBundleCreateRequest.assetBundle; if (resAB is null) { Debug.LogError(\"AB包不能存在\"); } else { assetBundleInfo = new AssetBundleInfo(resAB); m_LoadAssetBundle.Add(abName, assetBundleInfo); } //加载完成移除加载中列表 //避免啥异常状况，保险点！先判断是否存在 if (m_LoadingAssetBundle.ContainsKey(abName)) { Action&lt;AssetBundle&gt; action = m_LoadingAssetBundle[abName]; m_LoadingAssetBundle.Remove(abName); var callBackList = action.GetInvocationList(); foreach (Action&lt;AssetBundle&gt; callBack in callBackList) { callBack.Invoke(resAB); } } } } }} 与资源缓冲池结合的卸载为了保持平衡有了加载就一定会有卸载。但是在游戏中(特别是手游)卸载操作需要加上一些限制，因为在短时间内进行了大量资源的卸载增加了大量的IO操作也会造成卡顿（线程阻塞）的。🙂 所以我们的卸载操作需要与数量和时间扯上关系，在一定时间内只卸载一定数量的资源。 在引用计数中，如果引用计数为0则标记为可以开始卸载了。 1234567891011121314public class AssetBundleInfo{ public int ReferencedCount { get { return m_ReferencedCount; } set { m_ReferencedCount = value; if (m_ReferencedCount&lt;= 0) IsUnLoadFlag = true; else IsUnLoadFlag = false; } } public bool IsUnLoadFlag { get; private set; } private int m_ReferencedCount; //引用计数} 与时间挂钩与时间挂钩就需要有个地方能够一直统计和计算我们的时间并进行回收 123456public class ResourceManager{ void Update(){ }} 依赖本文之前的代码都是没有考虑依赖的，所以如果真的跑起来会发现计数会有偏差。 一个资源身上用到了别的AB包中的资源，这时候如果只加载自身的AB包，就会出现资源丢失的情况。这时候就需要把当前资源需要用到的依赖包一起加载出来。 但是我们又要怎么知道这个资源依赖于哪些包？ 这时候就需要用到Unity提供的AB包依赖文件来判断，后缀.manifest·。 Asset篇Asset什么是Asst？浅谈Assets——Unity资源映射 Resources什么是Resources？Resources目录的优点与痛点 AssetBundle什么是AssetBundle？AssetBundle的原理及最佳实践 热更篇Todo💁♀这部分内容写在别的地方，比较乱后续整理。","categories":[{"name":"资源管理篇","slug":"资源管理篇","permalink":"http://ysich.github.io/categories/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%AF%87/"}],"tags":[{"name":"资源管理","slug":"资源管理","permalink":"http://ysich.github.io/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"}]},{"title":"Lua基础语法","slug":"Lua基础语法","date":"2023-01-13T06:12:28.000Z","updated":"2023-01-17T06:16:15.830Z","comments":true,"path":"2023/01/13/Lua基础语法/","link":"","permalink":"http://ysich.github.io/2023/01/13/Lua%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","excerpt":"","text":"Lua基础语法注意点 循环用do，if语句用then，都使用end结尾 Lua不支持自减和自加操作，只能i=i+1，i=i-1 字符串的第一个位置是1不是0 技巧 Lua的字符串可以存储0x00，可以用字符串存储二进制流 注释 用--开头，来写一段单行注释 1-- 单行注释 用--[[开头，]]结尾，写一段多行注释。 1234--[[ 多行 注释]] 变量对一个变量进行赋值就相当于声明变量，与python相似 声明的变量默认为全局变量1a=1 同时给多个变量赋值，多重赋值 1a,b=1,2 局部变量1local b=2 nil类型没有被声明过的变量都是nil nil类型只有一个值，就是nil nil类似null类型 if(nil)为false number类型1234--支持十六进制表示方法a=0x11--输出为17--科学计数法a=2e10 string类型单引号、双引号1234a=\"daeqeq\"b='sdarrr'--转义字符\\nd=\"sdada\\nsdar\" 多行文本多行文本无法使用转义字符 1c=[[asdasfffrrqweqq]] 字符串连接字符串连接符号.. 1234a=\"daeqeq\"b='sdarrr'c=a..bprint(\"asdaf\"..\"as232\") 数值转字符串1tostring(10) 字符串转数值tonumber转换失败为nil 1tonumber(\"193\") 获取字符串长度123a=\"daeqeq\"print(#a)--等价于s:len() string类型类似char数组Lua中string类型 类似于C里的字符数组，可以包含任意数值包括0x00，可以存储二进制流因为都是原原本本存储 将ascii码转为字符串12s=string.char(65)s=string.char(0x30,0x31,0x32,0x33) 取出string中的某一位的ascii码1234n=string.byte(s,2)print(n)--语法糖，第一个到最后一个s:byte(1，-1) format调用c的接口 12local f=string.format(\"%d,%d\",1,2)print(f) function函数函数默认返回值为nil，没有任何返回值则为nil 1234567function function_name() --bodyend--函数名放前面f=function(...) --bodyend 123456function f(a,b,c) print(a,b,c) return aend--c没有传值则为nilprint(f(1,2))--1 函数可以返回多个值12345function f(a,b,c) return a,bendprint(f(1,2)) 多个返回值可以使用多重赋值语句12345function f(a,b,c) return a,bendlocal i,j=f(1,2) tabletable接口123table.insert(a,\"d\")--插入元素，末尾添加table.insert(a,2,\"d\")--插入元素，第二个位置，后续元素后移local s= table.remove(a,2)--移除第2个元素 table数字下标可以存所有东西(number,string,table,function) 12345a={1,\"ac\",{},function() end}a[5]=123 --可以直接添加一个元素print(a[1])--获取table长度print(#a) table字符串下标以字符为table的下标 12345678910a={ a=1, b=\"1234\", c=function() end, d=123123}print(a[\"a\"])--下标符合变量命名规范时print(a.a) 全局表_GLua内的所有全局变量都在_G这个table内 包括table.insert中的table(也是全局变量)也存储在_G中，insert为table的下标 1234print(_G[\"table\"][\"insert\"])--function: 0000000063be4590--输出值为一个函数--多文件调用知识 布尔型不等于在Lua中不等于使用~=表示 123456789a=trueb=falseprint(1&gt;2)print(1&lt;2)print(1&gt;=2)print(1&lt;=2)print(1==2)--不等于print(1~=2) 与或非只有false和nil表示假其他都表示真，包括0 123print(a and b)print(a or b)print(not a) and``or返回的并不完全是true和false，会直接返回a或者b的值，可以通过短路求值 只有not返回true和false 123456a=nil --真b=0 --假print(a and b) --nilprint(a or b) --0print(not a) --trueprint(b&gt;10 and \"yes\" or \"no\") --no 分支判断if语句1234567if 1&gt;10 then print(\"1&gt;10\")elseif 1&lt;10 then print(\"1&lt;10\")else print(\"no\")end 循环for循环1234567for i=1,10 do print(i)end--步长为2for i=1,10,2 do print(i)end 倒序循环123for i=10,1,-1 do print(i)end i在过程途中不能赋值，赋值了也没用 假如对i赋值会被认定为新建了局部变量 1234for i=10,1,-1 do print(i) local i=1end break通过break退出循环 1234for i=10,1,-1 do print(i) if i == 5 then break endend while循环12345n = 10while n&gt;1 do print(n) n = n - 1end repeat循环和while循环基本一致 多文件调用require和import的区别require实现换个目录后就需要对路径进行变更 个人理解：绝对路径 12345local MyClassBase = require(\"app.classes.MyClassBase\")local MyClass = class(\"MyClass\", MyClassBase)local Data1 = require(\"app.classes.data.Data1\")local Data2 = require(\"app.classes.data.Data2\") import实现在模块名前添加多个”.” ，这样 import() 会从更上层的目录开始查找模块。 个人理解：相对路径 12345local MyClassBase = import(\".MyClassBase\")local MyClass = class(\"MyClass\", MyClassBase)local Data1 = import(\".data.Data1\")local Data2 = import(\".data.Data2\") require运行指定多文件 末尾不带扩展名 12--.\\?lua 把文件名匹配到？内require(\"文件名\") 不同层架文件夹用.分隔 1require(\"文件夹名.文件名\") 只会运行一次 12345678--lua文件有可以return返回值local r = require('hello')--后面调用的都是前面返回的内容require('hello')require('hello')require('hello')require('hello')print(r) package.path12package.path=package.path..\";./path/?.lua\"require('hello2') 多次调用调用lua文件内的函数 123456789101112--hello.lualocal hello={}function hello.say() print(\"hello world\")end//通过返回tablereturn hello--test.lualocal test=require('hello')//通过table内的方法调用test.say() 迭代table1234t={\"a\",\"b\",\"c\",\"d\"}for i=1,#t,do print(i,t[i])end 迭代器ipairs纯数字连续下标可以用 12345t={\"a\",\"b\",\"c\",\"d\"}--下标给i，值给jfor i,j in ipairs(t) do print(i,j)end 1234567891011t={ [1]=\"a\", [2]=\"b\", [3]=\"c\", [5]=\"d\"}--下标给i，值给jfor i,j in ipairs(t) do --只能遍历到1到3，不连续的后面遍历不到 print(i,j)end 迭代器pairs可以遍历所有下标 pairs内部调用的是next函数 1234567891011t={ [1]=\"a\", [2]=\"b\", [3]=\"c\", [5]=\"d\"}--下标给i，值给jfor i,j in pairs(t) do --只能遍历到1到3，不连续的后面遍历不到 print(i,j)end 1234567891011t={ apple=\"a\", banana=\"b\", eraser=\"c\", water=\"d\"}--下标给i，值给jfor i,j in pairs(t) do --只能遍历到1到3，不连续的后面遍历不到 print(i,j)end 元表、元方法语法糖12345678t={ a=0, add=function(tab,num) tab.a=tab.a+num end}--类似于面向对象的方法调用t:add(10)--等价于t.add(t,10) 面向对象123456789101112131415161718192021222324--对象名bag={}bagmt={ --装入东西的函数 put=function(t,item) table.insert(t.items,item) end, take=function(t) return table.remove(t) end, list=function(t) return table.concat(t.items,\",\") end}bagmt[\"__index\"]=bagmt--构造函数function bag.new() local t={ items={} } setmetatable(t,bagmt) return tend 协程coroutine一个lua虚拟机里只能有一个线程 coroutine.create 可创建一个协程返回值为 thread 类型 123456local co=coroutine.create( function() print(\"hello world!\") end )","categories":[{"name":"编程语言篇","slug":"编程语言篇","permalink":"http://ysich.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%AF%87/"}],"tags":[{"name":"Lua","slug":"Lua","permalink":"http://ysich.github.io/tags/Lua/"}]}],"categories":[{"name":"框架篇","slug":"框架篇","permalink":"http://ysich.github.io/categories/%E6%A1%86%E6%9E%B6%E7%AF%87/"},{"name":"资源管理篇","slug":"资源管理篇","permalink":"http://ysich.github.io/categories/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%AF%87/"},{"name":"编程语言篇","slug":"编程语言篇","permalink":"http://ysich.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%AF%87/"}],"tags":[{"name":"Manager 框架 ET框架","slug":"Manager-框架-ET框架","permalink":"http://ysich.github.io/tags/Manager-%E6%A1%86%E6%9E%B6-ET%E6%A1%86%E6%9E%B6/"},{"name":"CallBack","slug":"CallBack","permalink":"http://ysich.github.io/tags/CallBack/"},{"name":"Manager 框架","slug":"Manager-框架","permalink":"http://ysich.github.io/tags/Manager-%E6%A1%86%E6%9E%B6/"},{"name":"资源管理","slug":"资源管理","permalink":"http://ysich.github.io/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"},{"name":"Lua","slug":"Lua","permalink":"http://ysich.github.io/tags/Lua/"}]}