{"meta":{"title":"ysich'Blog","subtitle":"","description":"","author":"ysich","url":"http://ysich.github.io","root":"/"},"pages":[{"title":"三十六分热","date":"2023-01-16T12:19:47.112Z","updated":"2023-01-16T12:19:47.112Z","comments":false,"path":"about/index.html","permalink":"http://ysich.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"AUP异步上传管线","slug":"AUP异步上传管线","date":"2023-10-27T02:17:37.000Z","updated":"2023-10-27T02:18:51.711Z","comments":true,"path":"2023/10/27/AUP异步上传管线/","link":"","permalink":"http://ysich.github.io/2023/10/27/AUP%E5%BC%82%E6%AD%A5%E4%B8%8A%E4%BC%A0%E7%AE%A1%E7%BA%BF/","excerpt":"","text":"AUP异步上传管线Async Upload Pipeline 优化加载性能：了解异步上传管线AUP (qq.com) 同步与异步在同步上传管线中，Unity必须在单个帧中同时加载纹理或网格的元数据、纹理的每个Texel或网格的每个顶点数据。而在异步上传管线中，Unity则在单个帧中仅加载元数据，并在后续帧中将二进制数据流式传输到GPU。 同步上传管线在项目构建时，Unity会将同步加载的网格或纹理的标头数据和二进制数据都写入同一.res文件（res即Resource）。在运行时，当程序同步加载纹理或网格时，Unity将该纹理或网格的标头数据和二进制数据从.res文件（磁盘中）加载到内存（RAM）中。当所有数据都位于内存中时，Unity随后将二进制数据上传到GPU（Draw Call前）。加载和上传操作都发生在主线程上的单个帧中。 异步上传管线在项目构建时，Unity会将标头数据写入到一个.res文件，而将二进制数据写入到另一个.resS文件（S应该指Streaming）。在运行时，当程序异步加载纹理或网格时，Unity将标头数据从.res文件（磁盘中）加载到内存（RAM）中。当标头数据位于内存中时，Unity随后使用固定大小的环形缓冲区（一块可配置大小的缓冲区）将二进制数据从.resS文件（磁盘中）流式传输到GPU。Unity使用多个线程通过几帧流式传输二进制数据。 注意：使用AUP时，AB包必须是LZ4压缩。 在构建过程中，纹理或网格对象会写入序列化文件，大型二进制数据的纹理或顶点数据会写入附带的.resS文件，这样的配置应用于玩家数据和资源包。 AUP可以加载纹理和网格，但可读写纹理、可读写网格和压缩网格都不适用于AUP。 AUP对每个指令会执行以下过程： 等待环形缓冲区中所需内存可用。 从源.resS文件中读取数据到分配的内存。 执行后期处理过程，例如：纹理解压、网格碰撞生成、每个平台的修复等。 以时间切片的方式在渲染线程进行上传。 释放环形缓冲区内存。 参数时间片QualitySettings.asyncUploadTimeSlice 设定渲染线程中每帧上传纹理和网格数据所用的时间总量，以毫秒为单位。 当异步加载操作进行时，该系统会执行二个该参数大小的时间切片，该参数的默认值为2毫秒。 如果该值太小，可能会在纹理/网格的GPU上传时遇到瓶颈。而该值太大的话，会造成帧率陡降。 如果上传时间设定的太长，那么留给渲染的时间就会变少。 缓冲区大小QualitySettings.asyncUploadBufferSize 该参数设定环形缓冲区的大小，以MB为单位。当上传时间切片在每帧发生时，要确保在环形缓冲区有足够的数据利用整个时间切片。 如果环形缓冲区太小，上传时间切片会被缩短。 当纹理大小超过缓冲区大小时，会先消耗完缓冲区剩余大小，再重新分配至纹理所需大小，待上传完成后缓冲区再调整至设置大小。 QualitySettings.asyncUploadPersistentBuffer它决定在完成所有待定读取工作时，是否释放上传时使用的环形缓冲区。 分配和释放该缓冲区经常会产生内存碎片，因此通常将其保留为默认值True。如果需要在未加载时回收内存，可以将该值设为False。 建议 选择不会导致掉帧的最大QualitySettings.asyncUploadTimeSlice。 在加载界面时，可以临时提高QualitySettings.asyncUploadTimeSlice。 使用性能分析器来检查时间切片的利用率。时间切片在性能分析器中会显示为AsyncUploadManager.AsyncResourceUpload。如果时间切片没有完全利用的话，就提高QualitySettings.asyncUploadBufferSize。 使用更大的QualitySettings.asyncUploadBufferSize会提高加载速度，所以如果内存足够的话，请将其从16MB提高至32MB。 将QualitySettings.asyncUploadPersistentBuffer保留为true，除非有理由在未加载时减少运行时内存的使用。","categories":[],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://ysich.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"Unity性能优化","slug":"Unity性能优化","date":"2023-09-08T01:18:59.000Z","updated":"2023-09-08T01:20:53.186Z","comments":true,"path":"2023/09/08/Unity性能优化/","link":"","permalink":"http://ysich.github.io/2023/09/08/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","excerpt":"","text":"Unity性能优化第1节 静态资源优化在Unity中的资源都存放在asset内，分为了外部导入资源和内部创建资源，无论是哪种资源都涉及到导入问题。在不同平台上合理的资源导入设置能够带来更高的效率。 Unity在UPR下也提供了asset检测工具Asset Check。 Audio当实现静音功能时，不要简单设置音量为0，应该销毁AudioSource组件，将音频从内存中卸载。 Force To Mono单声道一些双声道资源两个声道的声音一致，或移动设备下听不出区别则可以开启来减少内存。 压缩我们应该尽可能使用未压缩的WAV格式文件作为源文件。通过不同平台支持的压缩格式进行压缩。 大部分移动平台下使用Vorbis格式进行压缩，如果音频不进行循环还可以使用mp3格式。 一些操作系统对特定的压缩格式有特定的优化，比如ios下的mp3格式。 对一些简短常用的音效还可以使用ADPCM格式，可能压缩比不是最好的但是在播放时解码速度快。 采样率我们还需要关注音频的采样率，采样率高音频大小也会随之变大。 在移动平台下一般设置为22050Hz，经验之谈。在移动平台下一般都会选择对音质影响最小的最低设置。 在Sample Rate Setting中选择复写采样频率。 加载类型不同的音乐类型推荐使用不同的加载类型。Load Type。 Decompress On Load 音频压缩后大小小于200kb Compressed In Memory 音频压缩后大小大于200kb Streaming 适合背景音，较长较大的音频。通过流加载，避免加载卡顿。","categories":[],"tags":[{"name":"性能优化 资源管理 Asset","slug":"性能优化-资源管理-Asset","permalink":"http://ysich.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86-Asset/"}]},{"title":"帧同步设计","slug":"帧同步设计","date":"2023-09-07T02:23:48.000Z","updated":"2023-09-07T02:29:50.750Z","comments":true,"path":"2023/09/07/帧同步设计/","link":"","permalink":"http://ysich.github.io/2023/09/07/%E5%B8%A7%E5%90%8C%E6%AD%A5%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"帧同步设计第1节 简介状态同步 逻辑计算在服务器 服务器同步变化给客户端 客户端只做表现 帧同步 服务器广播客户端指令 逻辑计算在客户端逻辑层 客户端逻辑层发送变化给表现层 相当于把状态同步的服务器挪到了客户端逻辑层 适合的场景操作少，逻辑变化多 同场景玩家数少，需要同时同步的数量少 同视野单位特别多的场景 只适合开房间类型 不太需要单位信息保密的场景，安全性等级较低的场景 以上条件缺一不可 帧同步优势 流量少 具体流量多少看玩家数量 录像文件小 只需要记录操作 状态同步则是保存协议消息 服务器不做验证的话，服务器消耗小 帧同步误区 帧同步手感更好 帧同步开发简单，难度低 帧同步对网络速度要求低 如果需要体验流畅反而网络要求更高 帧同步各个客户端表现一模一样 只能保证逻辑层一致 帧同步可以减少服务器 帧同步的几种方案 服务器消息驱动帧同步：服务端固定帧率收集消息，定时广播，客户端指令没有帧的概念，帧是由服务端消息驱动的，适合玩家数量稍多的场景，预测只能做表现层的预测，开发难度相对简单 预测回滚帧同步：服务的固定帧率收集消息，客户端也有自己的帧，适合2-3人的场景，逻辑层有做预测，预测失败则回滚，开发难度大 第2节 网络0GC处理0GC的消除策略0GC就是不分配，共用对象池。但是多线程情况下共用对象池存在风险。 服务端不消除GC 客户端手动消除消息GC，消除量级比较大的消息 0GC的方式 MessagePool 线程安全的消息对象池 MemoryPack提供了ref的反序列化方式 不是new对象的形式 消息中的成员回收 消息中容器回收，MemoryPack会对容器调用Clear，容器中最好是struct MemoryPack构建struct的时候用的非反射方式，没有拆装箱避免了gc MemorySteam GC消除 Udp Send Recv GC消除 消息的创建回收 MessageObject.IsFromPool 消息都继承于MessageObject 发送消息时创建，消息传到网络层序列化完成后回收 发送的时候需要自己调用Create(true); 回收是框架自动调用Dispose(); 接受消息时创建，消息传到主线程使用完成后回收 接收的时候框架自动调用FetchMessage 回收需要自己调用Dispose(); MemoryBuffer创建回收MemoryBuffer是MemoryStream子类，主要为了配合MemoryPack用的 IBufferWriter接口 框架自动回收，使用者不需要关心 MemoryPack Source Generator不像protobuf通过反射生成代码，完全支持unity AssemblyBuilder失效 使用IDE编译Dll，所有代码放到Unity.Codes工程里面，开启ENABLE_CODES启用dll模式，跟ET7中相反 Unity.Codes分成Model跟Hotfix，报错，没找到问题，所以客户端热重载暂时不能用 第3节 框架层调整 EntityRef 原本对Entity的引用只能通过InstanceId，现在增加EntityRef持有Entity 当Entity被释放或者回收掉时，再去取EntityRef则为null Entity不再统一注册到Root中 在原本的设计中Root管理Entity，通过InstanceId为key来取出Entity。 只有Actor对象的Entity挂载了MailboxComponent的才会注册到ActorMessageDispatcherComponent中 TypeSystem EntitySystemSingleton，可扩展的Entity System机制 把之前EventSystem内一些生命周期的事件，抽出到EntitySystemSingleton中。 LSEntitySystemSingleton Domain IScene, 更完善，Scene的代码都简化了 只要Entity有IScene接口都可以是Domain Scene中简化了Parent和Domain的字段 Entity中Components改成SortedDictionary，保证有序 原本的Entity中的Components只是字段，在不同机器上的hash值不一样顺序也不一样。帧同步则会有问题，在Entity执行Disponse时，不同机器移除顺序不同则会造成问题。 Mongo序列化BeginInit, SerializeSystem Entity序列化时，调用BeginInit遍历判断Componets是否有ISerializeToEntity接口，有则加入ComponentDB 增加SerializeSystem，用于判断有些同类型Entity哪些需要存储哪些不需要存储。 配置文件改成了Bson，直接支持Dictionary 第4节 帧同步架构 客户端的Room相比服务端的Room多了个表现层 客户端挂载的是LSClientUpdate，服务端挂载的是LSServerUpdate，客户端相对服务端而言多了预测回滚的功能。 第5节 LSEntity为什么要LSEntity 限制Entity的Id生成 Entity的id都是通过IdGenerater生成，那么不同设备上生成出来的id会不一致。会导致逻辑不一致。 LSEntity AddChild和AddComponent时生成的id是统一的。 LSEntity 的Id序列化和反序列操作后不变。 LSWorld不能使用Update LateUpdate Load等等 需要专用的Update类似于FixedUpdate，每固定时间触发。 服务器的Load和客户端的Load，代码不一致可能导致结果也不一致。 序列和反序列化导致InstanceId跟System绑定关系失效，不能写一个老式的FixedUpdate 回滚逻辑在把操作进行序列化和反序列后，instanceId产生变化会自增1，导致失效。 用Id跟System绑定，专用的 LSUpdateSystem FixedUpdateSystem的实现 可以针对LSEntity，加上float分析器限制 LSWorld：LSEntityLSWorld只能挂在LSEntity 定点数部分，纯逻辑层 没必要所有代码都使用定点数，只有在于帧同步玩法内才需要。比如Room内LSWorld部分才使用定点数。 序列化反序列化, 回滚的部分 只有逻辑层、纯定点数部分才需要回滚。 Id生成器 随机数 服务器生成的随机数种子，使客户端通过Id生成器生成的Id能保持一致。 LSUpdater，注意，这个不是fixedUpdate，记录有哪些Entity有LSUpdate System LSEntitySystemSington LSUpdateSystem LSRollbackSystem 和表现层做和解用的 LSUpdater.Update驱动Room上挂有一个Updater组件，在固定帧调用LSWorld的Updater 客户端的Update间隔和服务端不一致，客户端可能需要动态调整，时间的膨胀、搜索。在服务端的Room上挂服务端的Update组件，在客户端的Room上挂客户端的Update组件。 LSRollbacke在表现层使用，用于状态回滚。表现层向逻辑层进行一一核对。 第6节 预测回滚RoomFrameBuffer输入缓存给记录的帧率限定数量，当超过限定值时则从记录的第一帧开始覆盖。 记录所有人的输入。每一帧的输入，每一帧都是一个字典。 每一帧的快照，记录帧并序列化。 每一帧都有一个hash值，用于做帧内容的对比。 FixedTimeCounter 固定时间计算，固定时间可改变用来计算FixedUpdate的时间，到FixedTime的时间才会调用LSWorld的Update。 为什么不用固定时间调用？因为每帧时间不是固定的，客户端的时间会膨胀收缩。如果客户端的时间比服务端慢了，那么客户端的帧的间隔会减小。因为要保证客户端的预测帧一直跑在服务器的权威帧之前。 LSWorldRoom的child 可以有多个，持有Ref的引用性能会高些。 PredictionFrame 预测帧 AuthorityFrame 权威帧预测帧就是客户端根据玩家操作预测出来的帧。服务器在做转发时，如果当前帧有玩家没输入则使用上一帧输入的数据做预测。 权威帧对客户端而言就是服务器下发的帧，确认帧。对服务端而言不做预测所以都是权威帧。 预测作用： 本地立即响应 提前发送操作给服务端，服务端的权威帧跑到了后可以马上广播 策略： 客户端预测自己的输入，直接获取。 客户端预测别人的输入，取上一帧的输入。避免权威帧到了之后做过多的回滚操作，因为大概率操作和上一帧一样。 服务的预测，时间到了，客户端的输入没有发送过来，直接取客户端上一帧的输入，相当于丢弃客户端的输入。 权威消息处理 权威消息比预测消息早 如果预测消息晚于权威消息，那么直接使用权威帧就不用预测了。 权威消息跟预测内容一样 消息一样则不用处理 权威消息跟预测消息不一致 如果和预测消息不同，那么就需要进行回滚。客户端先把权威帧的数据拷贝到预测帧中，然后回滚到权威帧时的world，然后执行权威帧。权威帧后面从帧数则要重新进行预测。 表现层，遍历Room下所有非LSEntity的Components，因为LSEntity是数据层使用的，然后做递归遍历执行所有的RollbackSystem。 第7节 客户端时间膨胀收缩-检测不同步客户端的预测帧需要在服务端处理到权威帧下一帧之前到达服务端。 动态调整客户端fixedTime每秒钟，服务端发送客户端的消息延迟时间给客户端 Room2C_AdiustUpdateTime 消息延迟的时间怎么算？比如当服务器跑到第2帧了，但是服务器只记录了第0帧的输入数据，那差距就是2帧的时间。 当客户端收到服务端同步的消息延迟时，缩放update的间隔，在一秒内完成调整(把每一帧的时间平均分一下)。 调整公式新的一帧时间 = （原来的一帧时间 + ( diffTime - 一帧时间 ) ）/ ( 1000 / 一阵时间 ) ps: diffTime - 一帧时间 ，因为预期是快一帧的时间所以减去一帧时间。 调整限制给调整的时间加个限制，如果一秒内调整不完那就放到下一秒调整。 最快一秒25帧，最慢一秒15帧 不同步检测客户端权威帧改变的时候，计算lsworld序列化的hash值给服务端，服务端对比hash值 第8节 录像Replay帧同步录像包含信息 记录初始化信息 玩家、时间、版本号这类信息 记录每帧输入 记录对局中的每一帧的数据 定期记录LSWorld序列化 如果没有序列化LSWorld，那在回放指定帧时计算过程会很长，计算过程可能导致卡顿。 比如每一分钟记录一次，播放指定帧时直接取出序列化文件反序列化。 LSReplayUpdaterLSReplayUpdater是从Replay中取出帧指令执行的，跟客户端和服务端的updater从framebuffer中取数据不同。 Replay跳转JumpReplay 如果在replay时快照的下标和当前权威帧计算出来的下标一致时，则不再取出快照进行序列化。因为快照是同一份。 如果跳转的帧小于当前的权威帧，那么还是需要反序列快照进行播放。 fame/快照记录的时间=快照下标 Replay加速播放ChangeReplaySpeed 调整每一帧播放的间隔时间 第9节 断线重连主要在loginGate的部分 判断账号是否在线，需要做顶号操作。可能是旧连接保持连接或者被顶号。 判断是否在帧同步房间内。 取出当前room数据转发给客户端，客户端根据数据生成room 把session挂上玩家，playersession赋值session 之前的设计session是一个entity。帧同步这里则是PlayerSessionComponent上的一个变量。这样做的好处就是session如果空了，下次断线重连赋值后就可以直接做转发。判空就行，不用判断连接状态。 客户端收到Reconnect消息时，进行场景切换。SceneChangeToReconnect 第10节 同步方式变种多个LSWorld比如守望先锋有两个world，一个计算战斗一个计算回放。两个并行的逻辑层，在进行回放的时候把world进行切换一下就可以看到战斗回放。 取消每帧序列化可以再进行抽象，抽象出权威world和预测world。就不需要每帧都进行序列化，当发生回滚时只需要把权威worldcopy到预测world中然后生成新的预测world，可以减少每帧序列化产生的gc。 缺点就是需要同时计算两个world，计算量会更大。 守望先锋状态帧守望先锋既同步操作帧，也同步状态。每帧计算状态脏数据，同步的状态是脏数据。 因为是纯struct结果，很容易做内存对比取出脏数据。 如果帧预测成功，则丢弃服务器下发的脏数据。 帧预测失败则回滚到权威帧，然后应用服务器发过来的脏数据包，继续执行到预测帧。 优点：脏数据自动计算 缺点：需要用纯粹的ECS进行内存对比，或者通过计算差异的代码来计算差异，不够灵活。 ET状态帧 ET不需要自动计算差异，仍然和做MMO一样，计算变化的消息，每帧把变化的消息打包同步给客户端。 帧预测成功，则丢弃消息。 帧预测失败则回滚到权威帧，应用服务器发过来的变化消息，继续执行到预测帧。 优点：不需要纯ECS，很灵活。缺点：需要跟MMO一样处理任何变化，创建不同的变化消息协议，无法自动化。 ET状态帧继续扩展做两个world，一个权威world，一个预测world。服务器始终和客户端的权威world做状态同步，所以权威world一直是正确的数据。 使用ET状态帧同步，服务端可以做AOI裁剪，只同步玩家能看到的减少数据和计算量。预测也可以只关心看到的数据。 不用定点数，因为服务端权威world和客户端的权威world只做状态同步，所以可以不使用定点数。客户端相当于只充当表现层，真正的逻辑层在服务端。 预测失败，则复制权威world到预测world 定期同步权威world到预测world，进行校准。 甚至可以权威world和预测world跟mmo一样只是部分逻辑层。相当于只是状态帧同步加上一个帧预测。 ET状态同步预测回滚状态同步，客户端都是表现，可以认为是表现层的预测回滚。moba等无法逻辑层预测回滚的游戏也能使用这种表现层预测回滚的形式 比如说demo鼠标点击移动做预测回滚 本地寻路完成立即移动，不用等服务端返回。向服务端发送寻路请求带一个客户端的时间 服务端返回寻路消息，这个时候，本地可以根据客户端这次移动了多少时间，重新计算服务端返回的路径应该走到了什么位置。然后表现层插值过去 收到stop的消息，预测失败，则立即stop到指定位置 更多方式大家取发掘，根据项目灵活应变 定点数物理库: https://et-framework.cn/d/1501-by/3 第11节 补充Updater中为什么要排序？LSWorld中的updater中的id为什么要排序？ 两个设备计算一致，id插入的顺序也一致为什么要排序？ Updater中的Entity是RegisterSystem注册进去的 反序列化注册Entity domain的时候会RegisterSystem 反序列化注册domain是从上到下执行的。 但是在运行时执行的顺序无法保证。而实际运行中的Updater并不是按这个规律执行 所以都用排序的方式，保持一致性。 帧同步逻辑内有关执行顺序的逻辑都需要小心，因为执行顺序不同造成的结果也是不同的。 预测回滚帧同步中逻辑层不能用协程预测回滚帧同步中逻辑层不能用协程，服务端驱动的状态帧同步可以 12345678910// 1await F1(); // 调用F2// 2await F2(); // 调用F3// 3await F3(); // 调用F4// 4await F4();//第四帧回滚到第一帧，协程F1重新执行，没什么问题//第四帧回滚到第二帧，协程状态机并不会重新回到第二帧的状态，导致协程丢失 因为协程的连续调用是链式反应。调用F2函数依赖F1函数执行完后才会调用。所以就算数据回滚了，函数的调用顺序也是有依赖关系。所以不能用协程。 预测回滚帧同步中使用事件的注意事项逻辑层抛出事件，表现层订阅事件 在回滚的时候，就不能触发表现的事件。因为当回滚时，如果表现层监听了逻辑层抛出的事件，那么就会造成表现层的错误。 解决办法是回滚过程中修改掉LSWorld的SceneType，这样回滚过程中的事件，表现层就订阅不到了 回滚完成再把LSWorld的SceneType修改正确 同样，两个demo中all in one，都是靠domain的SceneType来区分事件的 更加发散，如果使用权威world跟预测world的方案，区分事件也是一样通过SceneType来区分 怎么做预测？预测只是希望预测准确减少回滚的机率，所以只要计算量不大，怎么准确怎么来就行了 一般容易预测的就是一直触发的输入，比如移动输入，FPS机枪一直按着射击等等 按一下就弹起的键一般很难预测准确，就没必要预测了 比如某个职业有设计技能，需要一直按着按键，那么我们就可以做这种预测 浮点型分析器限制LSEntity的浮点型限制，一个类中有任何包含浮点类型的都会编译报错 1234567891011121314public class Test: LSEntity{ public float a; public List&lt;double&gt; b; public Dictionary&lt;float, int&gt; c; public Dictionary&lt;int, double&gt; d; public Dictionary&lt;int, HashSet&lt;double&gt;&gt; e;}","categories":[{"name":"框架篇","slug":"框架篇","permalink":"http://ysich.github.io/categories/%E6%A1%86%E6%9E%B6%E7%AF%87/"}],"tags":[{"name":"框架 ET框架 帧同步 状态帧同步","slug":"框架-ET框架-帧同步-状态帧同步","permalink":"http://ysich.github.io/tags/%E6%A1%86%E6%9E%B6-ET%E6%A1%86%E6%9E%B6-%E5%B8%A7%E5%90%8C%E6%AD%A5-%E7%8A%B6%E6%80%81%E5%B8%A7%E5%90%8C%E6%AD%A5/"}]},{"title":"AssetBundle详解","slug":"AssetBundle详解","date":"2023-08-29T03:03:56.000Z","updated":"2023-08-29T03:10:32.428Z","comments":true,"path":"2023/08/29/AssetBundle详解/","link":"","permalink":"http://ysich.github.io/2023/08/29/AssetBundle%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"AssetBundle详解AssetBundle一个AssetBundle有什么？ 一个序列化文件，标识符、是否压缩和清单(manifest)数据。 manifest数据是由对象的名称为key的查找表(lookup table)，每个条目都提供了一个字节的索引来标识对象在AssetBundle数据段的位置 资源文件，二进制数据块，支持异步加载 所有资源都被序列化，如果选择压缩则将序列化数据压缩。 AssetBundle的压缩方式LZMA基于文件流 包体小，解压时间长 因为使用流的方式，所以使用时必须加载整包，解压后会被重新压缩成LZ4 LZ4基于块(Chunk)的算法，读取文件时只需要解压文件所在的块数据 加载速度和不加载速度差不多，优势在于在内存中的占用变小了 会比LZMA的包体大25%，可以使用其他压缩手段进行二次压缩，包体也可以被压得很小。 差异更新可以通过包体的差异更新，在热更新的时候通过算法比对出新增内容再进行更新。因为是基于Chunk的算法，所以比对出来的差异文件会比较小，因为数据相对连续。 差异更新一般分为两种 基于源文件(安装包) 成功率高，算法简单 但在移动端保存所有源文件，在更新文件整合后再编译不现实。 基于二进制 也是最常用的差异比对方式，也是大多数PC游戏的做法。算是很成熟的技术了 可以和AB包配合，打出更小的热更包 Bsdiff ( 基于二进制的比对算法 )二进制比对生成差异化文件 比对两个版本文件的二进制数据，然后生成一个patch文件，再将这个patch打到旧文件就可以生成新文件。也就是游戏中的更新补丁包。 缺点：需要考虑二进制效率，生成的差异化文件可能会比小包情况大一些。 AssetBundle压缩算法不同导致的差异化文件差异在LZ4和LZMA两种压缩方式中，生成的差异化文件大小也是不同的。因为前面提到的AssetBundle的压缩算法都是先序列化再压缩。这就导致了LZMA的压缩算法可能导致一个Asset的数据分散开导致差异化文件过大，而LZ4压缩则是按块压缩数据相对比较集中。所以LZ4生成的差异化文件都比LZMA小。 Uncompressed(不压缩)的方式则差异不大 差异化文件(补丁)合并在合并差异化文件过程中，至少会进行一次文件复制，所以考虑到合并造成的IO消耗，所以单个包的大小还是需要限制一下。 在patch过程中，可能会造成界面卡顿，所以最好在其他线程中处理。 补丁文件的版本规划保持上个版本的全部文件，然后和新版本的文件做一次diff操作，然后把diff和新版本文件上传CDN。 如果有玩家多个版本没有更新，那么就下载多个版本的diff进行多次合并。如果跨越的版本数量过多，也可以中间插几个大版本的补丁包来减少补丁数量。 AssetBundle依赖项当Asset被打进AssetBundle包时，其他AssetBundle包依赖这个Asset时会变成依赖这个AssetBundle包。 当Asset没有打进AssetBundle包，在构建AssetBundle时如果有依赖于这个Asset则会将它打到一起。如果有多个AssetBundle依赖于这个Asset就会被打入多份，造成冗余。 如果AssetBundle内有依赖对象，在使用时需要先加载依赖的AssetBundle，Unity不会自动加载依赖项。需要自己根据AssetBundleManifest中加载依赖项。 当精灵图被依赖时，对应的精灵图集也会被打到AssetBundle中，容易造成图集冗余 AssetBundle之间的重复信息公共的资源最好打入一个AssetBundle包中，否则公共资源可能会被构建在多个AssetBundle包中。从而造成资源冗余，安装包的大小变大，运行时的内存占用量变大。 一个公共材质如果被打入到AssetBundle中会被视为副本，Unity将同一个材质的每个副本都视为独特材质。如果材质被打入到多个AssetBundle中，每个生成的AssetBundle都会包含此材质(包括其着色器和引用纹理)。Unity将同一个材质的每个副本都视为独特材质，所以还会影响到批处理。 所以在构建时材质和引用的资源尽量打在同一个AssetBundle中。还可以仅标记材质，因为纹理依赖关系也会被包含在AssetBundle中。 AssetBundle的加载AssetBundle.LoadFromMemoryAsync1AssetBundleCreateRequest createRequest = AssetBundle.LoadFromMemoryAsync(File.ReadAllBytes(path)); 按字节数组加载AB包。LZMA会在加载时解压，LZ4则会以压缩状态加载。 AssetBundle.LoadFromFile1var myLoadedAssetBundle = AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath, \"myassetBundle\")); 从本地存储中加载AB包。未压缩或LZ4直接从磁盘加载AB包，LZMA则先解压再加载到内存中。 从AssetBundle中加载资源123456//加载指定资源T objectFromBundle = bundleObject.LoadAsset&lt;T&gt;(assetName);//加载全部资源Unity.Object[] objectArray = loadedAssetBundle.LoadAllAssets();//加载依赖清单文件AssetBundleManifest manifest = assetBundle.LoadAsset&lt;AssetBundleManifest&gt;(\"AssetBundleManifest\"); AssetBundle的卸载AssetBundle.Unload(true)强制卸载掉所有AssetBundle中加载的Asset，包括AssetBundle的映射结构，和从AssetBundle创建出来的所有资源。释放AssetBundle实例。 会导致正在使用的资源丢失，需要一套自己的机制(引用计数)来关注是否有正在使用的资源。 AssetBundle.Unload(false)AssetBundle内的序列化数据会被释放，正在使用的资源还保持完好。等于断开了AssetBundle和实例的联系。再次使用这个AB包时，则会重新实例化一个新的，旧的就引用不到了。就造成了重复资源的冗余。 Resources.UnloadUnusedAssets卸载掉没有使用的Assets，作用范围是整个系统。 作用方式类似于GC，会遍历所有资源进行引用查询，会阻塞线程。 小结AssetBundle.Unload(false)更适用于一次性使用的资源，卸载后，在特定时机触发Resources.UnloadUnusedAssets就能卸载干净了。 AssetBundle.Unload(true)使用时最好添加引用计数作为保护。或在应用程序生命周期中具有明确定义的卸载瞬态 AssetBundle 的时间点，例如在关卡之间或在加载屏幕期间。 AssetBundle变体在Android 生态中有些设备不支持ETC2的纹理只支持ETC1的纹理，那么可以构建AssetBundle变体。使用ETC1支持的资源格式来构建AssetBundle变体，构建足够多的变体来支持Android 生态中不支持ETC2的设备。","categories":[{"name":"资源管理篇","slug":"资源管理篇","permalink":"http://ysich.github.io/categories/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%AF%87/"}],"tags":[{"name":"资源管理 AssetBundle 热更新","slug":"资源管理-AssetBundle-热更新","permalink":"http://ysich.github.io/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86-AssetBundle-%E7%83%AD%E6%9B%B4%E6%96%B0/"}]},{"title":"纹理详解","slug":"纹理详解","date":"2023-07-14T01:52:31.000Z","updated":"2023-07-14T01:53:36.556Z","comments":true,"path":"2023/07/14/纹理详解/","link":"","permalink":"http://ysich.github.io/2023/07/14/%E7%BA%B9%E7%90%86%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"纹理详解图像容量大小bpp每个像素的内存消耗 总图像存储大小 = width * height * bpp Non Power of 2长、宽不全是2的幂次尺寸的图片称为 NPOT（Non Power Of Two）格式的图片。 对于项目中需要压缩的贴图，需要尽量做成POT NPOT转成POT后，进行ToNearest操作可以压缩到六分之一大小。压缩比1：6 图片格式jpg有损压缩 不带Alpha通道 不可编辑，读取时需要先读取整张图片，再读取具体内容 png无损压缩 带Alpha通道 可编辑，可以直接读取具体内容 纹理格式对于所有平台RGBA 32Bit一个像素由红、绿、蓝三个色彩通道都由8位色彩深度组成，加上Alpha通道的8位，共计32位Bit。 Alpha通道8bit可以表示256级灰度，即透明度。 优点：适用所有设备 缺点：内存占用太高，移动平台基本不会直接使用 适用平台：Android、IOS RGBA 16Bit红色通道、绿色通道、蓝色通道和alpha 通道各4位。 Alpha8 只有透明度，没有颜色。 ASTC要求：iOS A8 处理器(iPhone6及iPad mini 4以上iOS设备)、Android 需要设备GPU支持 OpenGL ES 3.1及以上即部分 ES 3.0 优点：压缩后图片画质好、自由度高，有多种格式可以选择4x4~12x12、不要求图片尺寸 缺点：需要考虑支持的设备市场普及率，看了相关的几篇机型调查文章。不支持ES3.1的Android机型大概为1.5%，IOS基本没有。 适用平台：Android、IOS 注意：在不支持的设备上，贴图会解压成RGB(A)，然后与压缩的贴图一起存储在内存中，会增加纹理加载时间和增加额外内存 关于法线贴图法线贴图要求的质量会高一些，压缩度越高失真越严重，一般为 5 x 5 或 6 x 6 对于Android平台ETC1要求：贴图的长宽为2次幂 优点：适用所有的Android设备、压缩率较高 缺点：不支持带 Alpha 通道的贴图、肉眼可见失真，图集需要一张额外的Alpha通道的贴图。 适用平台：Android 压缩的RGB纹理。这是Android工程默认的纹理格式。ETC1是OpenGL ES 2.0标准的一部分，并且支持所有的OpenGL ES 2.0 GPU，但它不支持Alpha。 ETC2要求：贴图的长宽要能被4整除、OpenGL ES 3.0及以上 优点：支持Alpha通道的贴图 缺点：内存占用大于ETC1格式 适用平台：Android 注意：在不支持 ETC2 的 Android 平台上，纹理在运行时解压缩为 Build Settings 中的 ETC2 fallback 指定的格式，默认自动转成RGBA32/ARGB32的格式 对于IOS平台PVRTC要求长宽相等。且为2的幂次方 有些GUP不支持NPOT，遇到NPOT会有一个转换POT的过程，浪费性能 Texture Cache小结PS：在图集在纹理采样时，如果尺寸不是2次幂会被引擎层拉伸成2次幂，因为GPU光栅化需要对纹理采样进行快速取值。所以存储时如果非2次幂则节省内存，但是采样时会消耗额外性能；存储时如果拉伸为2次幂存储则费内存，采样时则节省性能。 TexturePacker工具TP工具打图集流程 调用TexturePacker 命令行打图集 下载TexturePacker工具，然后用命令行调用tp打图集，完成之后会生成2个文件，一张打好的图集，一份保存了真实图片的位置信息.txt文件 拆分alpha通道 texture导入精灵图(spritesheet) 生成材质球 生成预制，将padding信息保存在so里【atlas_tp_padding.asset】，游戏运作中需要用到 Padding信息存储和读取在打图集的时候，保存图片的位置信息，然后在图片绘制网格的时候，读取这些信息，计算出真实的位置信息，再将像素绘制上去 Image一些接口说明UGUI的OnPopulateMesh函数UGUI中与显示相关的控件，例如Image、Text、RawImage等都继承自MaskableGraphic类，MaskableGraphic类继承自Graphic类。 控件在画面中的形状、颜色、法线等信息都是由Graphics类中的OnPopulateMesh函数所控制每当改变了顶点或者纹理后，会调用OnPopulateMesh函数其中VertexHelper是一个顶点辅助类，保存着生成Mesh的基本信息 绘制图形 AddVert 添加顶点(第一个添加的顶点索引为0，第二个添加的顶点为1，依次…..) AddTriangle 绘制三角形(GPU绘制时会按照输入的顶点下标的顺序绘制一个三角形) 绘制四边形时，就是绘制两个三角形。 currentIndexCount VertexHelper结构中有几个顶点索引(重合的顶点被计为2个顶点，例如一个三角形最少有3个顶点，一个正方形最少有6个顶点) currentVertCount VertexHelper结构中有几个顶点(AddVert添加了几个顶点就有几个) PopulateUIVertex 获取某个索引的顶点数据 SetUIVertex 设置某个索引的顶点数据 AddUIVertexQuad 把AddVert和AddTriangle封装到一个函数中 AddUIVertexStream 把AddVert和AddTriangle封装到一个函数中 sprite和overrideSprite的区别官方的说法，overrideSprite 用于临时修改图片，sprite 用于永久修改图片。 overrideSprite 用于修改图片，但是不会把原来的图片给消除掉，直接的效果是如果 overrideSprite 是 null 的话，会变回原本的图片。可以理解为 overrdieSprite 是覆盖在 sprite 上的一层图片。所以，若使用 overrideSprite 更换图片，接下来要更换也只能用overrideSprite再覆盖掉，除非把它置为 null，不然用 sprite 更换是显示不出来的。 写入padding信息 spriteSourceSize为真实图片的位置信息。 sourceSize为原本的图片信息。 padding为 1234float left = frame.spriteSourceSize.x;float top = frame.spriteSourceSize.y;float right = frame.sourceSize.x - frame.spriteSourceSize.x - frame.spriteSourceSize.width;float bottom = frame.sourceSize.y - frame.spriteSourceSize.y - frame.spriteSourceSize.height; 运行时设置padding信息SpriteAssetMoudle初始化Init时，设置SDImage的静态对象`m_spritePaddingMap m_spritePaddingMap&lt;string,Vector4&gt;spriteName为key，padding参数为value。 重写OnPopulateMesh接口123456789101112131415161718192021222324252627282930313233343536373839404142434445protected Vector4 GetDrawingDimensions(bool shouldPreserveAspect){ Sprite overrideSprite = this.overrideSprite; var padding = GetPadding(); var size = overrideSprite == null ? Vector2.zero : new Vector2(overrideSprite.rect.width, overrideSprite.rect.height); Rect r = GetPixelAdjustedRect(); int spriteW = Mathf.RoundToInt(size.x); int spriteH = Mathf.RoundToInt(size.y); float width = spriteW + padding.z + padding.x; float height = spriteH + padding.w + padding.y; var v = new Vector4( padding.x / width, padding.y / height, (width - padding.z) / width, (height - padding.w) / height); if (shouldPreserveAspect &amp;&amp; size.sqrMagnitude &gt; 0.0f) { var spriteRatio = size.x / size.y; var rectRatio = r.width / r.height; if (spriteRatio &gt; rectRatio) { var oldHeight = r.height; r.height = r.width * (1.0f / spriteRatio); r.y += (oldHeight - r.height) * rectTransform.pivot.y; } else { var oldWidth = r.width; r.width = r.height * spriteRatio; r.x += (oldWidth - r.width) * rectTransform.pivot.x; } } //根据padding值换算出来的比例来计算新的 image顶点位置 v = new Vector4( r.x + r.width * v.x, r.y + r.height * v.y, r.x + r.width * v.z, r.y + r.height * v.w ); return v;} 获取Padding信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354protected Vector4 GetPadding(){ if (GameMain.Instance != null &amp;&amp; GameMain.Instance.enabled) { if (m_IsUrl || string.IsNullOrEmpty(SpriteName)) { return Vector4.zero; } if (m_spritePaddings == null) { //Debug.LogError(\"SpritePadding error\"); return Vector4.zero; } if (m_spritePaddings.ContainsKey(SpriteName)) { return m_spritePaddings[SpriteName]; } return Vector4.zero; } #if UNITY_EDITOR if (!overrideSprite) return Vector4.zero; if (UseSpritePacker) { return DataUtility.GetPadding(overrideSprite); } if (m_spritePaddings == null) { string path = PathDef.UI_ASSETS_PATH + \"/atlas_tp_padding.asset\"; PaddingData paddingData = AssetDatabase.LoadAssetAtPath&lt;PaddingData&gt;(path); m_spritePaddings = new Dictionary&lt;string, Vector4&gt;(); foreach (var atlas in paddingData.atlas) { foreach (var spriteInfo in atlas.spritesHavePadding) { if (m_spritePaddings.ContainsKey(spriteInfo.name)) continue; m_spritePaddings.Add(spriteInfo.name, spriteInfo.padding); } } } Vector4 v; if (!m_spritePaddings.TryGetValue(overrideSprite.name, out v)) { //Debuger.LogError(\"图集错误. 白边信息缺失: sprite:\" + overrideSprite.name); return Vector4.zero; } return v; #else return Vector4.zero; #endif} Texture相关TextureImporter此类中的设置与 Texture Import Settings 中显示的设置相匹配。 UnityEditor.TextureImporter - Unity 脚本 API TextureImporterPlatformSettings存储 TextureImporter 的平台特定设置。 UnityEditor.TextureImporterPlatformSettings - Unity 脚本 API SpriteMetaDataUnityEditor.SpriteMetaData - Unity 脚本 API EditorUtilityUnityEditor.EditorUtility - Unity 脚本 API Generate Mip Maps 属性开启Mipmaps可以使远离相机的物体使用较小的纹理版本，这样渲染时，显存带宽压力比较小，同时避免显示效果产生噪点（pix fight）。 Read/Write Enabled 属性Read/Write Enabled选项打开的时候主要是为了外部可以通过脚本进行一个修改，例如通过Texture2D.SetPixels、Texture2D.GetPixels和其他一些方法进行问理数据的访问。但是内部的话，unity并不是直接在原有的纹理上去做这些操作的，毕竟一个贴图可能用在很多地方，直接在原纹理图上进行修改的话，那么所有使用这个纹理的地方都会受到影响。所以内部unity会对原纹理进行一个拷贝产生一个副本，所有的读写操作都是在副本上进行完成的。所以产生一个副本的话，自然内存是会加倍的。","categories":[],"tags":[]},{"title":"网络游戏架构设计","slug":"网络游戏架构设计","date":"2023-03-17T06:07:03.000Z","updated":"2023-08-01T02:38:37.720Z","comments":true,"path":"2023/03/17/网络游戏架构设计/","link":"","permalink":"http://ysich.github.io/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"网络游戏架构设计第一节 代码结构项目代码结构需要满足的需求热更新需要把Unity的MonoBehaviour等等这些和Unity交互较深的脚本进行分离 至少有一个热更新的程序集 数据跟方法分离，热重载热重载​ 热重载只是数据跟方法分离后得到的好处 ​ 热重载便于改bug，节省重现环节。 数据跟方法分离​ 在C语言中叫做data + function的设计。数据就是定义数据结构，方法则是面向过程的方法。 ​ 相比于面向对象而已没有类与类之间的关联，只有方法和方法的关联，便于重构。 逻辑跟表现分离数据是同步的，而表现可能是异步的情况。在表现过程中可能会有一些资源加载的操作，在这个过程中逻辑发生了变化，表现也需要发生变化。 预表现。表现层可能提前做出一些表现比如一些战斗前摇，但是对逻辑层没有什么影响。等逻辑层同步了命中逻辑后，再播放命中的表现。 在MMO的切换场景中，服务器通知场景切换后，客户端逻辑层加载数据，表现层则在数据加载完成后开始异步加载场景。服务器再通知单位模型的数据后，客户端逻辑层整理数据后，表现成开始异步加载单位模型。 帧同步。帧同步两端的逻辑层的逻辑是一样的。而状态同步逻辑在服务端，两端的逻辑层实际上也是一样的。区别只在于一个是客户端计算一个是服务端计算。 帧同步如果把逻辑层看做是一个服务端，看起来就像是逻辑层在给表现层发消息。逻辑是离散的，表现是要做插值的。 ECS数据驱动数据变化是通过事件通知的。逻辑和表现监听事件产生变化。 ET版本变更1.0客户端 Hoxfix 热更层 Main 主工程 服务端 Hoxfix 纯逻辑 Main 纯数据 中间版本客户端 asmdef功能，多个程序集提升编译速度 Hoxfix 热更层 Loader 游戏入口，可放Unity脚本 Core 框架核心 ThirdParty 第三方库 服务端 Hoxfix Model Loader Core ThirdParty 热重载需求客户端 Hoxfix 热更层的逻辑层 纯逻辑改变时不用关闭游戏，直接重载这个程序集 Model 热更层的数据层 Loader 游戏入口，可放Unity脚本 Core 框架核心 ThirdParty 第三方库 另一种划分 HoxfixView 表现层 Hoxfix 逻辑层 抛事件通知表现层 Loader ThridParty Core 结合前面两个版本客户端 HoxfixView 表现层的方法 ModelView 表现层数据结构 Hofix 逻辑层方法 Model 逻辑层数据 Loader Core ThridParty 前四个程序集编译在一起做热更新。HofixView和Hofix编译在一起做热重载。 并且逻辑和表现分离 Robot Hofix 逻辑层方法 Model 逻辑层数据 Loader Core ThridParty 去掉客户端的表现层，就是机器人的程序集了。 Hofix和Model共用客户端的程序集。 第二节 All In One各类服务器进程合并 很多多进程的设计，都把一个服务整理成一个exe。多个服务就有多个exe，代码可能是高度相似的，或者基本一样的。只是启动时环境变量不同。合并成一个exe并设置环境变量。 发布部署简单、配置资源方便、多种服务共用进程。 结构调整容易，比如两种或多种服务要合并，拆分 多个exe会有多个进程，当其中一部分逻辑压力过大时（比如一个中心服有好友和组队功能，好友功能压力过大时 ）不好拆分，需要再拆成多个exe。 无限增加app类型，千古风流有几十种SceneType 根据配置需要什么服务，就配置什么类型。多个服务配置在一个进程内。 后端和机器人合并 机器人和服务器的代码基本一样。也引用了大部分的后端代码。还引用了客户端的逻辑代码。代码引用很乱。 机器人要单独起一个exe很不方便，跑测试需要起两个进程。 server和机器人合并带来的问题 代码类重名 合并后分别引用了客户端和服务端的代码。两端代码的类名重名（item、buff）。 用命名空间隔离解决重名冲突，带来的好处只需要检查目录下的命名空间就能保证不会调用到错误的代码。 ET.Server、ET.Client 事件订阅怎么区分前后端 有些工具类，或数值组件这种两端共用的代码就不用隔离。ET 比如单位组件，前后端都有抛出的事件很难做区分。需要区分订阅。 通过场景类型做区分SceneType 配置文件结构不同怎么共享 问题也不大，大不了两端配置都存在。 机器人在写组队逻辑时很有用。 前端跟后端合并 不需要单独起服务端，前后端代码共享更方便不需要单独启动服务器，unity一启动就启动前后端代码。 前后端代码的共享，前端可以包含一个服务器，后端可以包含前端的逻辑做个机器人。 后端可以更方便做Unity可视化工具，可视化树ENABLE_VIEW后端如果是命令行程序，做数据可视化很困难。 写后端就像写前端一样简单，比如写个行为树，后端可以直接调试，前端可以直接拿到后端数据。 ET7加上ENABLE_VIEW宏开启可视化树 更方便做插件机制用unity的导入导出做插件机制。 各种游戏代码合并的需求分析竞技游戏比如守望先锋，用的状态帧同步。本地先预测下一帧行为，服务器同步下来如果结果不符合则进行回滚。那么两端肯定有相同代码，否则产生结果肯定是不一致的。 MMO游戏、MOBA游戏模拟机器人的需求，充当普通玩家。 机器人压测需求。 状态同步客户端预测和服务器权威数据跑的代码基本一致。 帧同步逻辑都在客户端，但是在结算结果的时候数据不权威。后期帧同步，很多是依靠服务器也跑一份逻辑，根据跑出来的结果判定结算。也是防作弊很重要的内容。 前端和后端合并的细节问题怎么区分编译前端代码跟后端代码，还有双端编译搞一个编译工具，按照需求选择编译 配置要区分前端跟后端，以及双端，configpatial的处理有些配置不需要双端都知道的，比如前端的特效，或后端比较权威计算的数值。 这就需要导出三份配置。C、CS、S config patial就是把配置反序列化成需要的类对象的工具 config patial不能共享，需要写三份。 消息要区分前后端，以及双端。 总结 把服务器逻辑代码也写在客户端程序集内，直接引用。 第三节 单间管理器为什么需要单间管理器？统一管理单间类。单间类的问题？单间类生命周期的问题，创建了什么时候释放的问题。 内存随着生命周期清理的问题。 统一管理基础库，灵活引入基础库消除静态字段static Dictionary这种静态变量，生命周期清理的问题。 Unity domain模式domain模式为了提升性能不清理静态字段，需要自己清理。 为什么不用组件？组件本身需要一些额外的东西，比如创建的时候需要对象池。对象池又是谁管理。就可以使用单间管理器创建对象池。 为什么用Game.AddSingleton 创建单间Game.AddSingleton&lt;TimeInfo&gt;(); 代码可读性，明确知道单间初始化的地方。如果都是Instance很难找到哪里是初始化的地方。 明确知道初始化顺序，方便调整好释放，相反的顺序释放明确知道了初始化顺序，能更明确释放的顺序。 123456789public interface ISingleton: IDisposable{ void Register(); void Destroy(); bool IsDisposed();}public class Singleton&lt;T&gt;: ISingleton where T: Singleton&lt;T&gt;, new(){} 通过接口创建生命周期ISingletonAwake 、ISingletonUpdate 、ISingletonLateUpdate AddSingleton时判断是否有生命周期接口，如果有添加对应生命周期。 1234567891011121314151617181920212223242526272829public static void AddSingleton(ISingleton singleton){ Type singletonType = singleton.GetType(); if (singletonTypes.ContainsKey(singletonType)) { throw new Exception($\"already exist singleton: {singletonType.Name}\"); } singletonTypes.Add(singletonType, singleton); //管理单间加载顺序，做卸载时可用 singletons.Push(singleton); singleton.Register(); if (singleton is ISingletonAwake awake) { awake.Awake(); } if (singleton is ISingletonUpdate) { updates.Enqueue(singleton); } if (singleton is ISingletonLateUpdate) { lateUpdates.Enqueue(singleton); }} 第四节 多线程、单线程、Task await async的关系多线程使用多线程去执行复杂逻辑时，callback会在执行线程继续执行进行响应。 比如寻路的逻辑比较复杂抛给其他线程去处理，响应回调时也是会在寻路线程进行响应。 遇到的问题当遇到框架内的api都是单线程的api时，必须在主线程完成回调。在其他线程响应回调会导致线程竞争。 解决方法也很简单，在其他线程响应回调时把回调放到一个缓存队列中（需要同步上下文），在主线程的update里不断去取缓存队列中的响应，并去执行它。就能把回调丢回到主线程执行。(C++中的没有task而使用的手法) 详情看看MainThreadSynchronizationContext这个类 Task线程消耗比较大，创建的时候一般都使用线程池。Task就是线程池封装的结果。 Task 执行的线程和响应回调的线程不一致，回调的响应会丢到其他线程执行。 Task本质就是个状态机，当设置了同步上下文时，回调会被自动调整到主线程执行。 编译器帮我们做了这一步 12345678910111213public static async void StartTask(){ SynchronizationContext synchronizationContext = SynchronizationContext.Current; await Task.Run(FindPath); if(synchronizationContext == null){ //没设置同步上下文会在当前线程响应。 SendMessage(); }else{ //设置了同步上下文实际会在设置的线程响应。 synchronizationContext.post(()=&gt;{ SendMessage(); },null); }} 自己实现个TaskRun123456789101112131415 public static async Task Run(Action action) { TaskCompletionSource tcs = new TaskCompletionSource(); ThreadPool.QueueUserWorkItem((_) =&gt; { action.Invoke(); tcs.SetResult(); }); await tcs.Task; }public static async void StartTask(){ await Run(FindPath); //这里把回调和多线程的调用放在同个方法执行 SendMessage();} 使用Task.Factory.StartNew创建可以自由调度的线程 12345public static async void StartTask() { //MyTaskScheduler是自己实现的线程调度器 await Task.Factory.StartNew(FindPath,new CancellationToken(),TaskCreationOptions.None,new MyTaskScheduler()); } 自定义线程调度器继承TaskScheduler实现自己的线程调度器 123456789101112131415161718public class MyTaskScheduler:TaskScheduler { protected override IEnumerable&lt;Task&gt; GetScheduledTasks() { return null; } protected override void QueueTask(Task task) { //执行完回收到线程池 ThreadPool.QueueUserWorkItem((_) =&gt; TryExecuteTask(task)); } protected override bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued) { throw new NotImplementedException(); } } 第五节 ETTask回调地狱 Callback HellTask主要是为了解决回调地狱 在没有协程和await之前，cpp主要靠函数对象模拟Lambda。 后续谷歌推出NewCallback C# 5.0 推出了 await async 关键字 await难以维护的操作while await，await all 所有任务才执行回调。 go python js ts cpp后续也推出了await关键字，但是go的await不完善，是通过线程的方式去执行。比如玩家有的操作是需要单线程等待一段事件再执行的，回调则会执行在其他线程中。而好的设计则应该是只把回调拉直，而不关心你后续实现是在多线程还是单线程。 回调转成TaskTaskCompleteSource 12345678public async ETTask FindPath(){ TaskCompletionSource tcs = TaskCompletionSource(); ThreadPool.QueueUserWorkItem( state=&gt;{ Consle.WriteLine(\"FindPATH\"); tcs.SetResult(); }); await tcs.Task;} CancellationTokenSource await的取消操作 传入token，通过token状态来判断后续代码是否执行。 ETTask的好处生成代码极简，去除了多线程的支持，性能最好。 对象池消除了Task GC TaskCompleteSource和CancellationTokenSource这两个类比较庞大并且没有入池，gc问题比较严重。 去掉了ETVoid ETVoid对应 async void。任何异步都返回ETTask。不需要等待则直接Coroutine。操作简单。 线程取消 超级简单的ETCancelToken ETCancelToken替换CancellationTokenSource 协程取消判断 12345if(cancellationToken.IsCancel()){ Console.WriteLine(\"Start cancel\"); return;}Console.WriteLine(\"Start finish\"); 在ETTask中判断ETCanelToken是否取消然后继续执行后面操作。而Task在取消后则抛出异常。 ETCancelToken取消多个协程 多个ETTask判断同一个ETCancelToken ETCancelToken的必要性 尽可能设计一个await的取消方式，否则后续维护扩展非常困难。 awaitableGetAwaiterc#提供的GetAwaiter的机制，只要对象有一个成员方法或者静态方法名为GetAwaiter，就可以使用await的语法。 Unity yield转换本质上也是回调操作，把yield用await的形式更加简单。 1234567//unity中yield都会返回AsyncOperation的子类public static async ETTask GetAwaiter(this AsyncOperation asyncOperation){ ETTask task = ETTask.Create(true); //SetResult执行后会回到await后的操作。 asyncOperation.completed += _=&gt;{ task.SetResult();}; await task;} 1234567891011public static async ETTask&lt;string&gt; HttpGet(string link){ try{ UnityWedRequest req = UnityWebRequest.Get(link); //req.SendWebRequest()会返回UnityWebRequestAsyncOperation，继承于AsyncOperation await req.SendWebRequest(); return req.downloadHandler.text; } catch{ throw new Exception(); }} 第五节 -2 ETTask源码分析用反编译工具.NET Reflector查看ETTask实现。 这里需要反复看生成概念。 本质上是基于状态机的实现，执行时通过判断ETTaskCompleted的值来判断是否走到后面的逻辑，如果需要等待则将状态机的MoveNext方法传到ETTask的CallBack中。通过状态机的状态变化继续后面的逻辑。 ETTask的SetResult操作会触发回调，执行状态机的MoveNext。 实际上是把await前的代码和await后的操作，各放在一个状态中，通过状态机切换来执行。保证了上下文的统一。 多个await会生成多个状态机 ETTask只要用了ettask.Coroutine()在编译后会生成一个ETAsyncTaskMethodBuilder.Create() ETAsyncTaskMethodBuilderstruct类型，包含一个ETTask。 在方法执行了Coroutine编译后会对应生成一个相对的struct，继承于IAsyncStateMachine。生成一个状态机，根据state参数执行相对应阶段的代码。 ETVoidETAsyncVoidMethodBuilderETTaskCompleted返回完成状态，基本是true ETAsyncTaskCompletedMethodBuilder协程的使用用协程简化工作流程。 int result = await OpenBox();弹窗时返回点击按钮的type做相应的判断，简化在窗口里写逻辑，逻辑上更清晰。(有点像VB的弹窗返回值 await MoveTo(); await ChangeScene(); 切换场景的操作写成一个方法，await后执行切换场景完成后的代码。 await CastSpell(); 释放技能，技能成功或失败后的操作。比如失败时使用道具，成功后捡道具。如果用事件则会变得很复杂。 熊猫哥举了个例子，比如自动寻路时，需要通过几个场景的传送门才能到达最终场景。先把场景选出来，给每个场景写一个最短路径的寻路方法。根据读配置去执行相应的寻路方法。只需要通过一个while循环就能到达最终目标位置。 把逻辑异步化后，逻辑更清晰，只需要对内容进行封装抽象不需要再关心后续的逻辑了。 第六节 计时器TimerComponent 需求场景 UI倒计时 网络超时 技能释放 buff超时删除，定时事件 Task.Delay的问题C#提供的定时器Task.Delay。 跨线程 Task.Delay是跨线程的，会把await的回调放在其他线程执行。 性能 如果需要把回调设置到主线程，就需要设置同步上下文SynchronizationContext synchronizationContext = SynchronizationContext.Current;。把action post到主线程，性能很糟糕 CancleToken抛异常 抛异常的性能问题 不执行后续操作 GC 基于Task实现 有GC 实现代码实现相对时间public async ETTask WaitAsync(long time,ETCancellationToken cancellationToken = null) unix绝对时间public async ETTask WaitTillAsync(long tillTime,ETCancellationToken cancellationToken = null) 相对时间的会跟随帧率 或 线程情况受影响。而绝对时间则是跟随unix时间。在时间达到时，无论什么情况都会执行。 计时器public long NewOnceTimer(long tillTime,int type,object args) 为什么不用callback？ 计时器里可能会有泄露，方便查找泄露。callback没法热重载，基本不用callback。 跟WaitAsync的区别？ 时间长时，用NewOnceTimer，可以热重载。而WaitAsync不能热重载。 数据结构MultMap 管理时间线，在每个时间点插入一个list管理多个计时器。插入list的操作有gc，用对象池创建的话会有回收问题，一直创建池子只会越来越大，在切换场景的时候回收。 Remove细节，只从timerActions中删除。不删除MultMap 管理的计时器，MultMap管理的List插入删除都会影响性能。时间到了从MultMap 取出执行时，判断是否在timerActions中，如果在再执行。 WaitAsync ETCancellationToken怎么判断去取消。 第七节 协程锁CoroutineLockComponent 使用场景 协程并发造成协程竞争，类比于线程竞争 unity资源加载 同时异步加载同一个资源会报错 如果打标记后续逻辑比较不好扩展，比如要做await操作。 加载mail数据 不同服务器玩家数据的竞争 unit消息队列，上线下线 玩家下线了，但是有些异步操作还没完成。 数据库查询保存队列，防止并发过多 mongodb数据的并发数量是有限的。 用了协程锁后，协程则是并列进行。 死锁协程锁中再次获得同一把锁 A B互相等待想象不到的死锁 两条没有关联的消息正好在同一时间请求，请求的内容都需要用到同一把锁。就造成了死锁。 这种情况比较罕见，要么改成请求锁的地方统一通过转发形式。要么干脆直接不处理了。 协程队列实现CoroutineLockComponent 协程锁划分类型 不同类型的锁没必要等，比如资源和数据。 同一个类型，再根据id划分协程锁队列。 同一个类型，并且id相同则在同一个队列中，并列执行。 CoroutineLockQueueType CoroutineLockQueue 对象池 问题为什么不用池？不用struct？ 超时实现 第八节 协程同步三件套ETTask、协程锁、WaitAll 在使用waitAll时需要考虑是否能并发，是否需要并发。 ETTaskHelper.WaitAll 使用场景资源加载并发ResourceComponent实现了并发加载资源 机器人登录并发 每个流程都可以实现并发 WaitAll实现线程同步barrier可以参考barrier 主协程要阻塞住 主协程wait 所有子协程执行完，要通知主协程往下执行 子协程执行完有个回调，至少有个setResult的操作 用计数形式，每执行完一个子协程，count-1，count=0时表示子协程都执行完毕。 主协程在所有子协程都执行完后才开始执行，就需要判断。 在主协程开始时，判断计数是否为0，为0时直接执行。不为0时创建个ETTask等待。 Cancel的判断 WaitAll取消的操作 WaitAny有任一一个协程执行完则返回。 实现计数设置为1，执行完一个-1，count&lt;=0返回 第九节 ID、TimeInfo、ObjectPoolID对应类IdGenerater ID跟InstanceIDID是逻辑上的，InstanceID是对象的ID可以重复，管理器管理，而InstanceID是全局唯一的为什么需要InstanceID？InstanceID表示对象的唯一性对象可能会被释放或者清除，通过InstanceID判断对象是否存在 InstanceID有位置信息InstanceID拥有时间、进程号 InstanceID能方便区分对象进入对象池再被使用在await等待时当持有的unit可能在某个操作被对象池回收，后再被创建。持有的unit已经变成了新的unit造成逻辑错误。 InstanceID被池回收后再创建，InstanceID发生变化。在await操作时判断前后InstanceID是否一致。 ID的构成long类型 64位 Time 30bit 34年 不用从1970开始，可以从项目发布时间开始，还能用34年 Process进程号 18bit 1024*256 一个区大概使用256个进程(根据游戏类型调整)，可以支持1024个区 自增 16bit 65535 当一秒内的自增id超过范围时，借用下一秒的 UnitID构成 Time 30bit 34年 Zone 10bit 1024个区 跨服用 当出现跨服活动时，很方便的通过zone来做区分 ProcessMode 8bit Process % 256 自增 16bit 65535 InstanceID构成 Time 28bit 当年开始的tick 生命周期比较短，不需要那么长的 time Process进程号 18bit 1024*256 一个区大概使用256个进程(根据游戏类型调整)，可以支持1024个区 自增 18bit 65535 *4 数量比较多，增加自增率 TimeInfo对应类TimeInfo Unix Time 自1970年1月1日以来的毫秒 ServerMinusClientTime 服务器时间 - 客户端时间得到的时间差。在 ping的过程中获取。 客户端时间 + 与服务器的时间差 = 服务器时间 ServerTime、ClientTime 对于服务器而言，ServerTime和ClientTime是一样的，对服务器而言不需要考虑客户端时间。 对客户端而言，ServerTime就是 客户端时间 加上 与服务器的时间差获得的。 性能优化 在ClientNow中 计算时间用到Ticks，Ticks的操作非常耗时。 ObjectPoolmono的垃圾回收很垃圾。 在异步代码里，处处使用对象池很有问题。在每个操作都要判断是不是新的对象，漏了一个就有很大的问题。 有些对象池有定时回收的功能，这个功能的缺陷在于，在某一帧可能会回收大量对象，加深了那一帧的时间。 ET的设计则是将对象池设置个最大容量，超过最大容量时则不入池，避免内存占用过大。 在一些场景切换中也可以对对象池进行清理，避免没有意义的内存占用。 第十节 配置Excel、NLog、OptionsOptionOptions Options类 示例 长名 短名 Required Default HelperText OptionAttribute Required 为false时不强制要求带参数 序列化 反序列化 序列化和反序列称unix和linux命令行风格的字符串 起服命令参数 option一般用于服务器启动，起服命令参数一般用于创建进程的配置信息。 GM指令参数，手动解析？ GM指令如果是命令行最好使用option的形式来配置。optin提供静态检查，不容易出错。 Log Logger单间类 ILog接口，策略模式 策略模式，客户端使用UnityLogger，服务端用NLogger LogLevel 提供Log等级，来按照等级进行输出。开发模式，测试模式和线上模式 Conditional 当有些日志需要进行拼接的操作时，拼接消耗性能，就给个宏定义判断。 通过打标签的形式对指定 Log函数进行标记，等有了宏定义之后才生效。 一个函数可以定义多个宏 .NET的新特性，可以使用DefalutInterpolatedStringHandler来减少字符串拼接带来的GC LogTrace 当需要查看日志的堆栈时可以用LogTrace，函数内会创建个堆栈。这里可以看看堆栈的逻辑。 NLog配置对应config里的参数 Variables 通过变量修改Config里的配置，来达到指定参数的日志输出 LogManager.Configuration.Variables rules targets async、buffersize Excel StartConfig 启动时通过命令行选择加载指定的配置 C S # patial 有些配置，不方便填类型比如 ip地址等等 通过patial扩展想要的类型，通过proto反序列化时赋值。 KV 通过key value的形式配置buff 配置用时再加载节省内存 懒加载减少同时加载造成的cpu过载 第十一节 Why not 继承，多态，组合？成员继承的问题类层级调整复杂、耦合，一个变化回影响很多子类​ 当层级变多了后，插入一个新的对旧的逻辑都都会有影响 继承成员随意组合问题接口 + 组合？组合优于继承？​ 每个类都继承了接口的话，都需要额外实现。 ​ 缺乏动态性。当有一个功能，当前不开放但是之后开放。如果是接口，代码实现则需要预先实现，是否开放变成了时机的问题。浪费空间 ​ 特殊性影响了普遍性，可能并不是所有成员都拥有的功能，则需要给每个成员都添加对应的逻辑。 ​ 临时接口跟成员数量极多。比如各种种类的buff。 ​ 成员容易随意放置，没有规范。 ​ patial分开逻辑？没有解决根本的问题，内存占用巨大。不需要的成员拥有了不需要的字段。 类方法的问题函数跟数据混在一起，重构困难。当需要挪出逻辑时，会有private字段限制，不好挪动。 类和类之间方法互相调用，耦合，重构困难。 静态方法和类方法，界限不清晰。 虚函数问题(多态)行为跟类型绑定，类型数量会爆炸 当一个类拆的不够细时。由于子类做不到任何成员组合，子函数会巨大。 不同类型经常写差不多的方法 综合学习成本极大，打补丁的设计模式太多。 人员要求太高，经常设计不够细致。 如果没有统一标准，代码维护困难。 Unity组件的优点成员自由搭配 成员动态插拔的，内存占用率高。 方法也是动态插拔的，更合理，更不容易出错。 临时数据不会导致信息爆炸，成员，方法 代码可读性高，因为内部实现少都是组合。 Unity组件的缺陷数据跟方法没分离，容易耦合，互相调用。 事件方法基于反射，性能有些损失。 GameObject过于庞大，里面的东西过多，只需要纯逻辑时不需要view。 没有替代多态的解决方案。 组件无法再挂组件，组件无法再有child。 ECS的问题Entity只有一个ID，全是Entity。全是entity找bug起来很复杂 组件是strust，限制太大用起来很难受 非树状结构，不符合对世界的描述，工厂的管理模式。 组件无法再挂组件，过于扁平，组件无法再有child 第十二节 实体组件系统Entity Component SystemAddComponet、RemoveComponet、生命周期等等接口名与生命周期都和Unity保持一致。 Entity和Component合并。原因？区别？Entity和Component很类似，功能开发时逻辑很容易互相嵌套，不容易区分。只有Entity能挂组件很不灵活，在线上环境中Component需要扩展成Entity很难进行扩展因为数据已经是Component的形式。 数据跟方法完全分离Entity不能继承用组件代替继承，需要什么数据挂在需要的组件。 Entity树状无限嵌套大世界概念，比较容易描述游戏需求。 跟传统ECS的区别传统ECS的System更多是成员的形式。 传统ECS强调组件的筛选 ET组件数据跟方法分离的好处没有耦合，没有设计模式，学习简单，重构简单 热重载容易 多态实现简单，能基于任何字段做逻辑分发 逻辑分发-多态if elseswitchDictionary&lt;int,Action&gt;状态注册，相比switch而言优化了寻找时的复杂度。 问题在于需要手动注册状态，删除时需要手动删除相对而言比较麻烦 ET的分发形式，基于Attribute的自动注册eventsystem Entity树Entity的parent最顶层的Scene没有parent Entity被反序列化出来时是没有parent的 Domain每个Entity都有一个Domain字段，记录在于哪个场景下 在找中间某个节点时，防止写了过多的getParent。 对象生命周期管理的重要性创建对象时，谁去管理释放。谁去管理对象的生命周期。 如果通过单间管理对象的生命周期，又缺少了对单间生命周期的管理。写多了容易遗漏。 通过父级来管理孩子，父级移除时移除自身挂在的child。 UISceneComponet ResourceSceneComponent Timer等等按Scene挂ui，根据Scene的生命周期进行资源回收。 创建时需要想清楚，需要让谁进行管理。 最佳实践不建议把Entity做为另一个Entity的成员，要么作为组件，要么作为Child。 异步代码，容易出现对象消失，引用还在的情况。特别是用了对象池更危险，做分析器禁止 服务端逻辑帧一般不用Update和LateUpdate。服务器的一帧1毫秒，实际上不需要这么频繁，用Update100ms或者定时器来实现。 Entity代码详解Entity内，存放Component以Type为key ，一种Type的Component只能存在一个。 存放AddChild则是以Id为key。 EntityStatus8位的枚举，每一位都记录了一个信息。 SetParentParent{Set方法} 严格限制parent必须要有domain，parent必须在数据树上。 ComponentParent只能通过AddComponent来添加。 Domain根节点的Domain为自己，其他节点的Domain为父节点的Domain 如果是通过反序列化出来的Entity则没有domain，这时候需要递归把children的domain都设置一遍 DB如果Child继承于ComponentDB或者ChildDB，则会加到componentsDB或childrenDB内。表示需要持久化。 第十三节 EventSystemType.GetType在IL2CPP中性能很差 实体组件生命周期相关Awake Update LateUpdate Destory Publish 自定义的抛事件方法类比dll的单项依赖，防止互相依赖模块隔离同步异步异步Publish，等待订阅者完成操作后，发布者才会进行后面逻辑 SceneTypeall in one的设计，用来区分是客户端还是服务端 服务端也能用来做进程间的限制 全局事件(静态事件)动态事件的绑定都有一个绑定的过程，需要额外管理什么时候监听并且什么时候释放。在查看代码时，需要查看监听的绑定调用，会降低可读性。 不需要每个监听类都有一个callback，只有全局的callback。 Invoke相当于回调。取决于怎么去触发回调。 根据id分发。程序启动时把响应方法注册进EventSystem内。 Invoke和Publish的区别Publish抛出去不关心结果不关心订阅者的，Invoke是主动调用(类似函数)需要知道函数真实存在。 Publish区分SceneType，Invoke没有区分 Publish没有分发作用，Invoke带有分发作用 Publish一对多，Invoke一对一 Publish跟Invoke命名不同，Publish命名跟时间点相关，Invoke命名跟使用者相关 TypeSystem每个Type都有一个对应的OneTypeSystems OneTypeSystemsOneTypeSystems中的QueueFlag记录实现了哪些生命周期，ISystemType中的GetInstanceQueueIndex可以获取到 生命周期的Index 当Entity实例化时通过OneTypeSystems取生命周期的Flag Queue按照生命周期的Flag来缓存需要生命周期的组件ID队列，因为组件可能被对象池回收，所以缓存组件ID 第十四节 序列化反序列化使用场景Excel配置文件，编辑器配置文件，大小跟速度都无所谓 网络消息 大小速度很重要 Entity对象，很复杂，需要支持继承等复杂特性 数据库，mongodb 命令行 库的选择Google Protobuf 性能最好，代码生成复杂不容易扩展，容易无gc Protobuf-net 性能较好，代码简洁，使用最广泛。使用反射机制不好定制 MessagePack 性能较好，代码简洁，其他语言使用少 Mongo.Bson 性能较差，功能最强，并且支持Json 选择Protobuf-net跟MongoDB，满足任何需求 Protobuf-net继承为了支持protobuf的格式，需要在父类上打标签表示继承关系 1234567891011[ProtoContract][ProtoInclude(3,typeof(BB))]public class AA{ [ProtoMember(1)] public int a; [ProtoMember(2)] public float3 pos;}public class BB:AA{ public int b;} struct12345RuntimeTypeModel.Default.add(typeof(float3),false).add(\"x\",\"y\",\"z\");AA aa = new AA(){ a =1, pos = new float3(1,2,3)} Mongo BsonMongoDB的C#库，把C#对象序列化成MongoDB可以用的格式，也可以转换成其他格式，并且支持嵌套。 特性 Bsonld 每条数据都需要有一个Bsonld，如果没有赋值会默认给个96位的Id BsonElement private字段需要序列化字段的标签 可以重命名，可以取个别名可以节省空间。序列化反序列速度也能提升 Bsonlgnore public字段不需要序列化的标签 BsonDefaultValue 没有赋值则取默认值 BsonlgnoreIfDefault 如果是默认值则 序列化过程中不进行序列化 子类默认不能反序列化成父类BsonIgnoreExtraElements加上则在反序列化过程中排除多余的字段 每个都加比较麻烦，Mongo Bson提供了默认操作 1234// 自动注册IgnoreExtraElementsConventionPack conventionPack = new ConventionPack { new IgnoreExtraElementsConvention(true) };ConventionRegistry.Register(\"IgnoreExtraElements\", conventionPack, type =&gt; true); StructBsonSerialize注册了结构体后可以反序列化成结构体 BsonDictionaryOptions字典序列化时，默认的key需要为string。因为默认的json库的key是string类型 BsonDictionaryOptions提供了多种字典序列化方式 一般用ArrayOfArray的形式 BsonClassMap.LookupClassMapmongo在序列化时会记录继承关系，反序列化则会成功。 但是如果直接进行反序列化，mongo默认不知道继承关系则会失败。 把每个类型都进行注册BsonClassMap.LookupClassMap(type) 标准json格式MongoHelper.ToJson时可以传入设置，则为标准json格式。 EntityISerializeToEntity ComponentDB ChildrenDB DeserializeSystem 反序列化后执行的System 第十五节 Network-1 socket IP Port bind accept connect 分为阻塞和非阻塞 read 分为阻塞和非阻塞 socket有缓冲区，read需要等缓冲区满了才会进行读取。 write 分为阻塞和非阻塞 socket有缓冲区，write等缓存去满了才会进行write操作 ET的需求一个主线程 一个网络线程网络独立线程后不好做，对客户端而言很难实现0gc的操作不能用对象池，客户端对网络性能的需求没那么高。 对服务端而言，不是复杂场景下单线程网络线程基本满足需求。 单进程有多个监听(accept) all in one序列化跟反序列化在网络线程，减轻主线程压力如果放在主线程序列化和反序列化就会造成，在序列化后发送请求时，网络线程可能还需要等待一段时间后才会真正发送。这个时间片段内主线程又重新发送了相同的请求，如果使用了对象池就会修改到前面请求的数据。因为对象池是单线程的。 ET的设计抽象出NetService来处理主线程跟网络线程通信 抽象出AService来处理监听，管理连接 抽象出AChannel(网络连接)来做消息收发 多个AService注册到NetService 主线程封装NetComponent处理收到的连接，消息，错误 主线程封装Session做主线程消息发送，以及rpc NetServices线程安全队列NetServices主要负责主线程跟网络线程之间的通信 主线程-&gt;网络线程： 创建连接创建Channel 发送消息给Channel发送 网络线程-&gt;主线程: 接收连接创建Session 接收消息回调主线程 网络错误回调 主线程回调函数 acceptCallback readCallback errorCallback Service管理1private readonly ConcurrentDictionary&lt;long, AService&gt; services = new(); 多线程注意事项 除了线程队列，一个成员永远只能一个线程操作 一个方法永远只能跑在一个线程中，如果方法内操作了成员非常危险。 非常清楚每个字段是哪个线程操作的，绝对不能出错 NetOperator，跨线程消息要注意 只通过跨线程的消息做跨线程的处理 只通过双队列进行跨线程的数据传递，通过Update来取出双队列的数据。 12private readonly ConcurrentQueue&lt;NetOperator&gt; netThreadOperators = new ConcurrentQueue&lt;NetOperator&gt;();private readonly ConcurrentQueue&lt;NetOperator&gt; mainThreadOperators = new ConcurrentQueue&lt;NetOperator&gt;(); 第十六节 Network -2TCP特点监听的socket 监听到连接后，会返回读写的socket TODO：看看TService和Tchannel 面向连接的协议，syn ask fin 三次握手 可靠有序 滑动窗口 告诉发送方还能发多少还能接受多少数据，避免一次性发送过多，把缓冲区发爆了 拥塞窗口 发现丢包就控制下发包数量，未确认的包过多时，则会等待确认后再发包。控制发包速度。 一旦发生丢包，发送速度会指数型的下降。但是恢复则是线性的增长。 流 只保证数据会发送到，不保证顺序和完整性。 TCP实现 CPP包装 BindSend EndSend TcpListener TcpClient NetworkSteam c#提供的tcpsocket包装有少量GC SocketAsyncEventArgs 用这个做异步回调，没有gc TService TChannel System.IO.Pipelines 异步回调 TService Listem TChannel Read Write IOCP线程，网络线程windos下的网络异步api是完成端口。异步回调是在IO线程内。 SocketAsyncEventArgs的回调 回调是在另外一个线程，并不是在哪里调用就是在哪个线程。需要扔回网络线程处理 ConcurrentQueue 网络线程处理回调的队列，收到回调时会塞数据到队列中。网络线程Update轮询拿出数据 TArgs 类似于NetOperator，用作线程间的传递 CircularBuffer减少Read和Write的调用 把异步的操作变成同步操作(和缓冲队列同理，写入和读取都是同步的) socket是在内核里的，每次调用socket的代价算是比较大的。 recvBuffer socket写入，应用层取出调用 sendBuffer 应用层写入，socket取出调用 消息格式 PacketParser类解析消息 遇到的问题 堆栈溢出 TChannel.StartSend()内的while循环，之前是用递归写的。递归造成的问题就是调用的层数太多，会造成堆栈溢出 Tcp在linux上占用过多线程， cpu占用过多，不好观察性能 第十七节 Network -3TCP的问题 有连接 内核内，无法定制 不需要断开连接的时候被断开连接 拥塞控制算法 丢包重传算法 ICMP TCP层发送的数据无法到达时，IP层会进行通知 上层无法控制 容易破解 容易创建中间连接，中间连接容易破解数据 内核，不好定制 UDP 无连接 不可靠 无序 KCP 应用层连接 可靠有序 模拟tcp 数据冗余，降低丢包影响 拥塞控制 好定制 http3.0 ET KCP改进 KCP默认连接端才有conn，ET双端都有conn PS：conn连接号 默认客户端只能一个socket一个连接，ET一个socket可以发起多个连接 因为双端都有conn带来的好处 ikcp_input修改 客户端和服务端各有各的连接号，需要删除连接号的判断条件 KCP改造 Flag标识这条消息的类型，连接消息、断开消息、确认消息等等 TService.Recv() SYN accept ACK connect返回 一旦连接成功开始发送缓冲队列里的包 FIN 连接断开 MSG 包体信息 Conn一条消息会带自己的连接号和对面的连接号，保证无法被攻击。第三方无法读到这两个连接号。每条消息回来都会进行校验。 Content消息的内容 KCP握手 连接方发送握手请求，发送自己的LocalConn。被连接方，收到请求后创建自己的LocalConn并且记录RemoteConn(对方的连接号) ack回复，带上双方的Conn。连接方校验自己的连接号后创建连接 ack也可能会丢包，连接方会重复发送syn请求连接 为什么少了一次连接方的ack？因为等被连接方发送第一条msg就能表示连接成功 KCP收消息流程 kcp libc编写的Kcp库，收到的消息会丢到kcp库执行 可能会做排序、可靠性检查等操作(与TCP类似) KcpInput 接受到消息后输入到kcp lib库内执行 排序、检查等操作 KcpPeeksize 扔进库后，马上查询kcp lib有没有拼装出完整的包，如果有完整包则读取到应用层 KcpRecv 应用层 通过 kcp lib中返回的数据包，在通过kcp lib读取消息 KCP发消息流程 KcpWaitSend 发送之前的检查，可能网络问题不断重试。或者等待消息超过上限，可能判断连接超时有断开连接的操作。 KcpSend 发送检查正常时则把需要发送的数据写入到kcp lib中。 kcp lib会把数据拆分成多个片段，判断大小根据设置走。有些路由限制了udp包的大小，超过500字节的到不了，所以et kcp外网每个udp消息限制是470大小。 KcpSetOutPut 应用层通过KcpOutPut设置好回调，将回调设置到kcp lib库中。 KcpOutPut用udp协议，回调设置好通过upd发送到kcp lib中。 回调包含一些 发送状态的信息 KService KChannelSocketKService内有一个Socket，用来收发udp消息。 同步读socket消息时判断Socket.Available&gt;0。当缓冲队列数据量&gt;0时才进行真正读取，虽然是同步的但是不会造成阻塞。 PS:如果当前使用的是非阻止 Socket，一种较好的做法是在调用 Receive 之前使用 Available 来确定数据是否排队等待读取。可用的数据即网络缓冲区中排队等待读取的全部数据。如果在网络缓冲区中没有排队的数据，则 Available 返回 0。 KService计时器独立的计时器，因为是在网络线程 InitKcp具体参数需要结合文档 KCP Basic Usage · skywind3000/kcp Wiki (github.com) 123456789101112131415161718192021private void InitKcp(){ switch (this.Service.ServiceType) { case ServiceType.Inner: this.kcp.SetNoDelay(1, 10, 2, true); this.kcp.SetWindowSize(1024, 1024); //分片包大小 this.kcp.SetMtu(1400); // 默认1400 this.kcp.SetMinrto(30); this.kcp.InitArrayPool(1600, 10000); break; case ServiceType.Outer: this.kcp.SetNoDelay(1, 10, 2, true); this.kcp.SetWindowSize(256, 256); this.kcp.SetMtu(470); this.kcp.SetMinrto(30); this.kcp.InitArrayPool(600, 10000); break; }} 大包的实现超过大包设置的限定值时，进行分片处理 发送端1234567891011121314151617// 先发分片信息// 头部信息，和普通消息做区分，前4个字节是0则代表是分片的包。this.sendCache.WriteTo(0, 0);// 5-8字节 包体大小this.sendCache.WriteTo(4, count);this.kcp.Send(this.sendCache.AsSpan(0, 8));// 分片发送int alreadySendCount = 0;while (alreadySendCount &lt; count){ int leftCount = count - alreadySendCount; int sendCount = leftCount &lt; AService.MaxCacheBufferSize? leftCount: AService.MaxCacheBufferSize; this.kcp.Send(memoryStream.GetBuffer().AsSpan((int)memoryStream.Position + alreadySendCount, sendCount)); alreadySendCount += sendCount;} 接收端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364while (true){ //...一堆判断条件这里省略 if (this.needReadSplitCount &gt; 0) // 说明消息分片了 { byte[] buffer = readMemory.GetBuffer(); int count = this.kcp.Receive(buffer.AsSpan((int)(this.readMemory.Length - this.needReadSplitCount), n)); this.needReadSplitCount -= count; if (n != count) { Log.Error($\"kchannel read error1: {this.LocalConn} {this.RemoteConn}\"); this.OnError(ErrorCore.ERR_KcpReadNotSame); return; } if (this.needReadSplitCount &lt; 0) { Log.Error($\"kchannel read error2: {this.LocalConn} {this.RemoteConn}\"); this.OnError(ErrorCore.ERR_KcpSplitError); return; } // 没有读完 if (this.needReadSplitCount != 0) { continue; } } else { this.readMemory = this.Service.Fetch(n); this.readMemory.SetLength(n); this.readMemory.Seek(0, SeekOrigin.Begin); byte[] buffer = readMemory.GetBuffer(); int count = this.kcp.Receive(buffer.AsSpan(0, n)); if (n != count) { break; } // 如果是8字节代表有可能是分片包 if (n == 8) { // 如果前4个字节是0则代表是分片包 int headInt = BitConverter.ToInt32(this.readMemory.GetBuffer(), 0); if (headInt == 0) { this.needReadSplitCount = BitConverter.ToInt32(readMemory.GetBuffer(), 4); if (this.needReadSplitCount &lt;= AService.MaxCacheBufferSize) { Log.Error($\"kchannel read error3: {this.needReadSplitCount} {this.LocalConn} {this.RemoteConn}\"); this.OnError(ErrorCore.ERR_KcpSplitCountError); return; } //打包的长度 this.readMemory.SetLength(this.needReadSplitCount); this.readMemory.Seek(0, SeekOrigin.Begin); continue; } } }} 代码实现细节设置缓冲区一个socket对应多条回调的连接监听，缓存区太小容易爆掉 OSX平台无效 12345if (!RuntimeInformation.IsOSPlatform(OSPlatform.OSX)){ this.Socket.SendBufferSize = Kcp.OneM * 64; this.Socket.ReceiveBufferSize = Kcp.OneM * 64;} 发送时的RemoteConn设置12345678910111213141516171819202122232425public void Output(byte[] bytes, int count){ if (this.IsDisposed) { return; } try { // 没连接上 kcp不往外发消息, 其实本来没连接上不会调用update，这里只是做一层保护 if (!this.IsConnected) { return; } if (count == 0) { Log.Error($\"output 0\"); return; } bytes.WriteTo(0, KcpProtocalType.MSG); // 每个消息头部写下该channel的id; bytes.WriteTo(1, this.LocalConn); //这里只写入了LocalConn没有写入RemoteConn，是因为输入的bytes就带了RemoteConn this.Service.Socket.SendTo(bytes, 0, count + 5, SocketFlags.None, this.RemoteAddress); } SetSioUdpConnReset只在window平台存在的问题。设置屏蔽 a向b发送upd的包，a如果关闭了socket会通知b也需要关闭socket KChannel连接没连接成功前300毫秒发送一次请求连接。 12345678910111213141516171819202122232425262728293031323334353637383940private void Connect(uint timeNow){ try { if (this.IsConnected) { return; } // 300毫秒后再次update发送connect请求 if (timeNow &lt; this.lastConnectTime + 300) { //加到Service的updateChannel里做轮询连接 this.Service.AddToUpdate(300, this.Id); return; } // 10秒连接超时 if (timeNow &gt; this.CreateTime + KService.ConnectTimeoutTime) { Log.Error($\"kChannel connect timeout: {this.Id} {this.RemoteConn} {timeNow} {this.CreateTime} {this.ChannelType} {this.RemoteAddress}\"); this.OnError(ErrorCore.ERR_KcpConnectTimeout); return; } byte[] buffer = sendCache; buffer.WriteTo(0, KcpProtocalType.SYN); buffer.WriteTo(1, this.LocalConn); buffer.WriteTo(5, this.RemoteConn); this.Service.Socket.SendTo(buffer, 0, 9, SocketFlags.None, this.RemoteAddress); // 这里很奇怪 调用socket.LocalEndPoint会动到this.RemoteAddressNonAlloc里面的temp，这里就不仔细研究了 Log.Info($\"kchannel connect {this.LocalConn} {this.RemoteConn} {this.RealAddress}\"); this.lastConnectTime = timeNow; this.Service.AddToUpdate(300, this.Id); } catch (Exception e) { Log.Error(e); this.OnError(ErrorCore.ERR_SocketCantSend); }} 第十八节 Network -4NetworkComponent 处理收消息，接收连接，错误等回调 NetClientComponent NetServerComponent NetInnerComponent 内部进程通信 管理主动的连接跟accept的连接 Session 发消息 rpc 配合主线程网络的组件OpcodeTypeComponent 记录外网消息 记录Request跟Response配对 MessageDispatcherComponent协议消息的分发 根据Opcode管理具体的事件队列 1public readonly Dictionary&lt;ushort, List&lt;MessageDispatcherInfo&gt;&gt; Handlers = new(); 1234567891011public class MessageDispatcherInfo{ public SceneType SceneType { get; } public IMHandler IMHandler { get; } public MessageDispatcherInfo(SceneType sceneType, IMHandler imHandler) { this.SceneType = sceneType; this.IMHandler = imHandler; }} 程序启动时，根据Handler标签进行注册绑定。 Handler划分 AMHandler 正常调用，没有返回值 AMRpcHandler Rpc调用会创建Response返回并发送给对面 SessionAcceptTimeoutComponent连接长时间占用消耗资源 SessionAcceptTimeoutComponent维护连接的时长，持有该组件并且超过限定时间则进行断开连接。 一些外挂会长时间连接只监听消息 PingComponent心跳包组件，与SessionIdleCheckerComponent对应 客户端挂上PingComponent，每固定时间发送消息。保持连接 SessionIdleCheckerComponentSession挂上SessionIdleCheckerComponent，超过时间没收到PingComponent判断为断开 SessionMessageStatisticsComponentET里没有这个组件 记录一段时间内收了多少条客户端消息。判断是否被发起攻击或者写出bug。检测出异常。 第十九节 软路由防止黑客攻击的功能 黑客攻击tcp连接攻击黑客创建很多肉鸡创建很多tcp连接，tcp连接消耗内存会把服务器挤爆。 流量攻击不停发消息，把流量吃满。接受不到正常玩家消息也发送不出去 协议攻击破解协议，发送莫名其妙的东西 Http防攻击 http防攻击是每次http请求都通过cdn进行中介请求，实际上被攻击的会是cdn。一台崩了其他的还是正常运行。 游戏跟http不同 实时性更高 交互性更多 功能之间交互多，不像http可以拆分成各种服务 逻辑更复杂 服务更集中 长连接 大部分游戏服务器的弱点 TCP 只同步协议一样要分配资源 对外地址固定 对外的地址是公布的，容易暴漏地址 协议过于简单 大部分黑客的特点 流量不多 流量大不会攻击小游戏 攻击单个地址 成本问题 比较少进行协议破解攻击 技术含量比较高 针对性解决 使用UDP 多个对外地址 提高协议复杂性，提高破解难度 防攻击目标 服务器不能受影响 保持连接，不能让在线的玩家掉线 在线玩家无感 软路由方案，增加类似CDN的东西 软路由设计 使用UDP+KCP tcp可以吗？ 软路由如果与客户端用TCP连接，那攻击软路由一样会挂掉 主要利用KCP的有序可靠性 一个软路由被攻击，玩家客户端可以切换其它软路由转发 客户端发现卡顿时，超过限定时间会切换路由，重新请求连接。gate发现ReConnect请求后会变更软路由的地址连接。 在切换软路由过程中，网关怎么知道发送给软路由的包没真正到达客户端？ KCP的消息需要确认，收到会发确认包，没收到确认包则会重发。客户端如果收到两条相同的包也会剔除相同的。(KCP底层实现) 随时增加减少软路由进程 获取软路由服务，使用cdn保护 软路由的地址通过cdn或缺 RouterComponet本质就是校验安全性并且转发的过程 包含一个内网地址和一个外网地址 12345//正在连接，握手的节点public Dictionary&lt;uint, RouterNode&gt; ConnectIdNodes = new Dictionary&lt;uint, RouterNode&gt;();// 已经连接成功的，虽然跟id一样，但是没有经过验证的不会加到这里public Dictionary&lt;uint, RouterNode&gt; OuterNodes = new Dictionary&lt;uint, RouterNode&gt;(); 1234567891011121314//update轮询查询，内网和外网的监听protected override void Update(RouterComponent self){ long timeNow = TimeHelper.ClientNow(); self.RecvOuter(timeNow); self.RecvInner(timeNow); // 每秒钟检查一次 if (timeNow - self.LastCheckTime &gt; 1000) { self.CheckConnectTimeout(timeNow); self.LastCheckTime = timeNow; }} 连接与kcp连接不同的是需要告诉路由要连接的地址 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081case KcpProtocalType.RouterReconnectSYN:{ if (messageLength &lt; 13) { break; } uint outerConn = BitConverter.ToUInt32(self.Cache, 1); uint innerConn = BitConverter.ToUInt32(self.Cache, 5); //要连接路由的地址，后续不需要发送 uint connectId = BitConverter.ToUInt32(self.Cache, 9); string realAddress = self.Cache.ToStr(13, messageLength - 13); RouterNode routerNode; // RouterAck之后ConnectIdNodes会删除，加入到OuterNodes中来 if (!self.OuterNodes.TryGetValue(outerConn, out routerNode)) { self.ConnectIdNodes.TryGetValue(connectId, out routerNode); if (routerNode == null) { Log.Info($\"router create reconnect: {self.IPEndPoint} {realAddress} {connectId} {outerConn} {innerConn}\"); routerNode = self.New(realAddress, connectId, outerConn, innerConn, self.CloneAddress()); // self.OuterNodes 这里不能add，因为还没验证完成,要在RouterAck中加入 } } if (routerNode.ConnectId != connectId) { Log.Warning($\"kcp router router reconnect connectId diff1: {routerNode.SyncIpEndPoint} {(IPEndPoint) self.IPEndPoint}\"); break; } // 不是自己的，outerConn冲突, 直接break,也就是说这个软路由上有个跟自己outerConn冲突的连接，就不能连接了 // 这个路由连接不上，客户端会换个软路由，所以没关系 if (routerNode.InnerConn != innerConn) { Log.Warning($\"kcp router router reconnect inner conn diff1: {routerNode.SyncIpEndPoint} {(IPEndPoint) self.IPEndPoint}\"); break; } if (routerNode.OuterConn != outerConn) { Log.Warning($\"kcp router router reconnect outer conn diff1: {routerNode.SyncIpEndPoint} {(IPEndPoint) self.IPEndPoint}\"); break; } // 校验ip，连接过程中ip不能变化 if (!Equals(routerNode.SyncIpEndPoint, self.IPEndPoint)) { Log.Warning($\"kcp router syn ip is diff1: {routerNode.SyncIpEndPoint} {(IPEndPoint) self.IPEndPoint}\"); break; } // 校验内网地址 if (routerNode.InnerAddress != realAddress) { Log.Warning($\"router sync error2: {routerNode.OuterConn} {routerNode.InnerAddress} {outerConn} {realAddress}\"); break; } //大于40条连接请求则判断为是异常连接 if (++routerNode.RouterSyncCount &gt; 40) { self.OnError(routerNode.Id, ErrorCore.ERR_KcpRouterRouterSyncCountTooMuchTimes); break; } // 转发到内网 self.Cache.WriteTo(0, KcpProtocalType.RouterReconnectSYN); self.Cache.WriteTo(1, outerConn); self.Cache.WriteTo(5, innerConn); self.Cache.WriteTo(9, connectId); self.InnerSocket.SendTo(self.Cache, 0, 13, SocketFlags.None, routerNode.InnerIpEndPoint); if (!routerNode.CheckOuterCount(timeNow)) { self.OnError(routerNode.Id, ErrorCore.ERR_KcpRouterTooManyPackets); } break;} 路由重连路由繁忙重新选择路由时，软路由转发给网关，网关会进行remoteConn和localConn的校验，判断只有是链接过的没有造假。并且ip地址不能变化。 1KcpProtocalType.RouterReconnectSYN KService的网关校验 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556case KcpProtocalType.RouterReconnectSYN:{ // 长度!=5，不是RouterReconnectSYN消息 if (messageLength != 13) { break; } string realAddress = null; remoteConn = BitConverter.ToUInt32(this.cache, 1); localConn = BitConverter.ToUInt32(this.cache, 5); uint connectId = BitConverter.ToUInt32(this.cache, 9); this.localConnChannels.TryGetValue(localConn, out kChannel); if (kChannel == null) { Log.Warning($\"kchannel reconnect not found channel: {localConn} {remoteConn} {realAddress}\"); break; } // 这里必须校验localConn，客户端重连，localConn一定是一样的 if (localConn != kChannel.LocalConn) { Log.Warning($\"kchannel reconnect localconn error: {localConn} {remoteConn} {realAddress} {kChannel.LocalConn}\"); break; } if (remoteConn != kChannel.RemoteConn) { Log.Warning($\"kchannel reconnect remoteconn error: {localConn} {remoteConn} {realAddress} {kChannel.RemoteConn}\"); break; } // 重连的时候router地址变化, 这个不能放到msg中，必须经过严格的验证才能切换 if (!Equals(kChannel.RemoteAddress, this.ipEndPoint)) { kChannel.RemoteAddress = this.CloneAddress(); } try { byte[] buffer = this.cache; buffer.WriteTo(0, KcpProtocalType.RouterReconnectACK); buffer.WriteTo(1, kChannel.LocalConn); buffer.WriteTo(5, kChannel.RemoteConn); buffer.WriteTo(9, connectId); this.socket.SendTo(buffer, 0, 13, SocketFlags.None, this.ipEndPoint); } catch (Exception e) { Log.Error(e); kChannel.OnError(ErrorCore.ERR_SocketCantSend); } break;} 客户端登录时的操作RouterAddressComponent登陆时获取软路由列表 localConn为软路由创建并返回客户端，因为如果都由客户端随机也有可能重复。 第二十节 Actor传统意义的多线程写法，需要加各种锁做限制，逻辑复杂后锁容易被遗漏，或者多加了锁造成难以维护，变量膨胀。 why Actor？每个线程都有自己的变量，每个线程都维护自己的变量。当线程需要访问其他线程的变量时，实际是告诉其他线程自己要执行什么操作。 Erlang对Actor的进阶设计如果只对线程进行actor的操作，实际上还是可以访问到其他线程的变量。如果使用不规范还是会造成bug。 不同进程之间进行调度，只需要把需要使用到的进程processid和参数传递到消息通道内，等消息通道执行到时对应进程再从消息通道中取出数据进行执行。 Erlang对Actor抽象出进程的概念，不同进程之间是不共享内存的所以无法直接访问到其他进程的变量，只通过消息通道进行传递。 每个虚拟进程都只会通过一个线程进行调度，进程变量通过一个线程进行访问。 Erlang的虚拟进程使用成本较低，只是数据结构包装成的进程。不需要到内核态进行创建进程，并且能够进行访问地址的有效隔离。 ET Actor 每个进程都有很多个Entity，每个Entity都有一个Id，Id带有进程的信息。发消息的时候只需要知道id就能够进行通信。 ET的Actor进一步的扩展，可以直接通知到进程中的对象上。而Erlang只能通知到进程，进程再一步通知给对象。 实现细节 InstanceId 每个Scene在配置中都有自己的id，在配置AfterEndInit时构造出InstanceId。 StartSceneConfig Scene的InstanceId 服务器所有内部消息发送，gate转发 服务器所有内部信息都用Actor发送 MailboxComponent 三种MailboxType MessageDispatcher:队列处理，后续消息都需要进行等待处理完成。 UnOrderMessageDispatcher:不等待，每次消息收到都新开一个协程处理 GateSession:把SessionId缓存在unit上，当收到消息时直接通过SessionId返回给客户端。 Session可能会断开。需要额外管理 Actor死锁 当两个unit消除处理的mailBox都是队列类型时，当A处理完成后会返回一个rpc消息，当是这时候B又发送了一个消息需要A处理。这时候A在等待B的rpc消息处理，B在等待A的消息处理造成了相互等待。在有队列的maiBox中才会发生。 代码实现 ActorHandleHelper ```c#public static async ETTask HandleIActorRequest(long actorId, IActorRequest iActorRequest){InstanceIdStruct instanceIdStruct = new(actorId);//这里的进程号不是收到的进程号，而是来源的进程号。//因为要response,需要知道从哪个进程来的,回复到哪里取。int fromProcess = instanceIdStruct.Process;instanceIdStruct.Process = Options.Instance.Process;long realActorId = instanceIdStruct.ToLong();Entity entity = Root.Instance.Get(realActorId);if (entity == null){ IActorResponse response = ActorHelper.CreateResponse(iActorRequest, ErrorCore.ERR_NotFoundActor); Reply(fromProcess, response); return;}MailBoxComponent mailBoxComponent = entity.GetComponent();if (mailBoxComponent == null){ Log.Warning($”actor not found mailbox: {entity.GetType().Name} {realActorId} {iActorRequest}”); IActorResponse response = ActorHelper.CreateResponse(iActorRequest, ErrorCore.ERR_NotFoundActor); Reply(fromProcess, response); return;}switch (mailBoxComponent.MailboxType){ case MailboxType.MessageDispatcher: { using (await CoroutineLockComponent.Instance.Wait(CoroutineLockType.Mailbox, realActorId)) { if (entity.InstanceId != realActorId) { IActorResponse response = ActorHelper.CreateResponse(iActorRequest, ErrorCore.ERR_NotFoundActor); Reply(fromProcess, response); break; } await ActorMessageDispatcherComponent.Instance.Handle(entity, fromProcess, iActorRequest); } break; } case MailboxType.UnOrderMessageDispatcher: { await ActorMessageDispatcherComponent.Instance.Handle(entity, fromProcess, iActorRequest); break; } case MailboxType.GateSession: default: throw new Exception($”no mailboxtype: {mailBoxComponent.MailboxType} {iActorRequest}”);}}123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113- ActorHelper- ActorMessageDispatcherComponentSystem- ActorMessageSenderComponentSystem - 有个超时的设计，Awake时启动定时器每秒钟检查requestCallback内有哪些消息还没返回。方便检查性能。- AMActorHandler- AMActorRpcHandler- MailBoxComponentSystem- 为什么用两条Session？ - `ActorMessageSenderComponentSystem.Call()`为什么调用两个Session来传递，而不是直接用单个Session的call方法？ - ![image-20230731115309727](网络游戏架构设计/image-20230731115309727.png) - 如果用call返回，这时候再发消息就会有问题。保证Session的单一职责。## 第二十一节 ActorLocationTODO：这部分有点复杂，客户端用不到先简单看下LocationComponent对Actor基础上的封装，在某些特定场景使用- 比如Unit - InstanceId不固定- 只知道Id，并且想通过Id发消息 - InstanceId不固定，Id是固定的### 设计思路ActorLocation的概念就像是一个`中央管理区`，管理所有人的InstanceId，当Id持有的InstanceId需要变更时需要通知给中央管理区，并且锁住状态。当一个actor需要通知到具体对象时，会派出一个`高级邮递员`向中央管理区请求InstanceId信息，并进行投递。但是在进行投递的过程中，InstanceId还是有可能会变更，`高级邮递员`还是会发生投递失败的情况，这时候就会重新执行这个流程。需要注意的是，如果InstanceId一直在变更`高级邮递员`不可能一直处于投递状态，还是需要给个限定时间。### 回执无论有没有回调都需要有一个回执。- 有内容的回执- 没有内容的回执 - 只告诉发送者接收者收到了消息。### Location作用- zookeeper- 分布式锁服务- 存键值对## 第二十二节 机器人与测试用例### 机器人的作用- 功能开发的辅助- 单元测试- 性能压测- 逻辑压测- 模拟玩家### 共享逻辑代码放在share层，双端可以共享机器人的逻辑代码。#### 宏的处理方式因为是All in one的设计。逻辑层是动态加载出来的，都是编译出来的dll。直接代码里只加客户端的宏就没用了。#### ET的宏处理在`Define.cs`文件中统一管理宏逻辑，通过宏定义来设置变量的值。通过变量的值来获取状态。在逻辑里定义一堆宏反而更麻烦。### 测试用例- 测试驱动 - 传统概念，写逻辑先写测试用例，先让测试用例测试功能 - 但是在游戏中逻辑变化太快，测试用例很容易被推翻。- 函数级单元测试- 类级别单元测试- 协议级的单元测试 - 游戏中的测试用例基本都是面向于协议，因为协议较于稳定。### 写测试用例的技巧- 利用协程 - 用协程，发送协议然后等待协议返回，判断结果。当成同步方法来写。 - 部分协议不是rpc，这时候需要等待其他协议返回时，使用ObjectWait把没有关系的消息进行代码逻辑上的串行。 ```c# namespace ET.Server{ //虽然协议响应的场景是Client但是是Server命名空间下，所以编译成程序集时是在Server内。 //具体协议Handler [MessageHandler(SceneType.Client)] public class xxxHandler:AMHandler&lt;xxx协议&gt;{ protected override async ETTask Run(Session session,xxx协议 message){ ObjectWait objectWait = session.clientScene().GetComponent&lt;ObjectWait&gt;(); objectWait.Notify(new RobotCase_xxx(){}); } } public class RobotCase_xxx:ARobotCase{ protected override async ETTask Run(RobotCase robotCase){ ObjectWait objectWait = robotScene.GetComponent&lt;ObjectWait&gt;(); await objectWait&lt;RobotCase_xxx&gt;(); } } } 利用消息事件回调 不要用时间来卡逻辑 第二十三节 AIAI的用处 怪物、NPC等行为 子弹 机器人 托管 AI常用实现方案 状态机 每两个状态都可能发生转换，复杂度是N的平方 节点与节点之间耦合会很严重 行为树 每个方法都要包装成节点，节点太多 树太大不好编辑 牵一发而动全身，一个变量的调整可能会导致顺序的调整 表达弱，难以阅读，难以重构 协程的支持比较原始，等待的操作会被包装成节点 深度学习 AI的本质根据当前的状态，执行一个行为。 ET改进直接用代码编写AI ​ 复用节点改为复用函数。一个行为由多个函数组成。 协程化，每个节点是一个协程 ​ 在行为内隔一段时间进行条件的判定，当条件满足时打断其他的行为，并执行满足条件的行为。 节点包含条件跟行为 ​ 把行为进行抽象，而不是把状态进行抽象。 第二十四节 架构设计细节 推图游戏 主要就是房间管理的设计，如果有单人和多人的玩法。双端共享代码带来的优势。 多人玩法的代码可以通过服务器请求，房间在服务器上，通过协议驱动view表现。 单人玩法则可以在本地创建一个Scene当作逻辑层模拟服务器房间，驱动view层。 帧同步 状态帧 逻辑层和表现层分离，逻辑层可以优化成单独一个线程运行 可以客户端计算服务器做转发，然后多个客户端投票机制判定结果是否正常。 或者状态同步，客户端发送操作，服务器计算结果并转发 或者只搞结算服，游戏结束把每一帧结果都发送到结算服，判定结果再进行返回。或者改为仲裁机制，有人投诉再进行结果判定。 mmo slg 逻辑都在服务器，客户端只做表现。 在登录时，网关会先从player取出数据，在player上挂载一个map，把unit临时挂在这个map上。然后进入游戏场景时，相当于一个传送的机制。可以减少登录时的逻辑。修改登录获取数据的get方法来实现，还可以减少map上的压力。 一个unit上可能会挂在上百个组件，当创建unit到map时如果一起反序列化上百个组件，退出map时又序列化上百个组件无疑会带来很大的性能负担。而有些组件实际并没有使用到造成性能浪费。 ET对需要序列化的组件做了优化，会存在一个专门管理序列化组件的组件，只有在第一次GetComponent时会进行序列化并且进行标记为需要反序列化。 第二十五节 分析器ET分析器介绍 (yuque.com) HotfixProjectFieldDeclarationAnalyzer Hotfix程序集中只能携带无状态的代码。如果定义了Const变量在热更新时会产生变量参数的变更，造成代码的不稳定。 ClassDeclarationInHotfixAnalyzer 数据结构也不能在Hotfix程序集定义，数据结构的变更也会造成热更新的不稳定性。 EntityMethodDeclarationAnalyzer 实体类禁止声明方法。 EnableMethod开后门可以绕过约束 StaticClassCircularDependencyAnalyzer 静态类之间不能相互调用 静态类之间如果互相调用就会造成依赖 UniqueIdAnalyzer 避免定义的const int变量参数重复 框架定义枚举会有侵入性，上层可能会修改到底层的枚举 EntityDelegateDeclarationAnalyzerEntityDelegateDeclarationAnalyzer 避免声明Action，避免回调写法","categories":[{"name":"框架篇","slug":"框架篇","permalink":"http://ysich.github.io/categories/%E6%A1%86%E6%9E%B6%E7%AF%87/"}],"tags":[{"name":"Manager 框架 ET框架","slug":"Manager-框架-ET框架","permalink":"http://ysich.github.io/tags/Manager-%E6%A1%86%E6%9E%B6-ET%E6%A1%86%E6%9E%B6/"}]},{"title":"关于CallBack","slug":"关于CallBack","date":"2023-01-31T02:36:16.000Z","updated":"2023-07-14T01:49:20.038Z","comments":true,"path":"2023/01/31/关于CallBack/","link":"","permalink":"http://ysich.github.io/2023/01/31/%E5%85%B3%E4%BA%8ECallBack/","excerpt":"","text":"关于CallBackCallback提高cpu利用率不会造成阻塞。做一件事不会等待，等需要时再call back处 应用场景 DMA控制器 cpu做数据复制时会阻塞cpu，cpu 通知硬件进行复制完成后通知回来。不会阻塞整个cpu 网络多路复用 Socket读写过程中，等待数据发送或接收过程cpu的阻塞。等数据过来后再进行通知。 多线程 时间 比如等待5秒后执行一个函数，不需要阻塞线程5秒后再执行。 CallBack历史函数指针C语言内通过函数指针的方式，在callback 后用指针执行函数，但是不方便同步上下文且类型不安全（可以传递任意指针） 函数对象C++通过函数对象的方式，类型安全、构造时传递函数指针、构造时传递上下文、绑定上下文 将上下文和回调函数封装成一个类（闭包），做到延迟调用。闭包比较繁琐，当需要上下文对象类型不满足已有扩展的闭包支持的类型时就要进行 闭包类型的扩展。 谷歌的NewCallBack上下文只能绑定前面的参数不能绑定后面的参数、返回的是指针（本质是new一个函数对象执行）如果没有调用会造成内存泄漏（解决方案：使用智能指针包裹） Callback Hell（回调地狱）在处理回调时，我们的逻辑会被截成两段，一段是发起callback 一段是响应callback 。在Callback调用Callback的过程中，代码相应会像波浪一样越推越远。 易出错、难修改。在callback 中难插入。 async await Task把int Func() (回调) 转成await Func() 在C#中通过转换工具TaskCompletionSource 转换 ETTask 简化的Task 生成代码简单 (.Net Reflector 可以.net stand 2.0反编译) 解决了GC问题 Task 使用TaskCompletionSource工具类转换成await Func 时会new 工具类 ETTask在确保安全的时候使用池消除gc，Set Result (true)时回收 TaskCompletionSource和Task合并 不提供多线程处理 并行ET提供WaitAll WaitAny，类比线程同步barrier 当多个回调同时发起，等所有回调执行完再往下执行 场景： 切换场景资源,不需要一个个加载，可以同时加载，等所有加载完再往下执行。 机器人登录50个，不需要一个个登录。 协程锁应用场景： 两个逻辑同时加载同一个ab包 服务器玩家异步加载处理到一半，这时收到下线消息。 实现： CoroutineComponent实现思路： 同一种锁，同一个key放入同一个队列 一个协程执行完后从自己队列中取出下一个执行 问题: 协程执行取出下一个执行时，如果消息处理不过来会产生队列内的处理逻辑的堆积。队列很多时，堆栈的层级也会很多(因为逐层调用)，导致堆栈爆掉。 改进： 取出下一个执行时，不直接执行而是放入update中执行。 问题： 协程锁死锁情况，await互相等，永远等不到 改进： ET协程锁添加时间限制，时间到了解锁(超时机制)。","categories":[{"name":"框架篇","slug":"框架篇","permalink":"http://ysich.github.io/categories/%E6%A1%86%E6%9E%B6%E7%AF%87/"}],"tags":[{"name":"CallBack","slug":"CallBack","permalink":"http://ysich.github.io/tags/CallBack/"}]},{"title":"ManagerOfManager","slug":"ManagerOfManager","date":"2023-01-17T06:14:51.000Z","updated":"2023-01-17T08:48:13.113Z","comments":true,"path":"2023/01/17/ManagerOfManager/","link":"","permalink":"http://ysich.github.io/2023/01/17/ManagerOfManager/","excerpt":"","text":"框架搭建随笔版本号使⽤版本号命名的⽂件格式为: Framework_vX.Y.Z X 是主版本号，⽤于不向前兼容的更新。 Y 是中间版本，⽤于可向前兼容的功能性更新。 Z 是⼩版本号，⽤于功能完善和 bug 修复的更新 ⼀般都是从 v0.1.1 这个版本开始发布的，但是这个版本呢叫做 mvp 版本，也就是最⼩可验证版本。后续发布版本都需要向前兼容 Obsolete 标签使用Obsolete标签标记方法已弃用，使用其他方法。 添加弃用标签后会报警报提醒 12345[Obsolete(\"方法已过时，请使用xx方法\")]public static void OpenInFolder(string folderPath){ Application.OpenURL(\"file://\" + folderPath);} Partial关键字当类后续可能增长的时候使用，各个部分类需要用相同的访问权限。而且每个部分类都需要加partial关键字。 方法结构重复 解决方案当一个方法的的参数类型不同时，如果有共同父类可以将类型设置为父类，子类可以进行使用 123456789101112public static int GetRandomValueFrom(int[] values){ return values[Random.Range(0, values.Length)];}public static float GetRandomValueFrom(float[] values){ return values[Random.Range(0, values.Length)];}public static string GetRandomValueFrom(string[] values){ return values[Random.Range(0, values.Length)];} 可以将类型设置为object 1234public static object GetRandomValueFrom(object[] values){ return values[Random.Range(0, values.Length)];} 泛型实现结构复用使用泛型实现方法复用 1234public static T GetRandomValueFrom&lt;T&gt;(params T[] values){ return values[Random.Range(0, values.Length)];} params关键字修饰形参必须为一维数组，并且方法声明只能有一个params，如果不是一维数组编译器将报错。 使用 params 参数调用方法时，可以传入： 数组元素类型的参数的逗号分隔列表。 指定类型的参数的数组。 无参数。 如果未发送任何参数，则 params 列表的长度为零。 12345678910//数组元素类型的参数的逗号分隔列表public void Get(){ GetRandomValueFrom&lt;int&gt;(1, 2, 3);}//无参数public void Get(){ GetRandomValueFrom&lt;int&gt;();} 消息机制Unity内置消息机制方法调用使用字符串，可能用到反射，尽量不用。 1this.SendMessageUpward(\"MethedName\"); 通过委托通知A注册特定方法，B声明委托。当B想调用A的方法时，通过委托通知。 消息机制提供的功能 注册事件 注销事件 发送事件 123MsgDispatcher.Register(\"消息名\",(obj)=&gt;{ /* 处理消息 */ });MsgDispatcher.Send(\"消息名\",\"消息内容\");MsgDispatcher.UnRegister(\"消息名\"); new Class的优化当一个class作为存储数据时，为了减少new的次数可以做一个对象池进行存储 123456789101112131415161718192021222324252627282930313233private class MsgRecord{ //私有构造函数后，class无法被new private MsgRecord() { } //对象池 static Stack&lt;MsgRecord&gt; mMsgRecordPool = new Stack&lt;MsgRecord&gt;(); //创建对象 public static MsgRecord Allocate(string msgName, Action&lt;object&gt; onMsgReceived) { MsgRecord msgRecord; if (mMsgRecordPool.Count &gt; 0) { msgRecord = mMsgRecordPool.Pop(); } else { msgRecord = new MsgRecord { }; } msgRecord.Name = msgName; msgRecord.OnMsgReceived = onMsgReceived; return msgRecord; } //移除对象 public void Recycle() { Name = null; OnMsgReceived = null; mMsgRecordPool.Push(this); } public string Name; public Action&lt;object&gt; OnMsgReceived;} 框架的定义框架：提供⼀个架构（⽂件结构、约定等等），你必须遵守它，只要你遵守，那剩下的就 全部处理通⽤需求了。 好架构=好规则 库的定义库，插到既有 架构上，补充特定功能。 Unity常用架构1.EmptyGo 在 Hierarchy 上创建⼀个空的 GameObject,然后挂上所有与 GameObject ⽆关的逻辑控制的脚 本。使⽤GameObject.Find() 访问对象数据。 缺点:逻辑代码散落在各处,不适合⼤型项⽬。 2.Simple GameManager所有与 GameObject ⽆关的逻辑都放在⼀个单例中。 缺点:单⼀⽂件过于庞⼤ 3.Manager Of Managers将不同的功能单独管理。 如下: MainManager: 作为⼊⼝管理器。 EventManager: 消息管理。 GUIManager: 图形视图管理。 AudioManager: ⾳效管理。 PoolManager: GameObject管理（减少动态开辟内存消耗,减少GC)。 存储各类型的spawnPool，spawnpool存储各prefabPool。删除和添加时如果不需要立即操作，可以分步进行添加删除。(最基本拥有) LevelManager: 关卡管理。 (最基本拥有) GameManager: 游戏管理。 SaveManager: 配置&amp;存储管理。(最基本拥有) Easy save2插件使用二进制操作 ，对数据加密 MenuManager 菜单管理。 4.将 View 和 Model 之间增加⼀个媒介层UI和逻辑分离 MVCS: ​ StrangeIOC 插件。 ​ IBinder.Bind&lt;Key&gt;().To&lt;Value&gt;(); ​ IBinder.Bind&lt;Key&gt;().To&lt;Value&gt;().ToName(name);当key和value都相同时，根据name区分 ​ 通过event和listener来触发按键的操作 ​ 机制依赖于C#的Reflection(反射)，效率慢，模式、思想和理念可借鉴 MVVM: ​ uFrame 插件 5.ECS (Entity Component Based System) Unity 是基于 ECS,⽐较适合 GamePlay 模块使⽤ Manager Of Managers架构模式LevelManagerUnity里的LoadScene方法只能传递scene名字或index。改名或者变换顺序时变得非常麻烦。通过配置表配置，读取level时按顺序读取配置表即可。 PoolManager两个经典操作，Spawn、Despawn Spawn在创建新资源时，对象池有则直接调用，没有则需要初始化。 DeSpawn当池子容量达到指定上限时，将第一个第二个按照队列顺序进行销毁，先进先出。 对象池优化一个PoolManager下有若干个SpawnPool来管理一类的物体。比如NPC一个Pool，物品一个Pool。一个SpawnPool有若干个PrefabPool，一个PrefabPool只能存储一个Prefab，可以进行单个Prefab的加载和卸载。 对于每一个PrefabPool可以管理两个List，一个是ActivetedList，一个是DeactivateList，并管理所有Prefab的加载和卸载过程。 在删除时对数量要严格控制，一帧内不能同时删除太多物体，否则会触发GC。需要PoolManager管理时能够缓释，一帧只删除少量对象。 SaveManagerEasy Save2二进制进行Load和Save，与Unity很好的结合，Unity类型基本都能Serialized。比Json的一些方案快。 MainManager入口管理器，如资源加载流程、第三方SDK启动流程、热更新检测，都是在入口处完成的。 在开发阶段不同流程会有不同的log或调试需要进行阶段划分进行屏蔽。 职责： 管理多个入口 负责游戏的启动流程。 阶段划分 开发阶段:不断编码-&gt;验证结果-&gt;编码-&gt;验证结果-&gt;…. 出包/真机阶段：跑完整流程，QA测试 发布阶段：上线 对应的枚举 12345public enum EnvironmentMode{ Developing, QA, Release} 根据枚举执行抽象方法 123456789101112131415161718192021222324252627282930313233public abstract class MainManager : MonoBehaviour{ public EnvironmentMode mode; private static EnvironmentMode mSharedMode; private static bool mModeSetted = false; private void Start() { //不同场景不同mode时只会有一个唯一mode if (!mModeSetted) { mSharedMode = mode; mModeSetted = true; } switch (mSharedMode) { case EnvironmentMode.Developing: LaunchInDevelopingMode(); break; case EnvironmentMode.Test: LaunchInTestMode(); break; case EnvironmentMode.Production: LaunchInProductionMode(); break; } } protected abstract void LaunchInDevelopingMode(); protected abstract void LaunchInTestMode(); protected abstract void LaunchInProductionMode();} GuiManager加载卸载通过字典管理，加载和卸载通过存储Panel名字为key，GameObject为Value 123456789101112131415161718192021222324252627282930private static Dictionary&lt;string, GameObject&gt; mPanelDict = new Dictionary&lt;string, GameObject&gt;(); public static void UnLoadPanel(string PanelName) { if (mPanelDict.ContainsKey(PanelName)) { var gObj = mPanelDict[PanelName]; Destroy(gObj); } } public static GameObject LoadPanel(string PanelName, UILayer uILayer) { var PanelPrefab = Resources.Load&lt;GameObject&gt;(PanelName); var PanelObj = Instantiate(PanelPrefab, UIRoot.transform); PanelObj.name = PanelName; mPanelDict.Add(PanelName, PanelObj); switch (uILayer) { case UILayer.Bg: PanelObj.transform.SetParent(UIRoot.transform.Find(\"Bg\")); break; case UILayer.Common: PanelObj.transform.SetParent(UIRoot.transform.Find(\"Common\")); break; case UILayer.Top: PanelObj.transform.SetParent(UIRoot.transform.Find(\"Top\")); break; } return PanelObj; } 层级管理通过枚举分级,在Scene中创建相对应的GameObject来管理对应Panel的层级关系 123456public enum UILayer{ Bg, Common, Top} 在加载时加载到对应层级的GameObject中 12345678910111213141516171819public static GameObject LoadPanel(string panelName, UILayer uILayer){ var canvasObj = GameObject.Find(\"Canvas\"); var PanelPrefab = Resources.Load&lt;GameObject&gt;(panelName); var PanelObj = Instantiate(PanelPrefab, canvasObj.transform); switch (uILayer) { case UILayer.Bg: PanelObj.transform.SetParent(canvasObj.transform.Find(\"Bg\")); break; case UILayer.Common: PanelObj.transform.SetParent(canvasObj.transform.Find(\"Common\")); break; case UILayer.Top: PanelObj.transform.SetParent(canvasObj.transform.Find(\"Top\")); break; } return PanelObj;} UIRoot将前面所描述的canvas结构，制作为Prefab，名字为UIRoot，管理所有的UIPanel。 在GUIManager中存储一份，在加载Panel时使用。 1234567891011121314private static GameObject mPrivateUIRoot;public static GameObject UIRoot{ get { //懒加载 if (mPrivateUIRoot == null) { mPrivateUIRoot = GameObject.Instantiate(Resources.Load&lt;GameObject&gt;(\"UIRoot\")); } mPrivateUIRoot.name = \"UIRoot\"; return mPrivateUIRoot; }} AudioManager播放音效1234567891011/// &lt;summary&gt;音效 &lt;/summary&gt;public void PlaySound(string soundName){ CheckAudioListener(); var doorClip = Resources.Load&lt;AudioClip&gt;(soundName); var audioSource = gameObject.AddComponent&lt;AudioSource&gt;(); audioSource.clip = doorClip; audioSource.Play();} 播放背景音 12345678910111213141516/// &lt;summary&gt;背景音 &lt;/summary&gt;public void PlayMusic(string soundName, bool IsLoop = true){ CheckAudioListener(); if (mMusicSource == null) { mMusicSource = gameObject.AddComponent&lt;AudioSource&gt;(); } var doorClip = Resources.Load&lt;AudioClip&gt;(soundName); var audioSource = gameObject.AddComponent&lt;AudioSource&gt;(); audioSource.loop = IsLoop; audioSource.clip = doorClip; audioSource.Play();} PoolManager对象池解决的问题 减少new时候寻址造成的消耗，该消耗的原因是内存碎片。 减少Object.Instantiate时内部进行序列化和反序列化而造成的CPU消耗。 简易对象池获取的操作一般为Allocate(分配)，放入为Recycle(回收)。也有叫Spawn和Despawn 定义池接口12345public interface IPool&lt;T&gt;{ T Allocate(); bool Recycle(T obj);} 在Allocate和Recycle时不在意对象顺序，只需要位置连续，使用stack容器来存储对象。 使用一个简单工厂接口来创建对象。1234public interface IObjectFactory&lt;T&gt;{ T Create();} 对象池12345678910111213141516171819202122232425262728public abstract class Pool&lt;T&gt; : IPool&lt;T&gt;{ protected Stack&lt;T&gt; mCachedStack = new Stack&lt;T&gt;(); protected IObjectFactory&lt;T&gt; mFactory; protected int MaxNum = 5; public int curCount { get { return mCachedStack.Count; } } public virtual T Allocate() { if (mCachedStack.Count == 0) { return mFactory.Create(); } return mCachedStack.Pop(); } public abstract bool Recycle(T obj); //public virtual bool Recycle(T obj) //{ // if (mCachedStack.Count &gt;= MaxNum) // { // return false; // } // mCachedStack.Push(obj); // return true; //}} 基于工厂接口的简易工厂12345678910111213141516171819/// &lt;summary&gt;/// 基于工厂接口的简易工厂/// &lt;/summary&gt;/// &lt;typeparam name=\"T\"&gt;&lt;/typeparam&gt;public class CustomObjectFactroy&lt;T&gt; : IObjectFactory&lt;T&gt;{ /// &lt;summary&gt; /// 使用委托设置类内部信息 /// &lt;/summary&gt; private Func&lt;T&gt; mFactoryMethod; public CustomObjectFactroy(Func&lt;T&gt; factoryMethod) { mFactoryMethod = factoryMethod; } public T Create() { return mFactoryMethod(); }} 包含创建方法的简易对象池123456789101112131415161718192021222324252627/// &lt;summary&gt;/// 简易对象池/// &lt;/summary&gt;/// &lt;typeparam name=\"T\"&gt;&lt;/typeparam&gt;public class SimpleObjectPool&lt;T&gt; : Pool&lt;T&gt;{ //重置方法 Action&lt;T&gt; mResetMethod; public SimpleObjectPool(Func&lt;T&gt; factoryMethod, Action&lt;T&gt; ResetMethod = null, int initCount = 0) { mFactory = new CustomObjectFactroy&lt;T&gt;(factoryMethod); mResetMethod = ResetMethod; for (int i = 0; i &lt; initCount; i++) { mCachedStack.Push(mFactory.Create()); } } public override bool Recycle(T obj) { if (mResetMethod != null) { mResetMethod(obj); } mCachedStack.Push(obj); return true; }} 复盘设计一个比较复杂的模块结构时,可以先设计一个接口(规范)。描述内容有什么 在mFractroy.Create和Recycle(回收)时，更偏向于自定义的操作 LevelManager123456789101112131415161718192021222324public class LevelManager : MonoBehaviour{ //可换成配置表 private static List&lt;string&gt; mLevelNames; public static int Index { get; set; } public static void Init(List&lt;string&gt; levelNames) { mLevelNames = levelNames; Index = 0; } public static void LoadCurrent() { SceneManager.LoadScene(mLevelNames[Index]); } public static void LoadNext() { Index++; if (Index &gt;= mLevelNames.Count) { Index = 0; } SceneManager.LoadScene(mLevelNames[Index]); }} 单元测试Probject内-&gt;右键-&gt;Create-&gt;Testing 创建相对应的c#文件(test模板)在Test Runner 界面内可以看到所有的测试脚本和对应的方法 类似于自己编写测试用例进行测试 Assert.AreEqual叫做断言，在开发大项目时非常有用的工具。测试通不通过取决于断言通不通过。","categories":[{"name":"框架篇","slug":"框架篇","permalink":"http://ysich.github.io/categories/%E6%A1%86%E6%9E%B6%E7%AF%87/"}],"tags":[{"name":"Manager 框架","slug":"Manager-框架","permalink":"http://ysich.github.io/tags/Manager-%E6%A1%86%E6%9E%B6/"}]},{"title":"游戏资源管理","slug":"游戏资源管理","date":"2023-01-16T04:56:44.000Z","updated":"2023-02-01T09:32:57.671Z","comments":true,"path":"2023/01/16/游戏资源管理/","link":"","permalink":"http://ysich.github.io/2023/01/16/%E6%B8%B8%E6%88%8F%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/","excerpt":"","text":"游戏资源管理游戏运行就是一个接一个资源的展示，如何管理好这些展示的资源让游戏能够流畅运行在开发中非常重要。需要在合理的地方调用、加载资源，资源空闲时对其进行卸载以减少内存占用。当内存超出预算可能导致游戏闪退，所以对资源的管理实际就是对内存的优化！ 本文争取一文搞懂资源管理。PS：可能和一个视频学完c++差不多(一个视频一个多月) TODOLIST： 分包策略 依赖处理 AssetBundle详细 热更 断点续传 代码热更新/热重载 Lua重新将函数指针赋值的策略 HybridCLR 资源包和资源区分开 一些资源策略 整包只有基础内容，后续章节热更的形式(大资源情况) YooAsset扩展篇 资源管理主要的需求有哪些？ 为开发与正式版本提供资源的加载和卸载 支持远程更新资源 做好版本、平台、渠道的资源管理 内存优化 Unity中的两种加载方式Resources 资源必选放在Resources文件夹下；有容量上限(大概是2G)；重复加载和重复卸载操作，Unity做了容错处理不会报错。不支持热更，只能打整包 适合放游戏的启动逻辑需要的资源 可能会延长游戏启动时间 AssetBundle 可以理解成Unity内的资源压缩包，有不同的压缩方式，解压速度和包体大小也不同(LZMA 和 LZ4)。 适合做热更，以减少包体的初始大小。 已加载的资源不允许重复加载，会报错。而使用AssetDatabase则不需要考虑。需要使用引用计数。 这里还有一些开源的资源管理系统，如YooAsset。 同步加载与异步加载同步加载同步加载在加载资源时，会阻塞线程。等加载逻辑完成后才继续执行后续逻辑（图灵机） 异步加载同步加载在加载较大资源时阻塞明显，造成卡顿。因为Unity中所有的渲染都是放在主线程中的，所以主线程阻塞非常致命不能进行任何玩家操作。 所以需要使用另外一种加载方式对较大资源进行加载。异步加载使用协程/线程进行加载逻辑，等资源加载完毕后触发资源加载后的callback。 在一些资源的加载会影响到游戏的展示时，可以在需要之前对资源进行预先加载，保证流程能够顺利进行。 异步加载的三种状态异步加载的逻辑由于执行完成的时间不确定，可能会导致其他逻辑的冲突。所以我们给异步加载按照逻辑划分状态，好让其他逻辑能够做区分，不同状态下处理相应的操作。 未加载 异步加载还没开始时可能需要准备的事情，比如资源包不在本地需要下载、解密、解压等等。 加载中 资源开始加载后，其他业务逻辑也加载了相同资源时，可以判断这个资源的状态。正在加载则不再进行加载前的准备操作，并把加载后的callback注册进去。 已加载 主要为加载后触发相应callback。 123456public enum LoaderState { NONE, // 默认 LOADING, // 加载中 FINISHED, // 完成 } 存在问题玩家在进入一个场景后，假设资源预加载需要10s，玩家却在未加载完资源的过程中退出场景。这时候就会引发资源状态的问题。 资源缓存池资源缓存池为统一存储和调用资源的地方。在加载资源后统一存入池子中，卸载时则将其从池子中删除。 加载时先判断池子中是否存在此资源包，如果已经加载过了直接则直接使用，未加载再进行加载逻辑。 以下内容主要以AssetBundle举例 123public class AssetBundlePool{ private Dictionary&lt;string,AssetBundleInfo&gt; m_LoadAssetBundle = new Dictionary&lt;string,AssetBundleInfo&gt;();} 引用计数基础概念引用技术的应用范围很广，很多引擎、框架、插件的底层都离不开引用计数。 简单思想：被引用+1，不被引用时-1，当为0时触发清空逻辑。 123456789101112131415161718192021public interface IRefCounter{ int RefCount { get; } void Retain(); void Release();}public class SimpleRC : IRefCounter{ public int RefCount { get; private set; } public void Retain() { RefCount++; } public void Release() { RefCount--; if (RefCount == 0){ OnZeroRef(); } } protected virtual void OnZeroRef(){}} 与资源管理结合的引用计数资源被使用时引用次数+1，资源解除使用时次数-1，当引用次数为0时则进行卸载逻辑。 1234567891011public class AssetBundleInfo{ private AssetBundle m_AssetBundle; //AB包引用 public AssetBundle AssetBundle { get { return m_AssetBundle; } } public int m_ReferencedCount; //引用计数 public AssetBundleInfo(AssetBundle assetBundle) { m_AssetBundle = assetBundle; m_ReferencedCount = 1; }} 与资源缓冲池结合的加载123456789101112131415161718192021222324252627public class AssetBundlePool{ private Dictionary&lt;string,AssetBundleInfo&gt; m_LoadAssetBundle = new Dictionary&lt;string,AssetBundleInfo&gt;(); public AssetBundle LoadAssetsFromAB(string abName) { AssetBundleInfo assetBundleInfo = null; if (m_LoadAssetBundle.TryGetValue(abName, out assetBundleInfo)) { //检查是否加载过 assetBundleInfo.m_ReferencedCount++;//这里可以使用封装好的引用计数，为了方便展示直接使用 } else { string loadPath = PathUnit.DataPath + PathUnit.ABRootPath + abName; var ab = AssetBundle.LoadFromFile(loadPath); if (ab is null) { Debug.Log(\"AB包加载失败！\"+ loadPath); } else { assetBundleInfo = new AssetBundleInfo(ab); m_LoadAssetBundle.Add(abName, assetBundleInfo); //assetBundleInfo.m_ReferencedCount++;这里不需要加了因为默认值为1 } } return assetBundleInfo.AssetBundle; }} 异步加载也是相同的操作，但有点不同。需要一个额外的队列记录加载中的文件。当加载中的文件又收到了加载请求时，则需要在列表中查找是否正在加载。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class AssetBundleCachePool{ public MonoBehaviour monoBehaviour; private Dictionary&lt;string, AssetBundleInfo&gt; m_LoadAssetBundle = new Dictionary&lt;string, AssetBundleInfo&gt;(); private Dictionary&lt;string, Action&lt;AssetBundle&gt;&gt; m_LoadingAssetBundle = new Dictionary&lt;string, Action&lt;AssetBundle&gt;&gt;(); public void LoadAssetsFormAbAsync(string abName, Action&lt;AssetBundle&gt; loadingABAction) { monoBehaviour.StartCoroutine(OnLoadAssetsFormAbAsync(abName, loadingABAction)); } IEnumerator OnLoadAssetsFormAbAsync(string abName, Action&lt;AssetBundle&gt; loadingABAction) { AssetBundleInfo assetBundleInfo = null; if (m_LoadAssetBundle.TryGetValue(abName,out assetBundleInfo)) { Debug.Log(\"已加载过\"); AssetBundle assetBundle = assetBundleInfo.AssetBundle; //引用计数+1 assetBundleInfo.m_ReferencedCount++; //触发回调 if (loadingABAction != null) { loadingABAction.Invoke(assetBundle); } yield break; } else { if (m_LoadingAssetBundle.TryGetValue(abName,out Action&lt;AssetBundle&gt; temploadingABAction)) { if (loadingABAction != null) { temploadingABAction += loadingABAction; } Debug.Log(\"正在被加载\"); yield break; } else { //这步需要执行，避免与其他逻辑冲突 m_LoadingAssetBundle.Add(abName, loadingABAction); string loadPath = PathUnit.DataPath + PathUnit.ABRootPath + abName; AssetBundleCreateRequest assetBundleCreateRequest = AssetBundle.LoadFromFileAsync(loadPath); AssetBundle resAB = assetBundleCreateRequest.assetBundle; if (resAB is null) { Debug.LogError(\"AB包不能存在\"); } else { assetBundleInfo = new AssetBundleInfo(resAB); m_LoadAssetBundle.Add(abName, assetBundleInfo); } //加载完成移除加载中列表 //避免啥异常状况，保险点！先判断是否存在 if (m_LoadingAssetBundle.ContainsKey(abName)) { Action&lt;AssetBundle&gt; action = m_LoadingAssetBundle[abName]; m_LoadingAssetBundle.Remove(abName); var callBackList = action.GetInvocationList(); foreach (Action&lt;AssetBundle&gt; callBack in callBackList) { callBack.Invoke(resAB); } } } } }} 与资源缓冲池结合的卸载为了保持平衡有了加载就一定会有卸载。但是在游戏中(特别是手游)卸载操作需要加上一些限制，因为在短时间内进行了大量资源的卸载增加了大量的IO操作也会造成卡顿（线程阻塞）的。🙂 所以我们的卸载操作需要与数量和时间扯上关系，在一定时间内只卸载一定数量的资源。 在引用计数中，如果引用计数为0则标记为可以开始卸载了。 1234567891011121314public class AssetBundleInfo{ public int ReferencedCount { get { return m_ReferencedCount; } set { m_ReferencedCount = value; if (m_ReferencedCount&lt;= 0) IsUnLoadFlag = true; else IsUnLoadFlag = false; } } public bool IsUnLoadFlag { get; private set; } private int m_ReferencedCount; //引用计数} 与时间挂钩与时间挂钩就需要有个地方能够一直统计和计算我们的时间并进行回收 123456public class ResourceManager{ void Update(){ }} 依赖本文之前的代码都是没有考虑依赖的，所以如果真的跑起来会发现计数会有偏差。 一个资源身上用到了别的AB包中的资源，这时候如果只加载自身的AB包，就会出现资源丢失的情况。这时候就需要把当前资源需要用到的依赖包一起加载出来。 但是我们又要怎么知道这个资源依赖于哪些包？ 这时候就需要用到Unity提供的AB包依赖文件来判断，后缀.manifest·。 Asset篇Asset什么是Asst？浅谈Assets——Unity资源映射 Resources什么是Resources？Resources目录的优点与痛点 AssetBundle什么是AssetBundle？AssetBundle的原理及最佳实践 热更篇Todo💁♀这部分内容写在别的地方，比较乱后续整理。","categories":[{"name":"资源管理篇","slug":"资源管理篇","permalink":"http://ysich.github.io/categories/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%AF%87/"}],"tags":[{"name":"资源管理","slug":"资源管理","permalink":"http://ysich.github.io/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"}]},{"title":"Lua基础语法","slug":"Lua基础语法","date":"2023-01-13T06:12:28.000Z","updated":"2023-01-17T06:16:15.830Z","comments":true,"path":"2023/01/13/Lua基础语法/","link":"","permalink":"http://ysich.github.io/2023/01/13/Lua%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","excerpt":"","text":"Lua基础语法注意点 循环用do，if语句用then，都使用end结尾 Lua不支持自减和自加操作，只能i=i+1，i=i-1 字符串的第一个位置是1不是0 技巧 Lua的字符串可以存储0x00，可以用字符串存储二进制流 注释 用--开头，来写一段单行注释 1-- 单行注释 用--[[开头，]]结尾，写一段多行注释。 1234--[[ 多行 注释]] 变量对一个变量进行赋值就相当于声明变量，与python相似 声明的变量默认为全局变量1a=1 同时给多个变量赋值，多重赋值 1a,b=1,2 局部变量1local b=2 nil类型没有被声明过的变量都是nil nil类型只有一个值，就是nil nil类似null类型 if(nil)为false number类型1234--支持十六进制表示方法a=0x11--输出为17--科学计数法a=2e10 string类型单引号、双引号1234a=\"daeqeq\"b='sdarrr'--转义字符\\nd=\"sdada\\nsdar\" 多行文本多行文本无法使用转义字符 1c=[[asdasfffrrqweqq]] 字符串连接字符串连接符号.. 1234a=\"daeqeq\"b='sdarrr'c=a..bprint(\"asdaf\"..\"as232\") 数值转字符串1tostring(10) 字符串转数值tonumber转换失败为nil 1tonumber(\"193\") 获取字符串长度123a=\"daeqeq\"print(#a)--等价于s:len() string类型类似char数组Lua中string类型 类似于C里的字符数组，可以包含任意数值包括0x00，可以存储二进制流因为都是原原本本存储 将ascii码转为字符串12s=string.char(65)s=string.char(0x30,0x31,0x32,0x33) 取出string中的某一位的ascii码1234n=string.byte(s,2)print(n)--语法糖，第一个到最后一个s:byte(1，-1) format调用c的接口 12local f=string.format(\"%d,%d\",1,2)print(f) function函数函数默认返回值为nil，没有任何返回值则为nil 1234567function function_name() --bodyend--函数名放前面f=function(...) --bodyend 123456function f(a,b,c) print(a,b,c) return aend--c没有传值则为nilprint(f(1,2))--1 函数可以返回多个值12345function f(a,b,c) return a,bendprint(f(1,2)) 多个返回值可以使用多重赋值语句12345function f(a,b,c) return a,bendlocal i,j=f(1,2) tabletable接口123table.insert(a,\"d\")--插入元素，末尾添加table.insert(a,2,\"d\")--插入元素，第二个位置，后续元素后移local s= table.remove(a,2)--移除第2个元素 table数字下标可以存所有东西(number,string,table,function) 12345a={1,\"ac\",{},function() end}a[5]=123 --可以直接添加一个元素print(a[1])--获取table长度print(#a) table字符串下标以字符为table的下标 12345678910a={ a=1, b=\"1234\", c=function() end, d=123123}print(a[\"a\"])--下标符合变量命名规范时print(a.a) 全局表_GLua内的所有全局变量都在_G这个table内 包括table.insert中的table(也是全局变量)也存储在_G中，insert为table的下标 1234print(_G[\"table\"][\"insert\"])--function: 0000000063be4590--输出值为一个函数--多文件调用知识 布尔型不等于在Lua中不等于使用~=表示 123456789a=trueb=falseprint(1&gt;2)print(1&lt;2)print(1&gt;=2)print(1&lt;=2)print(1==2)--不等于print(1~=2) 与或非只有false和nil表示假其他都表示真，包括0 123print(a and b)print(a or b)print(not a) and``or返回的并不完全是true和false，会直接返回a或者b的值，可以通过短路求值 只有not返回true和false 123456a=nil --真b=0 --假print(a and b) --nilprint(a or b) --0print(not a) --trueprint(b&gt;10 and \"yes\" or \"no\") --no 分支判断if语句1234567if 1&gt;10 then print(\"1&gt;10\")elseif 1&lt;10 then print(\"1&lt;10\")else print(\"no\")end 循环for循环1234567for i=1,10 do print(i)end--步长为2for i=1,10,2 do print(i)end 倒序循环123for i=10,1,-1 do print(i)end i在过程途中不能赋值，赋值了也没用 假如对i赋值会被认定为新建了局部变量 1234for i=10,1,-1 do print(i) local i=1end break通过break退出循环 1234for i=10,1,-1 do print(i) if i == 5 then break endend while循环12345n = 10while n&gt;1 do print(n) n = n - 1end repeat循环和while循环基本一致 多文件调用require和import的区别require实现换个目录后就需要对路径进行变更 个人理解：绝对路径 12345local MyClassBase = require(\"app.classes.MyClassBase\")local MyClass = class(\"MyClass\", MyClassBase)local Data1 = require(\"app.classes.data.Data1\")local Data2 = require(\"app.classes.data.Data2\") import实现在模块名前添加多个”.” ，这样 import() 会从更上层的目录开始查找模块。 个人理解：相对路径 12345local MyClassBase = import(\".MyClassBase\")local MyClass = class(\"MyClass\", MyClassBase)local Data1 = import(\".data.Data1\")local Data2 = import(\".data.Data2\") require运行指定多文件 末尾不带扩展名 12--.\\?lua 把文件名匹配到？内require(\"文件名\") 不同层架文件夹用.分隔 1require(\"文件夹名.文件名\") 只会运行一次 12345678--lua文件有可以return返回值local r = require('hello')--后面调用的都是前面返回的内容require('hello')require('hello')require('hello')require('hello')print(r) package.path12package.path=package.path..\";./path/?.lua\"require('hello2') 多次调用调用lua文件内的函数 123456789101112--hello.lualocal hello={}function hello.say() print(\"hello world\")end//通过返回tablereturn hello--test.lualocal test=require('hello')//通过table内的方法调用test.say() 迭代table1234t={\"a\",\"b\",\"c\",\"d\"}for i=1,#t,do print(i,t[i])end 迭代器ipairs纯数字连续下标可以用 12345t={\"a\",\"b\",\"c\",\"d\"}--下标给i，值给jfor i,j in ipairs(t) do print(i,j)end 1234567891011t={ [1]=\"a\", [2]=\"b\", [3]=\"c\", [5]=\"d\"}--下标给i，值给jfor i,j in ipairs(t) do --只能遍历到1到3，不连续的后面遍历不到 print(i,j)end 迭代器pairs可以遍历所有下标 pairs内部调用的是next函数 1234567891011t={ [1]=\"a\", [2]=\"b\", [3]=\"c\", [5]=\"d\"}--下标给i，值给jfor i,j in pairs(t) do --只能遍历到1到3，不连续的后面遍历不到 print(i,j)end 1234567891011t={ apple=\"a\", banana=\"b\", eraser=\"c\", water=\"d\"}--下标给i，值给jfor i,j in pairs(t) do --只能遍历到1到3，不连续的后面遍历不到 print(i,j)end 元表、元方法语法糖12345678t={ a=0, add=function(tab,num) tab.a=tab.a+num end}--类似于面向对象的方法调用t:add(10)--等价于t.add(t,10) 面向对象123456789101112131415161718192021222324--对象名bag={}bagmt={ --装入东西的函数 put=function(t,item) table.insert(t.items,item) end, take=function(t) return table.remove(t) end, list=function(t) return table.concat(t.items,\",\") end}bagmt[\"__index\"]=bagmt--构造函数function bag.new() local t={ items={} } setmetatable(t,bagmt) return tend 协程coroutine一个lua虚拟机里只能有一个线程 coroutine.create 可创建一个协程返回值为 thread 类型 123456local co=coroutine.create( function() print(\"hello world!\") end )","categories":[{"name":"编程语言篇","slug":"编程语言篇","permalink":"http://ysich.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%AF%87/"}],"tags":[{"name":"Lua","slug":"Lua","permalink":"http://ysich.github.io/tags/Lua/"}]}],"categories":[{"name":"框架篇","slug":"框架篇","permalink":"http://ysich.github.io/categories/%E6%A1%86%E6%9E%B6%E7%AF%87/"},{"name":"资源管理篇","slug":"资源管理篇","permalink":"http://ysich.github.io/categories/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%AF%87/"},{"name":"编程语言篇","slug":"编程语言篇","permalink":"http://ysich.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%AF%87/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://ysich.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"性能优化 资源管理 Asset","slug":"性能优化-资源管理-Asset","permalink":"http://ysich.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86-Asset/"},{"name":"框架 ET框架 帧同步 状态帧同步","slug":"框架-ET框架-帧同步-状态帧同步","permalink":"http://ysich.github.io/tags/%E6%A1%86%E6%9E%B6-ET%E6%A1%86%E6%9E%B6-%E5%B8%A7%E5%90%8C%E6%AD%A5-%E7%8A%B6%E6%80%81%E5%B8%A7%E5%90%8C%E6%AD%A5/"},{"name":"资源管理 AssetBundle 热更新","slug":"资源管理-AssetBundle-热更新","permalink":"http://ysich.github.io/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86-AssetBundle-%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"Manager 框架 ET框架","slug":"Manager-框架-ET框架","permalink":"http://ysich.github.io/tags/Manager-%E6%A1%86%E6%9E%B6-ET%E6%A1%86%E6%9E%B6/"},{"name":"CallBack","slug":"CallBack","permalink":"http://ysich.github.io/tags/CallBack/"},{"name":"Manager 框架","slug":"Manager-框架","permalink":"http://ysich.github.io/tags/Manager-%E6%A1%86%E6%9E%B6/"},{"name":"资源管理","slug":"资源管理","permalink":"http://ysich.github.io/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"},{"name":"Lua","slug":"Lua","permalink":"http://ysich.github.io/tags/Lua/"}]}