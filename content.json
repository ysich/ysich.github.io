{"meta":{"title":"ysich'Blog","subtitle":"","description":"","author":"ysich","url":"http://ysich.github.io","root":"/"},"pages":[{"title":"三十六分热","date":"2023-01-16T12:19:47.112Z","updated":"2023-01-16T12:19:47.112Z","comments":false,"path":"about/index.html","permalink":"http://ysich.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"关于CallBack","slug":"关于CallBack","date":"2023-01-31T02:36:16.000Z","updated":"2023-01-31T02:37:19.200Z","comments":true,"path":"2023/01/31/关于CallBack/","link":"","permalink":"http://ysich.github.io/2023/01/31/%E5%85%B3%E4%BA%8ECallBack/","excerpt":"","text":"关于CallBackCallback提高cpu利用率不会造成阻塞。做一件事不会等待，等需要时再call back处 应用场景 DMA控制器 cpu做数据复制时会阻塞cpu，cpu 通知硬件进行复制完成后通知回来。不会阻塞整个cpu 网络多路复用 Socket读写过程中，等待数据发送或接收过程cpu的阻塞。等数据过来后再进行通知。 多线程 时间 比如等待5秒后执行一个函数，不需要阻塞线程5秒后再执行。 CallBack历史函数指针C语言内通过函数指针的方式，在callback 后用指针执行函数，但是不方便同步上下文且类型不安全（可以传递任意指针） 函数对象C++通过函数对象的方式，类型安全、构造时传递函数指针、构造时传递上下文、绑定上下文 将上下文和回调函数封装成一个类（闭包），做到延迟调用。闭包比较繁琐，当需要上下文对象类型不满足已有扩展的闭包支持的类型时就要进行 闭包类型的扩展。 谷歌的NewCallBack上下文只能绑定前面的参数不能绑定后面的参数、返回的是指针（本质是new一个函数对象执行）如果没有调用会造成内存泄漏（解决方案：使用智能指针包裹） Callback Hell（回调地狱）在处理回调时，我们的逻辑会被截成两段，一段是发起callback 一段是响应callback 。在Callback调用Callback的过程中，代码相应会像波浪一样越推越远。 易出错、难修改。在callback 中难插入。 async await Task把int Func() (回调) 转成await Func() 在C#中通过转换工具TaskCompletionSource 转换 ETTask 简化的Task 生成代码简单 (.Net Reflector 可以.net stand 2.0反编译) 解决了GC问题 Task 使用TaskCompletionSource工具类转换成await Func 时会new 工具类 ETTask在确保安全的时候使用池消除gc，Set Result (true)时回收 TaskCompletionSource和Task合并 不提供多线程处理 并行ET提供WaitAll WaitAny，类比线程同步barrier 当多个回调同时发起，等所有回调执行完再往下执行 场景： 切换场景资源,不需要一个个加载，可以同时加载，等所有加载完再往下执行。 机器人登录50个，不需要一个个登录。 协程锁应用场景： 两个逻辑同时加载同一个ab包 服务器玩家异步加载处理到一半，这时收到下线消息。 实现： CoroutineComponent实现思路： 同一种锁，同一个key放入同一个队列 一个协程执行完后从自己队列中取出下一个执行 问题: 协程执行取出下一个执行时，如果消息处理不过来会产生队列内的处理逻辑的堆积。队列很多时，堆栈的层级也会很多(因为逐层调用)，导致堆栈爆掉。 改进： 取出下一个执行时，不直接执行而是放入update中执行。 问题： 协程锁死锁情况，await互相等，永远等不到 改进： ET协程锁添加时间限制，时间到了解锁(超时机制)。","categories":[{"name":"框架篇","slug":"框架篇","permalink":"http://ysich.github.io/categories/%E6%A1%86%E6%9E%B6%E7%AF%87/"}],"tags":[{"name":"CallBack","slug":"CallBack","permalink":"http://ysich.github.io/tags/CallBack/"}]},{"title":"ManagerOfManager","slug":"ManagerOfManager","date":"2023-01-17T06:14:51.000Z","updated":"2023-01-17T08:48:13.113Z","comments":true,"path":"2023/01/17/ManagerOfManager/","link":"","permalink":"http://ysich.github.io/2023/01/17/ManagerOfManager/","excerpt":"","text":"框架搭建随笔版本号使⽤版本号命名的⽂件格式为: Framework_vX.Y.Z X 是主版本号，⽤于不向前兼容的更新。 Y 是中间版本，⽤于可向前兼容的功能性更新。 Z 是⼩版本号，⽤于功能完善和 bug 修复的更新 ⼀般都是从 v0.1.1 这个版本开始发布的，但是这个版本呢叫做 mvp 版本，也就是最⼩可验证版本。后续发布版本都需要向前兼容 Obsolete 标签使用Obsolete标签标记方法已弃用，使用其他方法。 添加弃用标签后会报警报提醒 12345[Obsolete(\"方法已过时，请使用xx方法\")]public static void OpenInFolder(string folderPath){ Application.OpenURL(\"file://\" + folderPath);} Partial关键字当类后续可能增长的时候使用，各个部分类需要用相同的访问权限。而且每个部分类都需要加partial关键字。 方法结构重复 解决方案当一个方法的的参数类型不同时，如果有共同父类可以将类型设置为父类，子类可以进行使用 123456789101112public static int GetRandomValueFrom(int[] values){ return values[Random.Range(0, values.Length)];}public static float GetRandomValueFrom(float[] values){ return values[Random.Range(0, values.Length)];}public static string GetRandomValueFrom(string[] values){ return values[Random.Range(0, values.Length)];} 可以将类型设置为object 1234public static object GetRandomValueFrom(object[] values){ return values[Random.Range(0, values.Length)];} 泛型实现结构复用使用泛型实现方法复用 1234public static T GetRandomValueFrom&lt;T&gt;(params T[] values){ return values[Random.Range(0, values.Length)];} params关键字修饰形参必须为一维数组，并且方法声明只能有一个params，如果不是一维数组编译器将报错。 使用 params 参数调用方法时，可以传入： 数组元素类型的参数的逗号分隔列表。 指定类型的参数的数组。 无参数。 如果未发送任何参数，则 params 列表的长度为零。 12345678910//数组元素类型的参数的逗号分隔列表public void Get(){ GetRandomValueFrom&lt;int&gt;(1, 2, 3);}//无参数public void Get(){ GetRandomValueFrom&lt;int&gt;();} 消息机制Unity内置消息机制方法调用使用字符串，可能用到反射，尽量不用。 1this.SendMessageUpward(\"MethedName\"); 通过委托通知A注册特定方法，B声明委托。当B想调用A的方法时，通过委托通知。 消息机制提供的功能 注册事件 注销事件 发送事件 123MsgDispatcher.Register(\"消息名\",(obj)=&gt;{ /* 处理消息 */ });MsgDispatcher.Send(\"消息名\",\"消息内容\");MsgDispatcher.UnRegister(\"消息名\"); new Class的优化当一个class作为存储数据时，为了减少new的次数可以做一个对象池进行存储 123456789101112131415161718192021222324252627282930313233private class MsgRecord{ //私有构造函数后，class无法被new private MsgRecord() { } //对象池 static Stack&lt;MsgRecord&gt; mMsgRecordPool = new Stack&lt;MsgRecord&gt;(); //创建对象 public static MsgRecord Allocate(string msgName, Action&lt;object&gt; onMsgReceived) { MsgRecord msgRecord; if (mMsgRecordPool.Count &gt; 0) { msgRecord = mMsgRecordPool.Pop(); } else { msgRecord = new MsgRecord { }; } msgRecord.Name = msgName; msgRecord.OnMsgReceived = onMsgReceived; return msgRecord; } //移除对象 public void Recycle() { Name = null; OnMsgReceived = null; mMsgRecordPool.Push(this); } public string Name; public Action&lt;object&gt; OnMsgReceived;} 框架的定义框架：提供⼀个架构（⽂件结构、约定等等），你必须遵守它，只要你遵守，那剩下的就 全部处理通⽤需求了。 好架构=好规则 库的定义库，插到既有 架构上，补充特定功能。 Unity常用架构1.EmptyGo 在 Hierarchy 上创建⼀个空的 GameObject,然后挂上所有与 GameObject ⽆关的逻辑控制的脚 本。使⽤GameObject.Find() 访问对象数据。 缺点:逻辑代码散落在各处,不适合⼤型项⽬。 2.Simple GameManager所有与 GameObject ⽆关的逻辑都放在⼀个单例中。 缺点:单⼀⽂件过于庞⼤ 3.Manager Of Managers将不同的功能单独管理。 如下: MainManager: 作为⼊⼝管理器。 EventManager: 消息管理。 GUIManager: 图形视图管理。 AudioManager: ⾳效管理。 PoolManager: GameObject管理（减少动态开辟内存消耗,减少GC)。 存储各类型的spawnPool，spawnpool存储各prefabPool。删除和添加时如果不需要立即操作，可以分步进行添加删除。(最基本拥有) LevelManager: 关卡管理。 (最基本拥有) GameManager: 游戏管理。 SaveManager: 配置&amp;存储管理。(最基本拥有) Easy save2插件使用二进制操作 ，对数据加密 MenuManager 菜单管理。 4.将 View 和 Model 之间增加⼀个媒介层UI和逻辑分离 MVCS: ​ StrangeIOC 插件。 ​ IBinder.Bind&lt;Key&gt;().To&lt;Value&gt;(); ​ IBinder.Bind&lt;Key&gt;().To&lt;Value&gt;().ToName(name);当key和value都相同时，根据name区分 ​ 通过event和listener来触发按键的操作 ​ 机制依赖于C#的Reflection(反射)，效率慢，模式、思想和理念可借鉴 MVVM: ​ uFrame 插件 5.ECS (Entity Component Based System) Unity 是基于 ECS,⽐较适合 GamePlay 模块使⽤ Manager Of Managers架构模式LevelManagerUnity里的LoadScene方法只能传递scene名字或index。改名或者变换顺序时变得非常麻烦。通过配置表配置，读取level时按顺序读取配置表即可。 PoolManager两个经典操作，Spawn、Despawn Spawn在创建新资源时，对象池有则直接调用，没有则需要初始化。 DeSpawn当池子容量达到指定上限时，将第一个第二个按照队列顺序进行销毁，先进先出。 对象池优化一个PoolManager下有若干个SpawnPool来管理一类的物体。比如NPC一个Pool，物品一个Pool。一个SpawnPool有若干个PrefabPool，一个PrefabPool只能存储一个Prefab，可以进行单个Prefab的加载和卸载。 对于每一个PrefabPool可以管理两个List，一个是ActivetedList，一个是DeactivateList，并管理所有Prefab的加载和卸载过程。 在删除时对数量要严格控制，一帧内不能同时删除太多物体，否则会触发GC。需要PoolManager管理时能够缓释，一帧只删除少量对象。 SaveManagerEasy Save2二进制进行Load和Save，与Unity很好的结合，Unity类型基本都能Serialized。比Json的一些方案快。 MainManager入口管理器，如资源加载流程、第三方SDK启动流程、热更新检测，都是在入口处完成的。 在开发阶段不同流程会有不同的log或调试需要进行阶段划分进行屏蔽。 职责： 管理多个入口 负责游戏的启动流程。 阶段划分 开发阶段:不断编码-&gt;验证结果-&gt;编码-&gt;验证结果-&gt;…. 出包/真机阶段：跑完整流程，QA测试 发布阶段：上线 对应的枚举 12345public enum EnvironmentMode{ Developing, QA, Release} 根据枚举执行抽象方法 123456789101112131415161718192021222324252627282930313233public abstract class MainManager : MonoBehaviour{ public EnvironmentMode mode; private static EnvironmentMode mSharedMode; private static bool mModeSetted = false; private void Start() { //不同场景不同mode时只会有一个唯一mode if (!mModeSetted) { mSharedMode = mode; mModeSetted = true; } switch (mSharedMode) { case EnvironmentMode.Developing: LaunchInDevelopingMode(); break; case EnvironmentMode.Test: LaunchInTestMode(); break; case EnvironmentMode.Production: LaunchInProductionMode(); break; } } protected abstract void LaunchInDevelopingMode(); protected abstract void LaunchInTestMode(); protected abstract void LaunchInProductionMode();} GuiManager加载卸载通过字典管理，加载和卸载通过存储Panel名字为key，GameObject为Value 123456789101112131415161718192021222324252627282930private static Dictionary&lt;string, GameObject&gt; mPanelDict = new Dictionary&lt;string, GameObject&gt;(); public static void UnLoadPanel(string PanelName) { if (mPanelDict.ContainsKey(PanelName)) { var gObj = mPanelDict[PanelName]; Destroy(gObj); } } public static GameObject LoadPanel(string PanelName, UILayer uILayer) { var PanelPrefab = Resources.Load&lt;GameObject&gt;(PanelName); var PanelObj = Instantiate(PanelPrefab, UIRoot.transform); PanelObj.name = PanelName; mPanelDict.Add(PanelName, PanelObj); switch (uILayer) { case UILayer.Bg: PanelObj.transform.SetParent(UIRoot.transform.Find(\"Bg\")); break; case UILayer.Common: PanelObj.transform.SetParent(UIRoot.transform.Find(\"Common\")); break; case UILayer.Top: PanelObj.transform.SetParent(UIRoot.transform.Find(\"Top\")); break; } return PanelObj; } 层级管理通过枚举分级,在Scene中创建相对应的GameObject来管理对应Panel的层级关系 123456public enum UILayer{ Bg, Common, Top} 在加载时加载到对应层级的GameObject中 12345678910111213141516171819public static GameObject LoadPanel(string panelName, UILayer uILayer){ var canvasObj = GameObject.Find(\"Canvas\"); var PanelPrefab = Resources.Load&lt;GameObject&gt;(panelName); var PanelObj = Instantiate(PanelPrefab, canvasObj.transform); switch (uILayer) { case UILayer.Bg: PanelObj.transform.SetParent(canvasObj.transform.Find(\"Bg\")); break; case UILayer.Common: PanelObj.transform.SetParent(canvasObj.transform.Find(\"Common\")); break; case UILayer.Top: PanelObj.transform.SetParent(canvasObj.transform.Find(\"Top\")); break; } return PanelObj;} UIRoot将前面所描述的canvas结构，制作为Prefab，名字为UIRoot，管理所有的UIPanel。 在GUIManager中存储一份，在加载Panel时使用。 1234567891011121314private static GameObject mPrivateUIRoot;public static GameObject UIRoot{ get { //懒加载 if (mPrivateUIRoot == null) { mPrivateUIRoot = GameObject.Instantiate(Resources.Load&lt;GameObject&gt;(\"UIRoot\")); } mPrivateUIRoot.name = \"UIRoot\"; return mPrivateUIRoot; }} AudioManager播放音效1234567891011/// &lt;summary&gt;音效 &lt;/summary&gt;public void PlaySound(string soundName){ CheckAudioListener(); var doorClip = Resources.Load&lt;AudioClip&gt;(soundName); var audioSource = gameObject.AddComponent&lt;AudioSource&gt;(); audioSource.clip = doorClip; audioSource.Play();} 播放背景音 12345678910111213141516/// &lt;summary&gt;背景音 &lt;/summary&gt;public void PlayMusic(string soundName, bool IsLoop = true){ CheckAudioListener(); if (mMusicSource == null) { mMusicSource = gameObject.AddComponent&lt;AudioSource&gt;(); } var doorClip = Resources.Load&lt;AudioClip&gt;(soundName); var audioSource = gameObject.AddComponent&lt;AudioSource&gt;(); audioSource.loop = IsLoop; audioSource.clip = doorClip; audioSource.Play();} PoolManager对象池解决的问题 减少new时候寻址造成的消耗，该消耗的原因是内存碎片。 减少Object.Instantiate时内部进行序列化和反序列化而造成的CPU消耗。 简易对象池获取的操作一般为Allocate(分配)，放入为Recycle(回收)。也有叫Spawn和Despawn 定义池接口12345public interface IPool&lt;T&gt;{ T Allocate(); bool Recycle(T obj);} 在Allocate和Recycle时不在意对象顺序，只需要位置连续，使用stack容器来存储对象。 使用一个简单工厂接口来创建对象。1234public interface IObjectFactory&lt;T&gt;{ T Create();} 对象池12345678910111213141516171819202122232425262728public abstract class Pool&lt;T&gt; : IPool&lt;T&gt;{ protected Stack&lt;T&gt; mCachedStack = new Stack&lt;T&gt;(); protected IObjectFactory&lt;T&gt; mFactory; protected int MaxNum = 5; public int curCount { get { return mCachedStack.Count; } } public virtual T Allocate() { if (mCachedStack.Count == 0) { return mFactory.Create(); } return mCachedStack.Pop(); } public abstract bool Recycle(T obj); //public virtual bool Recycle(T obj) //{ // if (mCachedStack.Count &gt;= MaxNum) // { // return false; // } // mCachedStack.Push(obj); // return true; //}} 基于工厂接口的简易工厂12345678910111213141516171819/// &lt;summary&gt;/// 基于工厂接口的简易工厂/// &lt;/summary&gt;/// &lt;typeparam name=\"T\"&gt;&lt;/typeparam&gt;public class CustomObjectFactroy&lt;T&gt; : IObjectFactory&lt;T&gt;{ /// &lt;summary&gt; /// 使用委托设置类内部信息 /// &lt;/summary&gt; private Func&lt;T&gt; mFactoryMethod; public CustomObjectFactroy(Func&lt;T&gt; factoryMethod) { mFactoryMethod = factoryMethod; } public T Create() { return mFactoryMethod(); }} 包含创建方法的简易对象池123456789101112131415161718192021222324252627/// &lt;summary&gt;/// 简易对象池/// &lt;/summary&gt;/// &lt;typeparam name=\"T\"&gt;&lt;/typeparam&gt;public class SimpleObjectPool&lt;T&gt; : Pool&lt;T&gt;{ //重置方法 Action&lt;T&gt; mResetMethod; public SimpleObjectPool(Func&lt;T&gt; factoryMethod, Action&lt;T&gt; ResetMethod = null, int initCount = 0) { mFactory = new CustomObjectFactroy&lt;T&gt;(factoryMethod); mResetMethod = ResetMethod; for (int i = 0; i &lt; initCount; i++) { mCachedStack.Push(mFactory.Create()); } } public override bool Recycle(T obj) { if (mResetMethod != null) { mResetMethod(obj); } mCachedStack.Push(obj); return true; }} 复盘设计一个比较复杂的模块结构时,可以先设计一个接口(规范)。描述内容有什么 在mFractroy.Create和Recycle(回收)时，更偏向于自定义的操作 LevelManager123456789101112131415161718192021222324public class LevelManager : MonoBehaviour{ //可换成配置表 private static List&lt;string&gt; mLevelNames; public static int Index { get; set; } public static void Init(List&lt;string&gt; levelNames) { mLevelNames = levelNames; Index = 0; } public static void LoadCurrent() { SceneManager.LoadScene(mLevelNames[Index]); } public static void LoadNext() { Index++; if (Index &gt;= mLevelNames.Count) { Index = 0; } SceneManager.LoadScene(mLevelNames[Index]); }} 单元测试Probject内-&gt;右键-&gt;Create-&gt;Testing 创建相对应的c#文件(test模板)在Test Runner 界面内可以看到所有的测试脚本和对应的方法 类似于自己编写测试用例进行测试 Assert.AreEqual叫做断言，在开发大项目时非常有用的工具。测试通不通过取决于断言通不通过。","categories":[{"name":"框架篇","slug":"框架篇","permalink":"http://ysich.github.io/categories/%E6%A1%86%E6%9E%B6%E7%AF%87/"}],"tags":[{"name":"Manager 框架","slug":"Manager-框架","permalink":"http://ysich.github.io/tags/Manager-%E6%A1%86%E6%9E%B6/"}]},{"title":"游戏资源管理","slug":"游戏资源管理","date":"2023-01-16T04:56:44.000Z","updated":"2023-02-01T07:29:27.892Z","comments":true,"path":"2023/01/16/游戏资源管理/","link":"","permalink":"http://ysich.github.io/2023/01/16/%E6%B8%B8%E6%88%8F%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/","excerpt":"","text":"游戏资源管理游戏运行就是一个接一个资源的展示，如何管理好这些展示的资源让游戏能够流畅运行在开发中非常重要。需要在合理的地方调用、加载资源，资源空闲时对其进行卸载以减少内存占用。当内存超出预算可能导致游戏闪退，所以对资源的管理实际就是对内存的优化！ 本文争取一文搞懂资源管理。PS：可能和一个视频学完c++差不多(一个视频一个多月) TODOLIST： 分包策略 依赖处理 AssetBundle详细 热更 断点续传 代码热更新/热重载 Lua重新将函数指针赋值的策略 HybridCLR 资源包和资源区分开 一些资源策略 整包只有基础内容，后续章节热更的形式(大资源情况) YooAsset扩展篇 资源管理主要的需求有哪些？ 为开发与正式版本提供资源的加载和卸载 支持远程更新资源 做好版本、平台、渠道的资源管理 内存优化 Unity中的两种加载方式Resources 资源必选放在Resources文件夹下；有容量上限(大概是2G)；重复加载和重复卸载操作，Unity做了容错处理不会报错。不支持热更，只能打整包 适合放游戏的启动逻辑需要的资源 可能会延长游戏启动时间 AssetBundle 可以理解成Unity内的资源压缩包，有不同的压缩方式，解压速度和包体大小也不同(LZMA 和 LZ4)。 适合做热更，以减少包体的初始大小。 已加载的资源不允许重复加载，会报错。而使用AssetDatabase则不需要考虑。需要使用引用计数。 这里还有一些开源的资源管理系统，如YooAsset。 同步加载与异步加载同步加载同步加载在加载资源时，会阻塞线程。等加载逻辑完成后才继续执行后续逻辑（图灵机） 异步加载同步加载在加载较大资源时阻塞明显，造成卡顿。因为Unity中所有的渲染都是放在主线程中的，所以主线程阻塞非常致命不能进行任何玩家操作。 所以需要使用另外一种加载方式对较大资源进行加载。异步加载使用协程/线程进行加载逻辑，等资源加载完毕后触发资源加载后的callback。 在一些资源的加载会影响到游戏的展示时，可以在需要之前对资源进行预先加载，保证流程能够顺利进行。 异步加载的三种状态异步加载的逻辑由于执行完成的时间不确定，可能会导致其他逻辑的冲突。所以我们给异步加载按照逻辑划分状态，好让其他逻辑能够做区分，不同状态下处理相应的操作。 未加载 异步加载还没开始时可能需要准备的事情，比如资源包不在本地需要下载、解密、解压等等。 加载中 资源开始加载后，其他业务逻辑也加载了相同资源时，可以判断这个资源的状态。正在加载则不再进行加载前的准备操作，并把加载后的callback注册进去。 已加载 主要为加载后触发相应callback。 123456public enum LoaderState { NONE, // 默认 LOADING, // 加载中 FINISHED, // 完成 } 存在问题玩家在进入一个场景后，假设资源预加载需要10s，玩家却在未加载完资源的过程中退出场景。这时候就会引发资源状态的问题。 资源缓存池资源缓存池为统一存储和调用资源的地方。在加载资源后统一存入池子中，卸载时则将其从池子中删除。 加载时先判断池子中是否存在此资源包，如果已经加载过了直接则直接使用，未加载再进行加载逻辑。 以下内容主要以AssetBundle举例 123public class AssetBundlePool{ private Dictionary&lt;string,AssetBundleInfo&gt; m_LoadAssetBundle = new Dictionary&lt;string,AssetBundleInfo&gt;();} 引用计数基础概念引用技术的应用范围很广，很多引擎、框架、插件的底层都离不开引用计数。 简单思想：被引用+1，不被引用时-1，当为0时触发清空逻辑。 123456789101112131415161718192021public interface IRefCounter{ int RefCount { get; } void Retain(); void Release();}public class SimpleRC : IRefCounter{ public int RefCount { get; private set; } public void Retain() { RefCount++; } public void Release() { RefCount--; if (RefCount == 0){ OnZeroRef(); } } protected virtual void OnZeroRef(){}} 与资源管理结合的引用计数资源被使用时引用次数+1，资源解除使用时次数-1，当引用次数为0时则进行卸载逻辑。 1234567891011public class AssetBundleInfo{ private AssetBundle m_AssetBundle; //AB包引用 public AssetBundle AssetBundle { get { return m_AssetBundle; } } public int m_ReferencedCount; //引用计数 public AssetBundleInfo(AssetBundle assetBundle) { m_AssetBundle = assetBundle; m_ReferencedCount = 1; }} 与资源缓冲池结合的加载123456789101112131415161718192021222324252627public class AssetBundlePool{ private Dictionary&lt;string,AssetBundleInfo&gt; m_LoadAssetBundle = new Dictionary&lt;string,AssetBundleInfo&gt;(); public AssetBundle LoadAssetsFromAB(string abName) { AssetBundleInfo assetBundleInfo = null; if (m_LoadAssetBundle.TryGetValue(abName, out assetBundleInfo)) { //检查是否加载过 assetBundleInfo.m_ReferencedCount++;//这里可以使用封装好的引用计数，为了方便展示直接使用 } else { string loadPath = PathUnit.DataPath + PathUnit.ABRootPath + abName; var ab = AssetBundle.LoadFromFile(loadPath); if (ab is null) { Debug.Log(\"AB包加载失败！\"+ loadPath); } else { assetBundleInfo = new AssetBundleInfo(ab); m_LoadAssetBundle.Add(abName, assetBundleInfo); //assetBundleInfo.m_ReferencedCount++;这里不需要加了因为默认值为1 } } return assetBundleInfo.AssetBundle; }} 异步加载也是相同的操作，但有点不同。需要一个额外的队列记录加载中的文件。当加载中的文件又收到了加载请求时，则需要在列表中查找是否正在加载。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class AssetBundleCachePool{ public MonoBehaviour monoBehaviour; private Dictionary&lt;string, AssetBundleInfo&gt; m_LoadAssetBundle = new Dictionary&lt;string, AssetBundleInfo&gt;(); private Dictionary&lt;string, Action&lt;AssetBundle&gt;&gt; m_LoadingAssetBundle = new Dictionary&lt;string, Action&lt;AssetBundle&gt;&gt;(); public void LoadAssetsFormAbAsync(string abName, Action&lt;AssetBundle&gt; loadingABAction) { monoBehaviour.StartCoroutine(OnLoadAssetsFormAbAsync(abName, loadingABAction)); } IEnumerator OnLoadAssetsFormAbAsync(string abName, Action&lt;AssetBundle&gt; loadingABAction) { AssetBundleInfo assetBundleInfo = null; if (m_LoadAssetBundle.TryGetValue(abName,out assetBundleInfo)) { Debug.Log(\"已加载过\"); AssetBundle assetBundle = assetBundleInfo.AssetBundle; //引用计数+1 assetBundleInfo.m_ReferencedCount++; //触发回调 if (loadingABAction != null) { loadingABAction.Invoke(assetBundle); } yield break; } else { if (m_LoadingAssetBundle.TryGetValue(abName,out Action&lt;AssetBundle&gt; temploadingABAction)) { if (loadingABAction != null) { temploadingABAction += loadingABAction; } Debug.Log(\"正在被加载\"); yield break; } else { //这步需要执行，避免与其他逻辑冲突 m_LoadingAssetBundle.Add(abName, loadingABAction); string loadPath = PathUnit.DataPath + PathUnit.ABRootPath + abName; AssetBundleCreateRequest assetBundleCreateRequest = AssetBundle.LoadFromFileAsync(loadPath); AssetBundle resAB = assetBundleCreateRequest.assetBundle; if (resAB is null) { Debug.LogError(\"AB包不能存在\"); } else { assetBundleInfo = new AssetBundleInfo(resAB); m_LoadAssetBundle.Add(abName, assetBundleInfo); } //加载完成移除加载中列表 //避免啥异常状况，保险点！先判断是否存在 if (m_LoadingAssetBundle.ContainsKey(abName)) { Action&lt;AssetBundle&gt; action = m_LoadingAssetBundle[abName]; m_LoadingAssetBundle.Remove(abName); var callBackList = action.GetInvocationList(); foreach (Action&lt;AssetBundle&gt; callBack in callBackList) { callBack.Invoke(resAB); } } } } }} 与资源缓冲池结合的卸载为了保持平衡有了加载就一定会有卸载。但是在游戏中(特别是手游)卸载操作需要加上一些限制，因为在短时间内进行了大量资源的卸载增加了大量的IO操作也会造成卡顿（线程阻塞）的。🙂 所以我们的卸载操作需要与数量和时间扯上关系，在一定时间内只卸载一定数量的资源。 在引用计数中，如果引用计数为0则标记为可以开始卸载了。 1234567891011121314public class AssetBundleInfo{ public int ReferencedCount { get { return m_ReferencedCount; } set { m_ReferencedCount = value; if (m_ReferencedCount&lt;= 0) IsUnLoadFlag = true; else IsUnLoadFlag = false; } } public bool IsUnLoadFlag { get; private set; } private int m_ReferencedCount; //引用计数} 与时间挂钩与时间挂钩就需要有个地方能够一直统计和计算我们的时间并进行回收 123456public class ResourceManager{ void Update(){ }} 依赖本文之前的代码都是没有考虑依赖的，所以如果真的跑起来会发现计数会有偏差。 一个资源身上用到了别的AB包中的资源，这时候如果只加载自身的AB包，就会出现资源丢失的情况。这时候就需要把当前资源需要用到的依赖包一起加载出来。 但是我们又要怎么知道这个资源依赖于哪些包？ 这时候就需要用到Unity提供的AB包依赖文件来判断，后缀.manifest·。 Asset篇Asset什么是Asst？浅谈Assets——Unity资源映射 - UWA问答 | 博客 | 游戏及VR应用性能优化记录分享 | 侑虎科技 (uwa4d.com) Resources什么是Resources？Resources目录的优点与痛点 - UWA问答 | 博客 | 游戏及VR应用性能优化记录分享 | 侑虎科技 (uwa4d.com) AssetBundle什么是AssetBundle？AssetBundle的原理及最佳实践 - UWA问答 | 博客 | 游戏及VR应用性能优化记录分享 | 侑虎科技 (uwa4d.com) 热更篇Todo💁♀这部分内容写在别的地方，比较乱后续整理。","categories":[{"name":"资源管理篇","slug":"资源管理篇","permalink":"http://ysich.github.io/categories/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%AF%87/"}],"tags":[{"name":"资源管理","slug":"资源管理","permalink":"http://ysich.github.io/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"}]},{"title":"Lua基础语法","slug":"Lua基础语法","date":"2023-01-13T06:12:28.000Z","updated":"2023-01-17T06:16:15.830Z","comments":true,"path":"2023/01/13/Lua基础语法/","link":"","permalink":"http://ysich.github.io/2023/01/13/Lua%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","excerpt":"","text":"Lua基础语法注意点 循环用do，if语句用then，都使用end结尾 Lua不支持自减和自加操作，只能i=i+1，i=i-1 字符串的第一个位置是1不是0 技巧 Lua的字符串可以存储0x00，可以用字符串存储二进制流 注释 用--开头，来写一段单行注释 1-- 单行注释 用--[[开头，]]结尾，写一段多行注释。 1234--[[ 多行 注释]] 变量对一个变量进行赋值就相当于声明变量，与python相似 声明的变量默认为全局变量1a=1 同时给多个变量赋值，多重赋值 1a,b=1,2 局部变量1local b=2 nil类型没有被声明过的变量都是nil nil类型只有一个值，就是nil nil类似null类型 if(nil)为false number类型1234--支持十六进制表示方法a=0x11--输出为17--科学计数法a=2e10 string类型单引号、双引号1234a=\"daeqeq\"b='sdarrr'--转义字符\\nd=\"sdada\\nsdar\" 多行文本多行文本无法使用转义字符 1c=[[asdasfffrrqweqq]] 字符串连接字符串连接符号.. 1234a=\"daeqeq\"b='sdarrr'c=a..bprint(\"asdaf\"..\"as232\") 数值转字符串1tostring(10) 字符串转数值tonumber转换失败为nil 1tonumber(\"193\") 获取字符串长度123a=\"daeqeq\"print(#a)--等价于s:len() string类型类似char数组Lua中string类型 类似于C里的字符数组，可以包含任意数值包括0x00，可以存储二进制流因为都是原原本本存储 将ascii码转为字符串12s=string.char(65)s=string.char(0x30,0x31,0x32,0x33) 取出string中的某一位的ascii码1234n=string.byte(s,2)print(n)--语法糖，第一个到最后一个s:byte(1，-1) format调用c的接口 12local f=string.format(\"%d,%d\",1,2)print(f) function函数函数默认返回值为nil，没有任何返回值则为nil 1234567function function_name() --bodyend--函数名放前面f=function(...) --bodyend 123456function f(a,b,c) print(a,b,c) return aend--c没有传值则为nilprint(f(1,2))--1 函数可以返回多个值12345function f(a,b,c) return a,bendprint(f(1,2)) 多个返回值可以使用多重赋值语句12345function f(a,b,c) return a,bendlocal i,j=f(1,2) tabletable接口123table.insert(a,\"d\")--插入元素，末尾添加table.insert(a,2,\"d\")--插入元素，第二个位置，后续元素后移local s= table.remove(a,2)--移除第2个元素 table数字下标可以存所有东西(number,string,table,function) 12345a={1,\"ac\",{},function() end}a[5]=123 --可以直接添加一个元素print(a[1])--获取table长度print(#a) table字符串下标以字符为table的下标 12345678910a={ a=1, b=\"1234\", c=function() end, d=123123}print(a[\"a\"])--下标符合变量命名规范时print(a.a) 全局表_GLua内的所有全局变量都在_G这个table内 包括table.insert中的table(也是全局变量)也存储在_G中，insert为table的下标 1234print(_G[\"table\"][\"insert\"])--function: 0000000063be4590--输出值为一个函数--多文件调用知识 布尔型不等于在Lua中不等于使用~=表示 123456789a=trueb=falseprint(1&gt;2)print(1&lt;2)print(1&gt;=2)print(1&lt;=2)print(1==2)--不等于print(1~=2) 与或非只有false和nil表示假其他都表示真，包括0 123print(a and b)print(a or b)print(not a) and``or返回的并不完全是true和false，会直接返回a或者b的值，可以通过短路求值 只有not返回true和false 123456a=nil --真b=0 --假print(a and b) --nilprint(a or b) --0print(not a) --trueprint(b&gt;10 and \"yes\" or \"no\") --no 分支判断if语句1234567if 1&gt;10 then print(\"1&gt;10\")elseif 1&lt;10 then print(\"1&lt;10\")else print(\"no\")end 循环for循环1234567for i=1,10 do print(i)end--步长为2for i=1,10,2 do print(i)end 倒序循环123for i=10,1,-1 do print(i)end i在过程途中不能赋值，赋值了也没用 假如对i赋值会被认定为新建了局部变量 1234for i=10,1,-1 do print(i) local i=1end break通过break退出循环 1234for i=10,1,-1 do print(i) if i == 5 then break endend while循环12345n = 10while n&gt;1 do print(n) n = n - 1end repeat循环和while循环基本一致 多文件调用require和import的区别require实现换个目录后就需要对路径进行变更 个人理解：绝对路径 12345local MyClassBase = require(\"app.classes.MyClassBase\")local MyClass = class(\"MyClass\", MyClassBase)local Data1 = require(\"app.classes.data.Data1\")local Data2 = require(\"app.classes.data.Data2\") import实现在模块名前添加多个”.” ，这样 import() 会从更上层的目录开始查找模块。 个人理解：相对路径 12345local MyClassBase = import(\".MyClassBase\")local MyClass = class(\"MyClass\", MyClassBase)local Data1 = import(\".data.Data1\")local Data2 = import(\".data.Data2\") require运行指定多文件 末尾不带扩展名 12--.\\?lua 把文件名匹配到？内require(\"文件名\") 不同层架文件夹用.分隔 1require(\"文件夹名.文件名\") 只会运行一次 12345678--lua文件有可以return返回值local r = require('hello')--后面调用的都是前面返回的内容require('hello')require('hello')require('hello')require('hello')print(r) package.path12package.path=package.path..\";./path/?.lua\"require('hello2') 多次调用调用lua文件内的函数 123456789101112--hello.lualocal hello={}function hello.say() print(\"hello world\")end//通过返回tablereturn hello--test.lualocal test=require('hello')//通过table内的方法调用test.say() 迭代table1234t={\"a\",\"b\",\"c\",\"d\"}for i=1,#t,do print(i,t[i])end 迭代器ipairs纯数字连续下标可以用 12345t={\"a\",\"b\",\"c\",\"d\"}--下标给i，值给jfor i,j in ipairs(t) do print(i,j)end 1234567891011t={ [1]=\"a\", [2]=\"b\", [3]=\"c\", [5]=\"d\"}--下标给i，值给jfor i,j in ipairs(t) do --只能遍历到1到3，不连续的后面遍历不到 print(i,j)end 迭代器pairs可以遍历所有下标 pairs内部调用的是next函数 1234567891011t={ [1]=\"a\", [2]=\"b\", [3]=\"c\", [5]=\"d\"}--下标给i，值给jfor i,j in pairs(t) do --只能遍历到1到3，不连续的后面遍历不到 print(i,j)end 1234567891011t={ apple=\"a\", banana=\"b\", eraser=\"c\", water=\"d\"}--下标给i，值给jfor i,j in pairs(t) do --只能遍历到1到3，不连续的后面遍历不到 print(i,j)end 元表、元方法语法糖12345678t={ a=0, add=function(tab,num) tab.a=tab.a+num end}--类似于面向对象的方法调用t:add(10)--等价于t.add(t,10) 面向对象123456789101112131415161718192021222324--对象名bag={}bagmt={ --装入东西的函数 put=function(t,item) table.insert(t.items,item) end, take=function(t) return table.remove(t) end, list=function(t) return table.concat(t.items,\",\") end}bagmt[\"__index\"]=bagmt--构造函数function bag.new() local t={ items={} } setmetatable(t,bagmt) return tend 协程coroutine一个lua虚拟机里只能有一个线程 coroutine.create 可创建一个协程返回值为 thread 类型 123456local co=coroutine.create( function() print(\"hello world!\") end )","categories":[{"name":"编程语言篇","slug":"编程语言篇","permalink":"http://ysich.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%AF%87/"}],"tags":[{"name":"Lua","slug":"Lua","permalink":"http://ysich.github.io/tags/Lua/"}]}],"categories":[{"name":"框架篇","slug":"框架篇","permalink":"http://ysich.github.io/categories/%E6%A1%86%E6%9E%B6%E7%AF%87/"},{"name":"资源管理篇","slug":"资源管理篇","permalink":"http://ysich.github.io/categories/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%AF%87/"},{"name":"编程语言篇","slug":"编程语言篇","permalink":"http://ysich.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%AF%87/"}],"tags":[{"name":"CallBack","slug":"CallBack","permalink":"http://ysich.github.io/tags/CallBack/"},{"name":"Manager 框架","slug":"Manager-框架","permalink":"http://ysich.github.io/tags/Manager-%E6%A1%86%E6%9E%B6/"},{"name":"资源管理","slug":"资源管理","permalink":"http://ysich.github.io/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"},{"name":"Lua","slug":"Lua","permalink":"http://ysich.github.io/tags/Lua/"}]}