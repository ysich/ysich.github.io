{"meta":{"title":"ysich-game-blog","subtitle":"","description":"","author":"ysich","url":"http://ysich.github.io","root":"/"},"pages":[],"posts":[{"title":"游戏资源管理","slug":"游戏资源管理","date":"2023-01-16T04:56:44.000Z","updated":"2023-01-16T05:00:11.899Z","comments":true,"path":"2023/01/16/游戏资源管理/","link":"","permalink":"http://ysich.github.io/2023/01/16/%E6%B8%B8%E6%88%8F%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/","excerpt":"","text":"游戏资源管理游戏运行就是一个接一个资源的展示，如何管理好这些展示的资源让游戏能够流畅运行在开发中非常重要。需要在合理的地方调用、加载资源，资源空闲时对其进行卸载以减少内存占用。当内存超出预算可能导致游戏闪退，所以对资源的管理实际就是对内存的优化！ 本文争取一文搞懂资源管理。PS：可能和一个视频学完c++差不多(一个视频一个多月) TODOLIST： 分包策略 依赖处理 AssetBundle详细 热更 断点续传 代码热更新/热重载 Lua重新将函数指针赋值的策略 HybridCLR 资源包和资源区分开 一些资源策略 整包只有基础内容，后续章节热更的形式(大资源情况) YooAsset扩展篇 资源管理主要的需求有哪些？ 为开发与正式版本提供资源的加载和卸载 支持远程更新资源 做好版本、平台、渠道的资源管理 内存优化 Unity中的两种加载方式Resources 资源必选放在Resources文件夹下；有容量上限(大概是2G)；重复加载和重复卸载操作，Unity做了容错处理不会报错。不支持热更，只能打整包 适合放游戏的启动逻辑需要的资源 可能会延长游戏启动时间 AssetBundle 可以理解成Unity内的资源压缩包，有不同的压缩方式，解压速度和包体大小也不同(LZMA 和 LZ4)。 适合做热更，以减少包体的初始大小。 已加载的资源不允许重复加载，会报错。而使用AssetDatabase则不需要考虑。需要使用引用计数。 这里还有一些开源的资源管理系统，如YooAsset。 同步加载与异步加载同步加载同步加载在加载资源时，会阻塞线程。等加载逻辑完成后才继续执行后续逻辑（图灵机） 异步加载同步加载在加载较大资源时阻塞明显，造成卡顿。因为Unity中所有的渲染都是放在主线程中的，所以主线程阻塞非常致命不能进行任何玩家操作。 所以需要使用另外一种加载方式对较大资源进行加载。异步加载使用协程/线程进行加载逻辑，等资源加载完毕后触发资源加载后的callback。 在一些资源的加载会影响到游戏的展示时，可以在需要之前对资源进行预先加载，保证流程能够顺利进行。 异步加载的三种状态异步加载的逻辑由于执行完成的时间不确定，可能会导致其他逻辑的冲突。所以我们给异步加载按照逻辑划分状态，好让其他逻辑能够做区分，不同状态下处理相应的操作。 未加载 异步加载还没开始时可能需要准备的事情，比如资源包不在本地需要下载、解密、解压等等。 加载中 资源开始加载后，其他业务逻辑也加载了相同资源时，可以判断这个资源的状态。正在加载则不再进行加载前的准备操作，并把加载后的callback注册进去。 已加载 主要为加载后触发相应callback。 123456public enum LoaderState { NONE, // 默认 LOADING, // 加载中 FINISHED, // 完成 } 存在问题玩家在进入一个场景后，假设资源预加载需要10s，玩家却在未加载完资源的过程中退出场景。这时候就会引发资源状态的问题。 资源缓存池资源缓存池为统一存储和调用资源的地方。在加载资源后统一存入池子中，卸载时则将其从池子中删除。 加载时先判断池子中是否存在此资源包，如果已经加载过了直接则直接使用，未加载再进行加载逻辑。 以下内容主要以AssetBundle举例 123public class AssetBundlePool{ private Dictionary&lt;string,AssetBundleInfo&gt; m_LoadAssetBundle = new Dictionary&lt;string,AssetBundleInfo&gt;();} 引用计数基础概念引用技术的应用范围很广，很多引擎、框架、插件的底层都离不开引用计数。 简单思想：被引用+1，不被引用时-1，当为0时触发清空逻辑。 123456789101112131415161718192021public interface IRefCounter{ int RefCount { get; } void Retain(); void Release();}public class SimpleRC : IRefCounter{ public int RefCount { get; private set; } public void Retain() { RefCount++; } public void Release() { RefCount--; if (RefCount == 0){ OnZeroRef(); } } protected virtual void OnZeroRef(){}} 与资源管理结合的引用计数资源被使用时引用次数+1，资源解除使用时次数-1，当引用次数为0时则进行卸载逻辑。 1234567891011public class AssetBundleInfo{ private AssetBundle m_AssetBundle; //AB包引用 public AssetBundle AssetBundle { get { return m_AssetBundle; } } public int m_ReferencedCount; //引用计数 public AssetBundleInfo(AssetBundle assetBundle) { m_AssetBundle = assetBundle; m_ReferencedCount = 1; }} 与资源缓冲池结合的加载123456789101112131415161718192021222324252627public class AssetBundlePool{ private Dictionary&lt;string,AssetBundleInfo&gt; m_LoadAssetBundle = new Dictionary&lt;string,AssetBundleInfo&gt;(); public AssetBundle LoadAssetsFromAB(string abName) { AssetBundleInfo assetBundleInfo = null; if (m_LoadAssetBundle.TryGetValue(abName, out assetBundleInfo)) { //检查是否加载过 assetBundleInfo.m_ReferencedCount++;//这里可以使用封装好的引用计数，为了方便展示直接使用 } else { string loadPath = PathUnit.DataPath + PathUnit.ABRootPath + abName; var ab = AssetBundle.LoadFromFile(loadPath); if (ab is null) { Debug.Log(\"AB包加载失败！\"+ loadPath); } else { assetBundleInfo = new AssetBundleInfo(ab); m_LoadAssetBundle.Add(abName, assetBundleInfo); //assetBundleInfo.m_ReferencedCount++;这里不需要加了因为默认值为1 } } return assetBundleInfo.AssetBundle; }} 异步加载也是相同的操作，但有点不同。需要一个额外的队列记录加载中的文件。当加载中的文件又收到了加载请求时，则需要在列表中查找是否正在加载。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class AssetBundleCachePool{ public MonoBehaviour monoBehaviour; private Dictionary&lt;string, AssetBundleInfo&gt; m_LoadAssetBundle = new Dictionary&lt;string, AssetBundleInfo&gt;(); private Dictionary&lt;string, Action&lt;AssetBundle&gt;&gt; m_LoadingAssetBundle = new Dictionary&lt;string, Action&lt;AssetBundle&gt;&gt;(); public void LoadAssetsFormAbAsync(string abName, Action&lt;AssetBundle&gt; loadingABAction) { monoBehaviour.StartCoroutine(OnLoadAssetsFormAbAsync(abName, loadingABAction)); } IEnumerator OnLoadAssetsFormAbAsync(string abName, Action&lt;AssetBundle&gt; loadingABAction) { AssetBundleInfo assetBundleInfo = null; if (m_LoadAssetBundle.TryGetValue(abName,out assetBundleInfo)) { Debug.Log(\"已加载过\"); AssetBundle assetBundle = assetBundleInfo.AssetBundle; //引用计数+1 assetBundleInfo.m_ReferencedCount++; //触发回调 if (loadingABAction != null) { loadingABAction.Invoke(assetBundle); } yield break; } else { if (m_LoadingAssetBundle.TryGetValue(abName,out Action&lt;AssetBundle&gt; temploadingABAction)) { if (loadingABAction != null) { temploadingABAction += loadingABAction; } Debug.Log(\"正在被加载\"); yield break; } else { //这步需要执行，避免与其他逻辑冲突 m_LoadingAssetBundle.Add(abName, loadingABAction); string loadPath = PathUnit.DataPath + PathUnit.ABRootPath + abName; AssetBundleCreateRequest assetBundleCreateRequest = AssetBundle.LoadFromFileAsync(loadPath); AssetBundle resAB = assetBundleCreateRequest.assetBundle; if (resAB is null) { Debug.LogError(\"AB包不能存在\"); } else { assetBundleInfo = new AssetBundleInfo(resAB); m_LoadAssetBundle.Add(abName, assetBundleInfo); } //加载完成移除加载中列表 //避免啥异常状况，保险点！先判断是否存在 if (m_LoadingAssetBundle.ContainsKey(abName)) { Action&lt;AssetBundle&gt; action = m_LoadingAssetBundle[abName]; m_LoadingAssetBundle.Remove(abName); var callBackList = action.GetInvocationList(); foreach (Action&lt;AssetBundle&gt; callBack in callBackList) { callBack.Invoke(resAB); } } } } }} 与资源缓冲池结合的卸载为了保持平衡有了加载就一定会有卸载。但是在游戏中(特别是手游)卸载操作需要加上一些限制，因为在短时间内进行了大量资源的卸载增加了大量的IO操作也会造成卡顿（线程阻塞）的。🙂 所以我们的卸载操作需要与数量和时间扯上关系，在一定时间内只卸载一定数量的资源。 在引用计数中，如果引用计数为0则标记为可以开始卸载了。 1234567891011121314public class AssetBundleInfo{ public int ReferencedCount { get { return m_ReferencedCount; } set { m_ReferencedCount = value; if (m_ReferencedCount&lt;= 0) IsUnLoadFlag = true; else IsUnLoadFlag = false; } } public bool IsUnLoadFlag { get; private set; } private int m_ReferencedCount; //引用计数} 与时间挂钩与时间挂钩就需要有个地方能够一直统计和计算我们的时间并进行回收 123456public class ResourceManager{ void Update(){ }} 依赖本文之前的代码都是没有考虑依赖的，所以如果真的跑起来会发现计数会有偏差。 一个资源身上用到了别的AB包中的资源，这时候如果只加载自身的AB包，就会出现资源丢失的情况。这时候就需要把当前资源需要用到的依赖包一起加载出来。 但是我们又要怎么知道这个资源依赖于哪些包？ 这时候就需要用到Unity提供的AB包依赖文件来判断，后缀.manifest·。 AssetBundle篇Todo💁♀这部分以前的笔记找不到了，先欠着。 热更篇Todo💁♀这部分内容写在别的地方，比较乱后续整理。","categories":[],"tags":[{"name":"资源管理","slug":"资源管理","permalink":"http://ysich.github.io/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"}]},{"title":"Lua入门","slug":"Lua入门","date":"2023-01-13T06:12:28.000Z","updated":"2023-01-14T13:05:50.879Z","comments":true,"path":"2023/01/13/Lua入门/","link":"","permalink":"http://ysich.github.io/2023/01/13/Lua%E5%85%A5%E9%97%A8/","excerpt":"","text":"Lua大纲注意点 循环用do，if语句用then，都使用end结尾 Lua不支持自减和自加操作，只能i=i+1，i=i-1 字符串的第一个位置是1不是0 技巧 Lua的字符串可以存储0x00，可以用字符串存储二进制流 注释 用--开头，来写一段单行注释 1-- 单行注释 用--[[开头，]]结尾，写一段多行注释。 1234--[[ 多行 注释]] 变量对一个变量进行赋值就相当于声明变量，与python相似 声明的变量默认为全局变量1a=1 同时给多个变量赋值，多重赋值 1a,b=1,2 局部变量1local b=2 nil类型没有被声明过的变量都是nil nil类型只有一个值，就是nil nil类似null类型 if(nil)为false number类型1234--支持十六进制表示方法a=0x11--输出为17--科学计数法a=2e10 string类型单引号、双引号1234a=\"daeqeq\"b='sdarrr'--转义字符\\nd=\"sdada\\nsdar\" 多行文本多行文本无法使用转义字符 1c=[[asdasfffrrqweqq]] 字符串连接字符串连接符号.. 1234a=\"daeqeq\"b='sdarrr'c=a..bprint(\"asdaf\"..\"as232\") 数值转字符串1tostring(10) 字符串转数值tonumber转换失败为nil 1tonumber(\"193\") 获取字符串长度123a=\"daeqeq\"print(#a)--等价于s:len() string类型类似char数组Lua中string类型 类似于C里的字符数组，可以包含任意数值包括0x00，可以存储二进制流因为都是原原本本存储 将ascii码转为字符串12s=string.char(65)s=string.char(0x30,0x31,0x32,0x33) 取出string中的某一位的ascii码1234n=string.byte(s,2)print(n)--语法糖，第一个到最后一个s:byte(1，-1) format调用c的接口 12local f=string.format(\"%d,%d\",1,2)print(f) function函数函数默认返回值为nil，没有任何返回值则为nil 1234567function function_name() --bodyend--函数名放前面f=function(...) --bodyend 123456function f(a,b,c) print(a,b,c) return aend--c没有传值则为nilprint(f(1,2))--1 函数可以返回多个值12345function f(a,b,c) return a,bendprint(f(1,2)) 多个返回值可以使用多重赋值语句12345function f(a,b,c) return a,bendlocal i,j=f(1,2) tabletable接口123table.insert(a,\"d\")--插入元素，末尾添加table.insert(a,2,\"d\")--插入元素，第二个位置，后续元素后移local s= table.remove(a,2)--移除第2个元素 table数字下标可以存所有东西(number,string,table,function) 12345a={1,\"ac\",{},function() end}a[5]=123 --可以直接添加一个元素print(a[1])--获取table长度print(#a) table字符串下标以字符为table的下标 12345678910a={ a=1, b=\"1234\", c=function() end, d=123123}print(a[\"a\"])--下标符合变量命名规范时print(a.a) 全局表_GLua内的所有全局变量都在_G这个table内 包括table.insert中的table(也是全局变量)也存储在_G中，insert为table的下标 1234print(_G[\"table\"][\"insert\"])--function: 0000000063be4590--输出值为一个函数--多文件调用知识 布尔型不等于在Lua中不等于使用~=表示 123456789a=trueb=falseprint(1&gt;2)print(1&lt;2)print(1&gt;=2)print(1&lt;=2)print(1==2)--不等于print(1~=2) 与或非只有false和nil表示假其他都表示真，包括0 123print(a and b)print(a or b)print(not a) and``or返回的并不完全是true和false，会直接返回a或者b的值，可以通过短路求值 只有not返回true和false 123456a=nil --真b=0 --假print(a and b) --nilprint(a or b) --0print(not a) --trueprint(b&gt;10 and \"yes\" or \"no\") --no 分支判断if语句1234567if 1&gt;10 then print(\"1&gt;10\")elseif 1&lt;10 then print(\"1&lt;10\")else print(\"no\")end 循环for循环1234567for i=1,10 do print(i)end--步长为2for i=1,10,2 do print(i)end 倒序循环123for i=10,1,-1 do print(i)end i在过程途中不能赋值，赋值了也没用 假如对i赋值会被认定为新建了局部变量 1234for i=10,1,-1 do print(i) local i=1end break通过break退出循环 1234for i=10,1,-1 do print(i) if i == 5 then break endend while循环12345n = 10while n&gt;1 do print(n) n = n - 1end repeat循环和while循环基本一致 多文件调用require和import的区别require实现换个目录后就需要对路径进行变更 个人理解：绝对路径 12345local MyClassBase = require(\"app.classes.MyClassBase\")local MyClass = class(\"MyClass\", MyClassBase)local Data1 = require(\"app.classes.data.Data1\")local Data2 = require(\"app.classes.data.Data2\") import实现在模块名前添加多个”.” ，这样 import() 会从更上层的目录开始查找模块。 个人理解：相对路径 12345local MyClassBase = import(\".MyClassBase\")local MyClass = class(\"MyClass\", MyClassBase)local Data1 = import(\".data.Data1\")local Data2 = import(\".data.Data2\") require运行指定多文件 末尾不带扩展名 12--.\\?lua 把文件名匹配到？内require(\"文件名\") 不同层架文件夹用.分隔 1require(\"文件夹名.文件名\") 只会运行一次 12345678--lua文件有可以return返回值local r = require('hello')--后面调用的都是前面返回的内容require('hello')require('hello')require('hello')require('hello')print(r) package.path12package.path=package.path..\";./path/?.lua\"require('hello2') 多次调用调用lua文件内的函数 123456789101112--hello.lualocal hello={}function hello.say() print(\"hello world\")end//通过返回tablereturn hello--test.lualocal test=require('hello')//通过table内的方法调用test.say() 迭代table1234t={\"a\",\"b\",\"c\",\"d\"}for i=1,#t,do print(i,t[i])end 迭代器ipairs纯数字连续下标可以用 12345t={\"a\",\"b\",\"c\",\"d\"}--下标给i，值给jfor i,j in ipairs(t) do print(i,j)end 1234567891011t={ [1]=\"a\", [2]=\"b\", [3]=\"c\", [5]=\"d\"}--下标给i，值给jfor i,j in ipairs(t) do --只能遍历到1到3，不连续的后面遍历不到 print(i,j)end 迭代器pairs可以遍历所有下标 pairs内部调用的是next函数 1234567891011t={ [1]=\"a\", [2]=\"b\", [3]=\"c\", [5]=\"d\"}--下标给i，值给jfor i,j in pairs(t) do --只能遍历到1到3，不连续的后面遍历不到 print(i,j)end 1234567891011t={ apple=\"a\", banana=\"b\", eraser=\"c\", water=\"d\"}--下标给i，值给jfor i,j in pairs(t) do --只能遍历到1到3，不连续的后面遍历不到 print(i,j)end 元表、元方法语法糖12345678t={ a=0, add=function(tab,num) tab.a=tab.a+num end}--类似于面向对象的方法调用t:add(10)--等价于t.add(t,10) 面向对象123456789101112131415161718192021222324--对象名bag={}bagmt={ --装入东西的函数 put=function(t,item) table.insert(t.items,item) end, take=function(t) return table.remove(t) end, list=function(t) return table.concat(t.items,\",\") end}bagmt[\"__index\"]=bagmt--构造函数function bag.new() local t={ items={} } setmetatable(t,bagmt) return tend 协程coroutine一个lua虚拟机里只能有一个线程 coroutine.create 可创建一个协程返回值为 thread 类型 123456local co=coroutine.create( function() print(\"hello world!\") end )","categories":[],"tags":[{"name":"Lua","slug":"Lua","permalink":"http://ysich.github.io/tags/Lua/"}]}],"categories":[],"tags":[{"name":"资源管理","slug":"资源管理","permalink":"http://ysich.github.io/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"},{"name":"Lua","slug":"Lua","permalink":"http://ysich.github.io/tags/Lua/"}]}