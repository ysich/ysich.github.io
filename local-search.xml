<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>AUP异步上传管线</title>
    <link href="/2023/10/27/AUP%E5%BC%82%E6%AD%A5%E4%B8%8A%E4%BC%A0%E7%AE%A1%E7%BA%BF/"/>
    <url>/2023/10/27/AUP%E5%BC%82%E6%AD%A5%E4%B8%8A%E4%BC%A0%E7%AE%A1%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="AUP异步上传管线"><a href="#AUP异步上传管线" class="headerlink" title="AUP异步上传管线"></a>AUP异步上传管线</h1><p>Async Upload Pipeline</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzkyMTM5Mjg3NQ==&amp;mid=2247535763&amp;idx=1&amp;sn=dda4a1f7fc62e0a23aeef3f48af9d9b8&amp;source=41#wechat_redirect">优化加载性能：了解异步上传管线AUP (qq.com)</a></p><h4 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h4><p>在同步上传管线中，Unity必须在单个帧中同时加载纹理或网格的元数据、纹理的每个Texel或网格的每个顶点数据。而在异步上传管线中，Unity则在单个帧中<strong>仅加载元数据</strong>，并在后续帧中将二进制数据流式传输到GPU。</p><h5 id="同步上传管线"><a href="#同步上传管线" class="headerlink" title="同步上传管线"></a>同步上传管线</h5><p>在项目构建时，Unity会将同步加载的网格或纹理的标头数据和二进制数据都写入<strong>同一.res文件</strong>（res即Resource）。在运行时，当程序同步加载纹理或网格时，Unity将该纹理或网格的标头数据和二进制数据从.res文件（磁盘中）加载到内存（RAM）中。当所有数据都位于内存中时，Unity随后将二进制数据上传到GPU（Draw Call前）。<strong>加载和上传操作都发生在主线程上的单个帧中</strong>。</p><h5 id="异步上传管线"><a href="#异步上传管线" class="headerlink" title="异步上传管线"></a>异步上传管线</h5><p>在项目构建时，Unity会将标头数据写入到一个.res文件，而将二进制数据写入到另一个.resS文件（S应该指Streaming）。在运行时，当程序异步加载纹理或网格时，Unity将标头数据从.res文件（磁盘中）加载到内存（RAM）中。当标头数据位于内存中时，Unity随后使用<strong>固定大小的环形缓冲区</strong>（一块可配置大小的缓冲区）将二进制数据从.resS文件（磁盘中）流式传输到GPU。<strong>Unity使用多个线程通过几帧流式传输二进制数据。</strong></p><p>注意：使用AUP时，AB包必须是LZ4压缩。</p><p>在构建过程中，纹理或网格对象会写入序列化文件，大型二进制数据的纹理或顶点数据会写入附带的.resS文件，这样的配置应用于玩家数据和资源包。</p><p>AUP可以加载纹理和网格，但可读写纹理、可读写网格和压缩网格都不适用于AUP。</p><p>AUP对每个指令会执行以下过程：</p><ol><li>等待环形缓冲区中所需内存可用。</li><li>从源.resS文件中读取数据到分配的内存。</li><li>执行后期处理过程，例如：纹理解压、网格碰撞生成、每个平台的修复等。</li><li>以时间切片的方式在渲染线程进行上传。</li><li>释放环形缓冲区内存。</li></ol><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><h5 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h5><p>QualitySettings.asyncUploadTimeSlice</p><p>设定渲染线程中每帧上传纹理和网格数据所用的时间总量，以毫秒为单位。</p><p>当异步加载操作进行时，该系统会执行二个该参数大小的时间切片，该参数的默认值为2毫秒。</p><p>如果该值太小，可能会在纹理/网格的GPU上传时遇到瓶颈。而该值太大的话，会造成帧率陡降。</p><p>如果上传时间设定的太长，那么留给渲染的时间就会变少。</p><h5 id="缓冲区大小"><a href="#缓冲区大小" class="headerlink" title="缓冲区大小"></a>缓冲区大小</h5><p>QualitySettings.asyncUploadBufferSize</p><p>该参数设定环形缓冲区的大小，以MB为单位。当上传时间切片在每帧发生时，要确保在环形缓冲区有足够的数据利用整个时间切片。</p><p>如果环形缓冲区太小，上传时间切片会被缩短。</p><p>当纹理大小超过缓冲区大小时，会先消耗完缓冲区剩余大小，再重新分配至纹理所需大小，待上传完成后缓冲区再调整至设置大小。</p><h5 id="QualitySettings-asyncUploadPersistentBuffer"><a href="#QualitySettings-asyncUploadPersistentBuffer" class="headerlink" title="QualitySettings.asyncUploadPersistentBuffer"></a>QualitySettings.asyncUploadPersistentBuffer</h5><p>它决定在完成所有待定读取工作时，是否释放上传时使用的环形缓冲区。</p><p>分配和释放该缓冲区经常会产生内存碎片，因此通常将其保留为默认值True。如果需要在未加载时回收内存，可以将该值设为False。</p><h4 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h4><ul><li>选择不会导致掉帧的最大QualitySettings.asyncUploadTimeSlice。</li><li>在加载界面时，可以临时提高QualitySettings.asyncUploadTimeSlice。</li><li>使用性能分析器来检查时间切片的利用率。时间切片在性能分析器中会显示为AsyncUploadManager.AsyncResourceUpload。如果时间切片没有完全利用的话，就提高QualitySettings.asyncUploadBufferSize。</li><li>使用更大的QualitySettings.asyncUploadBufferSize会提高加载速度，所以如果内存足够的话，请将其从16MB提高至32MB。</li><li>将QualitySettings.asyncUploadPersistentBuffer保留为true，除非有理由在未加载时减少运行时内存的使用。</li></ul>]]></content>
    
    
    <categories>
      
      <category>性能优化篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity性能优化</title>
    <link href="/2023/09/08/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2023/09/08/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity性能优化"><a href="#Unity性能优化" class="headerlink" title="Unity性能优化"></a>Unity性能优化</h1><h2 id="第1节-静态资源优化"><a href="#第1节-静态资源优化" class="headerlink" title="第1节 静态资源优化"></a>第1节 静态资源优化</h2><p>在Unity中的资源都存放在asset内，分为了外部导入资源和内部创建资源，无论是哪种资源都涉及到导入问题。在不同平台上合理的资源导入设置能够带来更高的效率。 </p><p>Unity在UPR下也提供了asset检测工具<code>Asset Check</code>。 </p><h3 id="Audio"><a href="#Audio" class="headerlink" title="Audio"></a>Audio</h3><p>当实现静音功能时，不要简单设置音量为0，应该销毁AudioSource组件，将音频从内存中卸载。</p><h4 id="Force-To-Mono单声道"><a href="#Force-To-Mono单声道" class="headerlink" title="Force To Mono单声道"></a>Force To Mono单声道</h4><p>一些双声道资源两个声道的声音一致，或移动设备下听不出区别则可以开启来减少内存。</p><h4 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h4><ul><li>PCM ：提供高品质但牺牲文件大小最适合使用在很短的音效上。</li><li>ADPCM： 这种格式适用于大量音效上如脚步爆破和武器，它比PCM小3.5倍但CPU使用率远低于Vorbis/MP3</li><li>Vorbis/MP3： 比PCM小但是品质比PCM低，比ADPCM消耗更多CPU。但大多数情况下我们还是应该使用这种格式，这个选择还多了个Quality可以调节质量改变文件大小 （Quality测试1和100对内存影响并不大）</li></ul><p>我们应该尽可能使用未压缩的<code>WAV格式文件</code>作为源文件。通过不同平台支持的压缩格式进行压缩。</p><p>大部分移动平台下使用<code>Vorbis格式</code>进行压缩，如果音频不进行循环还可以使用<code>mp3格式</code>。</p><p>一些操作系统对特定的压缩格式有特定的优化，比如ios下的<code>mp3格式</code>。</p><p>对一些简短常用的音效还可以使用<code>ADPCM格式</code>，可能压缩比不是最好的但是在播放时解码速度快。</p><h4 id="采样率"><a href="#采样率" class="headerlink" title="采样率"></a>采样率</h4><p>我们还需要关注音频的采样率，采样率高音频大小也会随之变大。</p><p>在移动平台下一般设置为22050Hz，经验之谈。在移动平台下一般都会选择对音质影响最小的最低设置。</p><p>在<code>Sample Rate Setting</code>中选择复写采样频率。</p><h4 id="加载类型"><a href="#加载类型" class="headerlink" title="加载类型"></a>加载类型</h4><p>不同的音乐类型推荐使用不同的加载类型。<code>Load Type</code>。</p><ul><li>Decompress On Load   <strong>加载时解压缩</strong><ul><li>音频压缩后大小小于200kb</li><li>注：在加载时解压缩Vorbis编码的声音比使用它压缩大约多十倍的内存（对于ADPCM编码大约是3.5倍</li></ul></li><li>Compressed In Memory   <strong>:压缩在内存中</strong><ul><li>音频压缩后大小大于200kb</li><li>在播放时解压缩，解压缩在混音器线程上发生，并可在Profiler窗口的音频面板中的“DSP CPU”部分进行监视。</li></ul></li><li>Streaming<ul><li>适合背景音，较长较大的音频。通过流加载，避免加载卡顿。</li><li>注：即使没有加载任何音频数据，流式片段也会有大约200KB的过载。</li></ul></li></ul><h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><p>尽可能使用fbx格式。需要先对dcc工具进行导出设置。 </p><p>优化原始导入模型文件，删除不需要的数据</p><ul><li>统一单位</li><li>导出的网格必须是多边形拓扑，不能是贝塞尔曲线、样条曲线、NURBS、NURMS、曲面细分等</li><li>烘培Deformers,在导出之前，确保变形体被烘培到网格模型上，如骨骼形变烘培到蒙皮权重上</li><li>不建议模型使用的纹理随模型导出<ul><li>会降低unity导入的模型导入效率，还会影响资源管理</li></ul></li><li>如果需要导入Blend shape normals时，必须指定光滑组Smooth groups<ul><li>不是任何时候都需要导出光滑组，因为会损失细节</li></ul></li><li>建议导出时不携带摄像机、灯光、材质等场景信息<ul><li>因为和unity的设置都不同，造成冗余</li></ul></li></ul><p><img src="https://github.com/lwwhb/Unity2022_SUNTAIL_Stylized_Fantasy_Village_Optimization/blob/main/Documents/Pics/2.png?raw=true" alt="2.png"></p><h4 id="原始模型影响性能点"><a href="#原始模型影响性能点" class="headerlink" title="原始模型影响性能点"></a>原始模型影响性能点</h4><p>前期尽量避免，后期比较难修改。</p><ul><li>最小化面数，不需要微三角面，三角面尽量分布均匀<ul><li>微三角面指一个三角面只包含几个像素</li></ul></li><li>合理的拓扑结果与平滑组，尽可能是闭包<ul><li>如果是几个单独面没有封闭，只是看起来是封闭的。那在unity烘焙的时候就会容易出错。</li></ul></li><li>尽量少的材质个数<ul><li>材质数增多容易造成shader和贴图的爆炸</li></ul></li><li>尽可能少的蒙皮网格<ul><li>尽量用相同的</li></ul></li><li>尽可能少的骨骼数量<ul><li>过多骨骼动画容易造成CPU和GPU的性能瓶颈</li></ul></li><li>FK与IK节点没分离，IK节点没删除</li></ul><h4 id="模型优化"><a href="#模型优化" class="headerlink" title="模型优化"></a>模型优化</h4><ul><li>尽可能的将网格合并到一起</li><li>尽可能使用共享材质</li><li>不要使用网格碰撞体</li><li>不必要不要开启网格读写</li><li>使用合理的LOD级别</li><li>Skin Weights受骨骼影响个过多</li><li>合理压缩网格</li><li>不需要rigs和BlendShapes尽量关闭</li><li>如果可能，禁用法线或切线</li><li>多套模型</li></ul><h4 id="Unity导入设置"><a href="#Unity导入设置" class="headerlink" title="Unity导入设置"></a>Unity导入设置</h4><h5 id="模型设置"><a href="#模型设置" class="headerlink" title="模型设置"></a>模型设置</h5><ul><li>Mesh Compression<ul><li>默认不开启，当确保网格正确时可以开启，可以让网格占用空间变小，但是运行时占用内存不变。</li><li>开启后需要检查一遍，闭包比开放的模型出现概率更小</li></ul></li><li>Read/Write<ul><li>会多复制一份副本，一份副本在内存中，一份副本在显存中。需要动态修改时才开启。</li></ul></li><li>Optimize Mesh和Generate Colliders<ul><li>做网格级碰撞用的</li></ul></li></ul><h3 id="Texture"><a href="#Texture" class="headerlink" title="Texture"></a>Texture</h3><h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><p>应用于模型表面用于增加细节的位图图像。 纹理需要通过材质着色器映射才能到模型表面</p><h5 id="纹理类型"><a href="#纹理类型" class="headerlink" title="纹理类型"></a>纹理类型</h5><ul><li><strong>Default：</strong>默认的纹理类型格式</li><li><strong>Normal map：</strong>法线贴图，可将颜色通道转换为适合实时法线贴图格式</li><li><strong>Editor GUI and Legacy GUI：</strong>在编辑器GUI控件上使用纹理请选择此类型</li><li><strong>Sprite(2D and UI)：</strong>在2D游戏中使用的精灵(Sprite)或UGUI使用的纹理请选择此类型</li><li><strong>Cursor：</strong>鼠标光标自定义纹理类型</li><li><strong>Cookie：</strong>用于光照Cookie剪影类型的纹理</li><li><strong>Lightmap：</strong>光照贴图类型的纹理，编码格式取决于不同的平台</li><li><strong>Single Channel：</strong>如果原始图片文件只有一个通道，请选择此类型</li></ul><h5 id="纹理大小"><a href="#纹理大小" class="headerlink" title="纹理大小"></a>纹理大小</h5><p>纹理大小最好是2的幂次方。纹理大小直接影响内存和显存占用的大小，同时也会对GPU采样、CPU加载带宽造成影响。</p><p>选择合适纹理大小应尽量遵循以下经验：</p><ul><li>不同平台、不同硬件配置选择不同的纹理大小，Unity下可以采用bundle变体设置多套资源、通过Mipmap限制不同平台加载不同level层级的贴图。</li><li>根据纹理用途的不同选择不同的纹理加载方式，如流式纹理加载Texture Streaming、稀疏纹理Sparse Texture、虚拟纹理VirtualTexture等方式。</li><li>不能让美术人员通过增加纹理大小的方式增加细节(容易造成内存爆炸)，可以选择细节贴图DetailMap或增加高反差保留的方式。</li><li>在不降低视觉效果的情况下尽量减小贴图大小，最好的方式是纹理映射的每一个纹素的大小正好符合屏幕上显示像素的大小，如果纹理小了会造成欠采样，纹理显示模糊，如果纹理大了会造成过采样，纹理显示噪点。这一点做到完美平衡很难保障，可以充分利用Unity编辑器下SceneView-&gt;DrawMode-&gt;Mipmap来查看在游戏摄像机视角下哪些纹理过采样，哪些纹理欠采样，进而来调整纹理大小。</li></ul><h5 id="纹理颜色空间"><a href="#纹理颜色空间" class="headerlink" title="纹理颜色空间"></a>纹理颜色空间</h5><p> 默认大多数图像处理工具都会使用sRGB颜色空间处理和导出纹理。但如果你的纹理不是用作颜色信息的话，那就不要使用sRGB空间，如金属度贴图、粗糙度贴图、高度图或者法线贴图等。一旦这些纹理使用sRGB空间会造成视觉表现错误。</p><h5 id="纹理压缩"><a href="#纹理压缩" class="headerlink" title="纹理压缩"></a>纹理压缩</h5><p> 纹理压缩是指图像压缩算法，保持贴图视觉质量的同时，尽量减小纹理数据的大小。默认情况下我们的纹理原始格式采用PNG或TGA这类通用文件格式，但与专用图像格式相比他们访问和采样速度都比较慢，无法通用GPU硬件加速，同时纹理数据量大，占用内存较高。所以在渲染中我们会采用一些硬件支持的纹理压缩格式，如ASTC 、ETC、ETC2、DXT等。</p><p> 如下图为未压缩、ETC2、ASTC6x6三种格式文件大小对比，我们可以看到在质量相差不大的情况下ASTC6x6压缩下大小可以减少到接近未压缩的十分之一。</p><h5 id="纹理图集"><a href="#纹理图集" class="headerlink" title="纹理图集"></a>纹理图集</h5><p>纹理图集是一系列小纹理图像的集合，</p><ul><li>优点：</li></ul><p> 一是采用共同纹理图集的多个静态网格资源可以进行静态合批处理，减少DrawCall调用次数。</p><p> 二是纹理图集可以减少碎纹理过多，因为他们打包在一个图集里，通过压缩可以更有效的利用压缩，降低纹理的内存成本和冗余数据。</p><ul><li>缺点</li></ul><p> 美术需要合理规划模型，并且要求模型有相同的材质着色器，或需要制作通道图去区分不同材质。制作和修改成本较高。</p><h5 id="纹理过滤"><a href="#纹理过滤" class="headerlink" title="纹理过滤"></a>纹理过滤</h5><ul><li><strong>Nearest Point Filtering：</strong>临近点采样过滤最简单、<strong>计算量最小</strong>的纹理过滤形式，但在近距离观察时，纹理会呈现块状。</li><li><strong>Bilinear Filtering：</strong>双线性采样过滤会对临近纹素采样并插值化处理，对纹理像素进行着色。双线性过滤会让像素看上去平滑渐变，但近距离观察时，纹理会变得模糊。</li><li><strong>Trilinear Filtering：</strong>三线性过滤除与双线性过滤相同部分外，还增加了Mipmap等级之间的采样差值混合，用来平滑过度消除Mipmap之间的明显变化。</li><li><strong>Anisotropic Filtering：</strong>各向异性过滤可以改善纹理在倾斜角度下的视觉效果，跟适合用于地表纹理。</li></ul><h5 id="纹理Mipmap"><a href="#纹理Mipmap" class="headerlink" title="纹理Mipmap"></a>纹理Mipmap</h5><ul><li>Mipmap纹理</li></ul><p> 逐级减低分辨率来保存纹理副本。相当于生成了纹理LOD，渲染纹理时，将根据像素在屏幕中占据的纹理空间大小选择合适的Mipmap级别进行采样。渲染具有mipmap对象时，当摄像机离对象较远时将采用较低分辨率的纹理，当摄像机离对象较近时采用较高分辨率的纹理。</p><ul><li>优点：</li></ul><p> GPU不需要在远距离上对对象进行全分辨率纹理采样，因此可以<strong>提高纹理采样性能。</strong></p><p> 同时也解决了远距离下的过采样导致的噪点问题，提高的纹理渲染质量。</p><ul><li>缺点：</li></ul><p> 由于Mipmap纹理要生成低分辨率副本，会造成额外的内存开销。</p><h4 id="导入设置"><a href="#导入设置" class="headerlink" title="导入设置"></a>导入设置</h4><p><img src="/2023/09/08/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/TextureSetting.png" alt="TextureSetting"></p><h5 id="Texture-Shape"><a href="#Texture-Shape" class="headerlink" title="Texture Shape"></a>Texture Shape</h5><ul><li>2D 最常用的2D纹理，默认选项</li><li>Cube 一般用于天空和与反射探针，默认支持Default、Normal、Single Channel几种类型纹理，可以通过Assets &gt; Create &gt; Legacy &gt; Cubemap生成，也可以通过C#代码 Camera.RenderToCubemap在脚本中生成</li><li>2D Array 2D纹理数组，可以极大提高大量相同大小和格式的纹理访问效率，但需要特定平台支持，可以通过引擎SystemInfo.supports2DArrayTextures 接口运行时查看是否支持。</li><li>3D 通过纹理位图方式存储或传递一些3D结构话数据，一般用于体积仿真，如雾效、噪声、体积数据、距离场、动画数据等信息，可以外部导入，也可运行时程序化创建。</li></ul><h5 id="Alpha-Source"><a href="#Alpha-Source" class="headerlink" title="Alpha Source"></a>Alpha Source</h5><p>默认选择Input Texture Alpha就好，如果确定不使用原图中的Alpha通道，可以选择None。另外From Gray Scale我们一般不会选用</p><h5 id="Alpha-Is-Transparency"><a href="#Alpha-Is-Transparency" class="headerlink" title="Alpha Is Transparency"></a>Alpha Is Transparency</h5><p>指定Alpha通道是否开启半透明，如果位图像素不关心是否要半透明可以不开启此选项。这样Alpha信息只需要占1bit。节省内存</p><h5 id="Ignore-Png-file-gamma"><a href="#Ignore-Png-file-gamma" class="headerlink" title="Ignore Png file gamma"></a>Ignore Png file gamma</h5><p>是否忽略png文件中的gamma属性，这个选项是否忽略取决于png文件中设置不同gamma属性导致的显示不正常，一般原图制作流程没有特殊设置，这个选项一般默认就好。</p><h5 id="Read-x2F-Write"><a href="#Read-x2F-Write" class="headerlink" title="Read/Write"></a>Read/Write</h5><p>开启此选项会导致内存量增加一倍，默认我们都是不开启，除非你的脚本逻辑中需要动态读写该纹理时需要打开此选项。</p><h5 id="Streaming-Mipmaps-Texture-Streaming部分讲解"><a href="#Streaming-Mipmaps-Texture-Streaming部分讲解" class="headerlink" title="Streaming Mipmaps(Texture Streaming部分讲解)"></a>Streaming Mipmaps(Texture Streaming部分讲解)</h5><h5 id="Virtual-Texture-Only-虚拟部分讲解"><a href="#Virtual-Texture-Only-虚拟部分讲解" class="headerlink" title="Virtual Texture Only(虚拟部分讲解)"></a>Virtual Texture Only(虚拟部分讲解)</h5><h6 id="Generate-Mip-Maps"><a href="#Generate-Mip-Maps" class="headerlink" title="Generate Mip Maps"></a>Generate Mip Maps</h6><p><strong>什么时候不需要生成MipMaps？</strong></p><ol><li>2D场景</li><li>固定视角，摄像机无法缩放远近</li></ol><ul><li>Border Mip Maps 默认不开启，只有当纹理的是Light Cookies类型时，开启此选项来避免colors bleeding现象导致颜色渗透到较低级别的Mip Level纹理边缘上</li><li>MipMap Filtering</li><li>Box 最简单，随尺寸减小，Mipmap纹理变得平滑模糊</li><li>Kaiser，避免平滑模糊的锐化过滤算法。</li><li>Mip Maps Preserve Coverage，只有需要纹理在开启mipmap后也需要做Alpha Coverage时开启。默认不开启。</li><li>Fadeout MipMaps, 纹理Mipmap随Mip层级淡化为灰色，一般不开启，只有在雾效较大时开启不影响视觉效果。</li></ul><h6 id="选择合适纹理过滤的最佳经验："><a href="#选择合适纹理过滤的最佳经验：" class="headerlink" title="选择合适纹理过滤的最佳经验："></a>选择合适纹理过滤的最佳经验：</h6><ul><li>使用双线性过滤平衡性能和视觉质量。</li><li>有选择地使用三线性过滤，因为与双线性过滤相比，它需要更多的内存和带宽。</li><li>使用双线性和 2x 各向异性过滤，而不是三线性和 1x 各向异性过滤，因为这样做不仅视觉效果更好，而且性能也更高。</li><li>保持较低的各向异性级别。仅对关键游戏资源使用高于 2 的级别。</li></ul><h6 id="其他可能有问题的纹理类型"><a href="#其他可能有问题的纹理类型" class="headerlink" title="其他可能有问题的纹理类型"></a>其他可能有问题的纹理类型</h6><ul><li>纹理图集大小设置不合理，图集利用率低</li><li>大量只有颜色差异的图片</li><li>UI背景贴图而不采用9宫格缩放的图</li><li>纯色图没有使用Single Channel</li><li>不合理的半透明UI，占据大量屏幕区域，造成Overdraw开销</li><li>大量2D序列帧动画，而且图片大，还不打图集</li><li>不合理的通道图利用方案</li><li>大量渐变色贴图，没有采用1像素过渡图，也不采用Single Channel, 粒子特效中较为常见。</li></ul><h3 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h3><h4 id="Rig标签-骨骼设置"><a href="#Rig标签-骨骼设置" class="headerlink" title="Rig标签 骨骼设置"></a>Rig标签 骨骼设置</h4><p><img src="/2023/09/08/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/AnimationRigSetting.png" alt="AnimationRigSetting"></p><h5 id="Animation-Type"><a href="#Animation-Type" class="headerlink" title="Animation Type"></a><strong>Animation Type</strong></h5><ul><li>None 无动画</li><li>Legacy 旧版动画，不要用</li><li>Generic 通用骨骼框架</li><li>Humanoid 人形骨骼框架</li></ul><h6 id="选择原则："><a href="#选择原则：" class="headerlink" title="选择原则："></a><strong>选择原则：</strong></h6><ul><li>无动画选择None</li><li>非人形动画选择Generic<ul><li>在移动平台推荐使用Generic，但是避免原始骨骼数量爆炸</li></ul></li><li>人形动画<ul><li>人形动画需要Kinematices或Animation Retargeting功能，或者没有有自定义骨骼对象时选择Humanoid Rig</li><li>其他都选择Generic Rig，<strong>在骨骼数差不多的情况下,Generic Rig会比Humanoid Rig省30%甚至更多的CPU的时间</strong>。节省的时间正是Kinematices或Animation Retargeting功能消耗的时间。</li></ul></li></ul><h5 id="Skin-Weights-骨骼优化"><a href="#Skin-Weights-骨骼优化" class="headerlink" title="Skin Weights(骨骼优化)"></a><strong>Skin Weights</strong>(骨骼优化)</h5><p> 默认4根骨头，但对于一些不重要的动画对象可以减少到1根，节省计算量</p><h5 id="Optimize-Bones-骨骼优化"><a href="#Optimize-Bones-骨骼优化" class="headerlink" title="Optimize Bones(骨骼优化)"></a><strong>Optimize Bones(骨骼优化)</strong></h5><p> 建议开启，在导入时自动剔除没有蒙皮顶点的骨骼</p><h5 id="Optimize-Game-Objects-骨骼优化"><a href="#Optimize-Game-Objects-骨骼优化" class="headerlink" title="Optimize Game Objects(骨骼优化)"></a><strong>Optimize Game Objects</strong>(骨骼优化)</h5><p> 在Avatar和Animatior组件中删除导入游戏角色对象的变换层级结构，而使用Unity动画内部结构骨骼，消减骨骼transform带来的性能开销。可以提高角色动画性能, 但有些情况下会造成角色动画错误，这个选项可以尝试开启但要看表现效果而定。注意如果你的角色是可以换装的，在导入时不要开启此选项，但在换装后在运行时在代码中通过调用AnimatorUtility.OptimizeTransformHierarchy接口仍然可以达到此选项效果。</p><h4 id="Animation标签页"><a href="#Animation标签页" class="headerlink" title="Animation标签页"></a>Animation标签页</h4><p><img src="/2023/09/08/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/AnimationSetting.png" alt="AnimationSetting"></p><h5 id="Resmple-Curves"><a href="#Resmple-Curves" class="headerlink" title="Resmple Curves"></a><strong>Resmple Curves</strong></h5><p> 将动画曲线重新采样为四元数数值，并为动画每帧生成一个新的四元数关键帧，仅当导入动画文件包含尤拉曲线时才会显示此选项</p><h5 id="Anim-Compression"><a href="#Anim-Compression" class="headerlink" title="Anim.Compression"></a><strong>Anim.Compression</strong></h5><ul><li><strong>Off</strong> 不压缩,质量最高，内存消耗最大</li><li><strong>Keyframe Reduction</strong> 减少冗余关键帧，减小动画文件大小和内存大小。</li><li><strong>Keyframe Reduction and Compression</strong> 减小关键帧的同时对关键帧存储数据进行压缩，只影响文件大小。</li><li><strong>Optimal</strong>，仅适用于Generic与Humanoide动画类型，Unity决定如何进行压缩。</li></ul><h5 id="Animation-Custom-Properties"><a href="#Animation-Custom-Properties" class="headerlink" title="Animation Custom Properties"></a><strong>Animation Custom Properties</strong></h5><p> 导入用户自定义属性，一般对应<strong>DCC</strong>工具中的<strong>extraUserProperties</strong>字段中定义的数据</p><h4 id="动画曲线数据信息"><a href="#动画曲线数据信息" class="headerlink" title="动画曲线数据信息"></a>动画曲线数据信息</h4><p><img src="/2023/09/08/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%8A%A8%E7%94%BB%E6%9B%B2%E7%BA%BF%E6%95%B0%E6%8D%AE%E4%BF%A1%E6%81%AF.png" alt="动画曲线数据信息"></p><ul><li>Curves Pos: 位置曲线</li><li>Quaternion: 四元数曲线 Resample Curves开启会有</li><li>Euler: 尤拉曲线</li><li>Scale: 缩放曲线</li><li>Muscles: 肌肉曲线，Humanoid类型下会有</li><li>Generic: 一般属性动画曲线，如颜色，材质等</li><li><strong>PPtr：</strong>精灵动画曲线，一般2D系统下会有</li><li>**Curves Total: **曲线总数</li><li>Constant: 优化为常数的曲线</li><li>Dense: 使用了密集数据（线性插值后的离散值）存储</li><li>Stream: 使用了流式数据（插值的时间和切线数据）存储</li></ul><h5 id="动画文件导入设置优化后信息查看原则"><a href="#动画文件导入设置优化后信息查看原则" class="headerlink" title="动画文件导入设置优化后信息查看原则"></a>动画文件导入设置优化后信息查看原则</h5><ol><li>一看效果差异（与原始制作动画差异是否明显）</li><li>二看曲线数量（总曲线数量与各种曲线数显，常量曲线比重大更好）</li><li>三看动画文件大小（以移动平台为例，动画文件在小几百k或更少为合理，查过1M以上的动画文件考虑是否进行了合理优化）</li></ol>]]></content>
    
    
    <categories>
      
      <category>性能优化篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能优化 资源管理 Asset</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>帧同步设计</title>
    <link href="/2023/09/07/%E5%B8%A7%E5%90%8C%E6%AD%A5%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/09/07/%E5%B8%A7%E5%90%8C%E6%AD%A5%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="帧同步设计"><a href="#帧同步设计" class="headerlink" title="帧同步设计"></a>帧同步设计</h1><h2 id="第1节-简介"><a href="#第1节-简介" class="headerlink" title="第1节 简介"></a>第1节 简介</h2><h3 id="状态同步"><a href="#状态同步" class="headerlink" title="状态同步"></a>状态同步</h3><ul><li>逻辑计算在服务器</li><li>服务器同步变化给客户端</li><li>客户端只做表现</li></ul><h3 id="帧同步"><a href="#帧同步" class="headerlink" title="帧同步"></a>帧同步</h3><ul><li>服务器广播客户端指令</li><li>逻辑计算在客户端逻辑层</li><li>客户端逻辑层发送变化给表现层</li><li>相当于把状态同步的服务器挪到了客户端逻辑层</li></ul><h4 id="适合的场景"><a href="#适合的场景" class="headerlink" title="适合的场景"></a>适合的场景</h4><p>操作少，逻辑变化多</p><p>同场景玩家数少，需要同时同步的数量少</p><p>同视野单位特别多的场景</p><p>只适合开房间类型</p><p>不太需要单位信息保密的场景，安全性等级较低的场景</p><p>以上条件缺一不可</p><h4 id="帧同步优势"><a href="#帧同步优势" class="headerlink" title="帧同步优势"></a>帧同步优势</h4><ul><li>流量少<ul><li>具体流量多少看玩家数量</li></ul></li><li>录像文件小<ul><li>只需要记录操作</li><li>状态同步则是保存协议消息</li></ul></li><li>服务器不做验证的话，服务器消耗小</li></ul><h4 id="帧同步误区"><a href="#帧同步误区" class="headerlink" title="帧同步误区"></a>帧同步误区</h4><ul><li>帧同步手感更好</li><li>帧同步开发简单，难度低</li><li>帧同步对网络速度要求低<ul><li>如果需要体验流畅反而网络要求更高</li></ul></li><li>帧同步各个客户端表现一模一样<ul><li>只能保证逻辑层一致</li></ul></li><li>帧同步可以减少服务器</li></ul><h4 id="帧同步的几种方案"><a href="#帧同步的几种方案" class="headerlink" title="帧同步的几种方案"></a>帧同步的几种方案</h4><ul><li>服务器消息驱动帧同步：服务端固定帧率收集消息，定时广播，客户端指令没有帧的概念，帧是由服务端消息驱动的，适合玩家数量稍多的场景，预测只能做表现层的预测，开发难度相对简单</li><li>预测回滚帧同步：服务的固定帧率收集消息，客户端也有自己的帧，适合2-3人的场景，逻辑层有做预测，预测失败则回滚，开发难度大</li></ul><h2 id="第2节-网络0GC处理"><a href="#第2节-网络0GC处理" class="headerlink" title="第2节 网络0GC处理"></a>第2节 网络0GC处理</h2><h3 id="0GC的消除策略"><a href="#0GC的消除策略" class="headerlink" title="0GC的消除策略"></a>0GC的消除策略</h3><p>0GC就是不分配，共用对象池。但是多线程情况下共用对象池存在风险。</p><p>服务端不消除GC</p><p>客户端手动消除消息GC，消除量级比较大的消息</p><h3 id="0GC的方式"><a href="#0GC的方式" class="headerlink" title="0GC的方式"></a>0GC的方式</h3><ul><li>MessagePool<ul><li>线程安全的消息对象池</li></ul></li><li>MemoryPack提供了ref的反序列化方式<ul><li>不是new对象的形式</li></ul></li><li>消息中的成员回收</li><li>消息中容器回收，MemoryPack会对容器调用Clear，容器中最好是struct<ul><li>MemoryPack构建struct的时候用的非反射方式，没有拆装箱避免了gc</li></ul></li><li>MemorySteam GC消除</li><li>Udp Send Recv GC消除</li></ul><h3 id="消息的创建回收"><a href="#消息的创建回收" class="headerlink" title="消息的创建回收"></a>消息的创建回收</h3><ul><li>MessageObject.IsFromPool<ul><li>消息都继承于MessageObject</li></ul></li><li>发送消息时创建，消息传到网络层序列化完成后回收<ol><li>发送的时候需要自己调用Create(true);</li><li>回收是框架自动调用Dispose();</li></ol></li><li>接受消息时创建，消息传到主线程使用完成后回收<ol><li>接收的时候框架自动调用FetchMessage</li><li>回收需要自己调用Dispose();</li></ol></li></ul><h3 id="MemoryBuffer创建回收"><a href="#MemoryBuffer创建回收" class="headerlink" title="MemoryBuffer创建回收"></a>MemoryBuffer创建回收</h3><p>MemoryBuffer是MemoryStream子类，主要为了配合MemoryPack用的</p><p>IBufferWriter接口</p><p>框架自动回收，使用者不需要关心</p><h3 id="MemoryPack-Source-Generator"><a href="#MemoryPack-Source-Generator" class="headerlink" title="MemoryPack Source Generator"></a>MemoryPack Source Generator</h3><p>不像protobuf通过反射生成代码，完全支持unity</p><p>AssemblyBuilder失效</p><p>使用IDE编译Dll，所有代码放到Unity.Codes工程里面，开启ENABLE_CODES启用dll模式，跟ET7中相反</p><p>Unity.Codes分成Model跟Hotfix，报错，没找到问题，所以客户端热重载暂时不能用</p><h2 id="第3节-框架层调整"><a href="#第3节-框架层调整" class="headerlink" title="第3节 框架层调整"></a>第3节 框架层调整</h2><ol><li>EntityRef<ul><li>原本对Entity的引用只能通过InstanceId，现在增加EntityRef持有Entity</li><li>当Entity被释放或者回收掉时，再去取EntityRef则为null</li></ul></li><li>Entity不再统一注册到Root中<ul><li>在原本的设计中Root管理Entity，通过InstanceId为key来取出Entity。</li><li>只有Actor对象的Entity挂载了MailboxComponent的才会注册到ActorMessageDispatcherComponent中</li></ul></li><li>TypeSystem EntitySystemSingleton，可扩展的Entity System机制<ul><li>把之前EventSystem内一些生命周期的事件，抽出到EntitySystemSingleton中。</li><li>LSEntitySystemSingleton</li></ul></li><li>Domain IScene, 更完善，Scene的代码都简化了<ul><li>只要Entity有IScene接口都可以是Domain</li><li>Scene中简化了Parent和Domain的字段</li></ul></li><li>Entity中Components改成SortedDictionary，保证有序<ul><li>原本的Entity中的Components只是字段，在不同机器上的hash值不一样顺序也不一样。帧同步则会有问题，在Entity执行Disponse时，不同机器移除顺序不同则会造成问题。</li></ul></li><li>Mongo序列化BeginInit, SerializeSystem<ul><li>Entity序列化时，调用BeginInit遍历判断Componets是否有ISerializeToEntity接口，有则加入ComponentDB</li><li>增加SerializeSystem，用于判断有些同类型Entity哪些需要存储哪些不需要存储。</li></ul></li><li>配置文件改成了Bson，直接支持Dictionary</li></ol><h2 id="第4节-帧同步架构"><a href="#第4节-帧同步架构" class="headerlink" title="第4节 帧同步架构"></a>第4节 帧同步架构</h2><p><img src="/2023/09/07/%E5%B8%A7%E5%90%8C%E6%AD%A5%E8%AE%BE%E8%AE%A1/image-20230817212941518.png" alt="image-20230817212941518"></p><ul><li>客户端的Room相比服务端的Room多了个表现层</li><li>客户端挂载的是LSClientUpdate，服务端挂载的是LSServerUpdate，客户端相对服务端而言多了预测回滚的功能。</li></ul><h2 id="第5节-LSEntity"><a href="#第5节-LSEntity" class="headerlink" title="第5节 LSEntity"></a>第5节 LSEntity</h2><h3 id="为什么要LSEntity"><a href="#为什么要LSEntity" class="headerlink" title="为什么要LSEntity"></a>为什么要LSEntity</h3><ol><li>限制Entity的Id生成<ul><li>Entity的id都是通过IdGenerater生成，那么不同设备上生成出来的id会不一致。会导致逻辑不一致。</li><li>LSEntity AddChild和AddComponent时生成的id是统一的。</li><li>LSEntity 的Id序列化和反序列操作后不变。</li></ul></li><li>LSWorld不能使用Update LateUpdate Load等等<ul><li>需要专用的Update类似于FixedUpdate，每固定时间触发。</li><li>服务器的Load和客户端的Load，代码不一致可能导致结果也不一致。</li></ul></li><li>序列和反序列化导致InstanceId跟System绑定关系失效，不能写一个老式的FixedUpdate<ul><li>回滚逻辑在把操作进行序列化和反序列后，instanceId产生变化会自增1，导致失效。</li></ul></li><li>用Id跟System绑定，专用的 LSUpdateSystem<ul><li>FixedUpdateSystem的实现</li></ul></li><li>可以针对LSEntity，加上float分析器限制</li></ol><h3 id="LSWorld：LSEntity"><a href="#LSWorld：LSEntity" class="headerlink" title="LSWorld：LSEntity"></a>LSWorld：LSEntity</h3><p>LSWorld只能挂在LSEntity</p><ol><li>定点数部分，纯逻辑层<ul><li>没必要所有代码都使用定点数，只有在于帧同步玩法内才需要。比如Room内LSWorld部分才使用定点数。</li></ul></li><li>序列化反序列化, 回滚的部分<ul><li>只有逻辑层、纯定点数部分才需要回滚。</li></ul></li><li>Id生成器</li><li>随机数<ul><li>服务器生成的随机数种子，使客户端通过Id生成器生成的Id能保持一致。</li></ul></li><li>LSUpdater，注意，这个不是fixedUpdate，记录有哪些Entity有LSUpdate</li></ol><h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><ul><li>LSEntitySystemSington</li><li>LSUpdateSystem</li><li>LSRollbackSystem<ul><li>和表现层做和解用的</li></ul></li></ul><h3 id="LSUpdater-Update驱动"><a href="#LSUpdater-Update驱动" class="headerlink" title="LSUpdater.Update驱动"></a>LSUpdater.Update驱动</h3><p>Room上挂有一个Updater组件，在固定帧调用LSWorld的Updater</p><p>客户端的Update间隔和服务端不一致，客户端可能需要动态调整，时间的膨胀、搜索。在服务端的Room上挂服务端的Update组件，在客户端的Room上挂客户端的Update组件。</p><h3 id="LSRollbacke"><a href="#LSRollbacke" class="headerlink" title="LSRollbacke"></a>LSRollbacke</h3><p>在表现层使用，用于状态回滚。表现层向逻辑层进行一一核对。</p><h2 id="第6节-预测回滚"><a href="#第6节-预测回滚" class="headerlink" title="第6节 预测回滚"></a>第6节 预测回滚</h2><h3 id="Room"><a href="#Room" class="headerlink" title="Room"></a>Room</h3><h4 id="FrameBuffer输入缓存"><a href="#FrameBuffer输入缓存" class="headerlink" title="FrameBuffer输入缓存"></a>FrameBuffer输入缓存</h4><p>给记录的帧率限定数量，当超过限定值时则从记录的第一帧开始覆盖。</p><ul><li>记录所有人的输入。每一帧的输入，每一帧都是一个字典。</li><li>每一帧的快照，记录帧并序列化。</li><li>每一帧都有一个hash值，用于做帧内容的对比。</li></ul><h4 id="FixedTimeCounter-固定时间计算，固定时间可改变"><a href="#FixedTimeCounter-固定时间计算，固定时间可改变" class="headerlink" title="FixedTimeCounter 固定时间计算，固定时间可改变"></a>FixedTimeCounter 固定时间计算，固定时间可改变</h4><p>用来计算FixedUpdate的时间，到FixedTime的时间才会调用LSWorld的Update。</p><p>为什么不用固定时间调用？因为每帧时间不是固定的，客户端的时间会膨胀收缩。如果客户端的时间比服务端慢了，那么客户端的帧的间隔会减小。因为要保证客户端的预测帧一直跑在服务器的权威帧之前。</p><h4 id="LSWorld"><a href="#LSWorld" class="headerlink" title="LSWorld"></a>LSWorld</h4><p>Room的child 可以有多个，持有Ref的引用性能会高些。</p><h4 id="PredictionFrame-预测帧-AuthorityFrame-权威帧"><a href="#PredictionFrame-预测帧-AuthorityFrame-权威帧" class="headerlink" title="PredictionFrame 预测帧 AuthorityFrame 权威帧"></a>PredictionFrame 预测帧 AuthorityFrame 权威帧</h4><p>预测帧就是客户端根据玩家操作预测出来的帧。服务器在做转发时，如果当前帧有玩家没输入则使用上一帧输入的数据做预测。</p><p>权威帧对客户端而言就是服务器下发的帧，确认帧。对服务端而言不做预测所以都是权威帧。</p><h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><p>作用：</p><ol><li>本地立即响应</li><li>提前发送操作给服务端，服务端的权威帧跑到了后可以马上广播</li></ol><p>策略：</p><ol><li>客户端预测自己的输入，直接获取。</li><li>客户端预测别人的输入，取上一帧的输入。避免权威帧到了之后做过多的回滚操作，因为大概率操作和上一帧一样。 </li><li>服务的预测，时间到了，客户端的输入没有发送过来，直接取客户端上一帧的输入，相当于丢弃客户端的输入。</li></ol><h3 id="权威消息处理"><a href="#权威消息处理" class="headerlink" title="权威消息处理"></a>权威消息处理</h3><ol><li><p>权威消息比预测消息早</p><p>如果预测消息晚于权威消息，那么直接使用权威帧就不用预测了。</p></li><li><p>权威消息跟预测内容一样</p><p>消息一样则不用处理</p></li><li><p>权威消息跟预测消息不一致</p><p>如果和预测消息不同，那么就需要进行回滚。客户端先把权威帧的数据拷贝到预测帧中，然后回滚到权威帧时的world，然后执行权威帧。权威帧后面从帧数则要重新进行预测。</p><p>表现层，遍历Room下所有非LSEntity的Components，因为LSEntity是数据层使用的，然后做递归遍历执行所有的RollbackSystem。</p></li></ol><h2 id="第7节-客户端时间膨胀收缩-检测不同步"><a href="#第7节-客户端时间膨胀收缩-检测不同步" class="headerlink" title="第7节 客户端时间膨胀收缩-检测不同步"></a>第7节 客户端时间膨胀收缩-检测不同步</h2><p>客户端的预测帧需要在服务端处理到权威帧下一帧之前到达服务端。</p><h3 id="动态调整客户端fixedTime"><a href="#动态调整客户端fixedTime" class="headerlink" title="动态调整客户端fixedTime"></a>动态调整客户端fixedTime</h3><p>每秒钟，服务端发送客户端的消息延迟时间给客户端 Room2C_AdiustUpdateTime</p><h4 id="消息延迟的时间怎么算？"><a href="#消息延迟的时间怎么算？" class="headerlink" title="消息延迟的时间怎么算？"></a><strong>消息延迟的时间怎么算？</strong></h4><p>比如当服务器跑到第2帧了，但是服务器只记录了第0帧的输入数据，那差距就是2帧的时间。</p><p>当客户端收到服务端同步的消息延迟时，缩放update的间隔，在一秒内完成调整(把每一帧的时间平均分一下)。</p><h4 id="调整公式"><a href="#调整公式" class="headerlink" title="调整公式"></a>调整公式</h4><p><code>新的一帧时间 = （原来的一帧时间 + ( diffTime - 一帧时间 ) ）/ ( 1000 / 一阵时间 )</code></p><p>ps: <code>diffTime - 一帧时间</code> ，因为预期是快一帧的时间所以减去一帧时间。</p><h4 id="调整限制"><a href="#调整限制" class="headerlink" title="调整限制"></a>调整限制</h4><p>给调整的时间加个限制，如果一秒内调整不完那就放到下一秒调整。</p><p>最快一秒25帧，最慢一秒15帧</p><h3 id="不同步检测"><a href="#不同步检测" class="headerlink" title="不同步检测"></a>不同步检测</h3><p>客户端权威帧改变的时候，计算lsworld序列化的hash值给服务端，服务端对比hash值</p><h2 id="第8节-录像Replay"><a href="#第8节-录像Replay" class="headerlink" title="第8节 录像Replay"></a>第8节 录像Replay</h2><h3 id="帧同步录像包含信息"><a href="#帧同步录像包含信息" class="headerlink" title="帧同步录像包含信息"></a>帧同步录像包含信息</h3><ol><li><p>记录初始化信息</p><p>玩家、时间、版本号这类信息</p></li><li><p>记录每帧输入</p><p>记录对局中的每一帧的数据</p></li><li><p>定期记录LSWorld序列化</p><p>如果没有序列化LSWorld，那在回放指定帧时计算过程会很长，计算过程可能导致卡顿。</p><p>比如每一分钟记录一次，播放指定帧时直接取出序列化文件反序列化。</p></li></ol><h3 id="LSReplayUpdater"><a href="#LSReplayUpdater" class="headerlink" title="LSReplayUpdater"></a>LSReplayUpdater</h3><p>LSReplayUpdater是从Replay中取出帧指令执行的，跟客户端和服务端的updater从framebuffer中取数据不同。</p><h3 id="Replay跳转"><a href="#Replay跳转" class="headerlink" title="Replay跳转"></a>Replay跳转</h3><p>JumpReplay</p><p>如果在replay时快照的下标和当前权威帧计算出来的下标一致时，则不再取出快照进行序列化。因为快照是同一份。</p><p>如果跳转的帧小于当前的权威帧，那么还是需要反序列快照进行播放。</p><p><code>fame/快照记录的时间=快照下标</code></p><h3 id="Replay加速播放"><a href="#Replay加速播放" class="headerlink" title="Replay加速播放"></a>Replay加速播放</h3><p>ChangeReplaySpeed</p><p>调整每一帧播放的间隔时间</p><h2 id="第9节-断线重连"><a href="#第9节-断线重连" class="headerlink" title="第9节 断线重连"></a>第9节 断线重连</h2><p>主要在loginGate的部分</p><ol><li><p>判断账号是否在线，需要做顶号操作。可能是旧连接保持连接或者被顶号。</p></li><li><p>判断是否在帧同步房间内。</p></li><li><p>取出当前room数据转发给客户端，客户端根据数据生成room</p></li><li><p>把session挂上玩家，playersession赋值session</p><p>之前的设计session是一个entity。帧同步这里则是PlayerSessionComponent上的一个变量。这样做的好处就是session如果空了，下次断线重连赋值后就可以直接做转发。判空就行，不用判断连接状态。</p></li><li><p>客户端收到Reconnect消息时，进行场景切换。SceneChangeToReconnect</p></li></ol><h2 id="第10节-同步方式变种"><a href="#第10节-同步方式变种" class="headerlink" title="第10节 同步方式变种"></a>第10节 同步方式变种</h2><h3 id="多个LSWorld"><a href="#多个LSWorld" class="headerlink" title="多个LSWorld"></a>多个LSWorld</h3><p>比如守望先锋有两个world，一个计算战斗一个计算回放。两个并行的逻辑层，在进行回放的时候把world进行切换一下就可以看到战斗回放。</p><h3 id="取消每帧序列化"><a href="#取消每帧序列化" class="headerlink" title="取消每帧序列化"></a>取消每帧序列化</h3><p>可以再进行抽象，抽象出<code>权威world</code>和<code>预测world</code>。就不需要每帧都进行序列化，当发生回滚时只需要把<code>权威world</code>copy到<code>预测world</code>中然后生成新的<code>预测world</code>，可以减少每帧序列化产生的gc。</p><p>缺点就是需要同时计算两个world，计算量会更大。</p><h3 id="守望先锋状态帧"><a href="#守望先锋状态帧" class="headerlink" title="守望先锋状态帧"></a>守望先锋状态帧</h3><p>守望先锋既同步<code>操作帧</code>，也同步<code>状态</code>。每帧计算状态脏数据，同步的状态是脏数据。</p><p>因为是纯struct结果，很容易做内存对比取出脏数据。</p><p>如果帧预测成功，则丢弃服务器下发的脏数据。</p><p>帧预测失败则回滚到权威帧，然后应用服务器发过来的脏数据包，继续执行到预测帧。</p><p>优点：脏数据自动计算</p><p>缺点：需要用纯粹的ECS进行内存对比，或者通过计算差异的代码来计算差异，不够灵活。</p><h3 id="ET状态帧"><a href="#ET状态帧" class="headerlink" title="ET状态帧"></a>ET状态帧</h3><ol><li>ET不需要自动计算差异，仍然和做MMO一样，计算变化的消息，每帧把变化的消息打包同步给客户端。</li><li>帧预测成功，则丢弃消息。</li><li>帧预测失败则回滚到权威帧，应用服务器发过来的变化消息，继续执行到预测帧。</li><li>优点：不需要纯ECS，很灵活。<br>缺点：需要跟MMO一样处理任何变化，创建不同的变化消息协议，无法自动化。</li></ol><h3 id="ET状态帧继续扩展"><a href="#ET状态帧继续扩展" class="headerlink" title="ET状态帧继续扩展"></a>ET状态帧继续扩展</h3><p>做两个world，一个权威world，一个预测world。服务器始终和客户端的权威world做状态同步，所以权威world一直是正确的数据。</p><p>使用ET状态帧同步，服务端可以做AOI裁剪，只同步玩家能看到的减少数据和计算量。预测也可以只关心看到的数据。</p><p>不用定点数，因为服务端权威world和客户端的权威world只做状态同步，所以可以不使用定点数。客户端相当于只充当表现层，真正的逻辑层在服务端。</p><p>预测失败，则复制权威world到预测world</p><p>定期同步权威world到预测world，进行校准。</p><p>甚至可以权威world和预测world跟mmo一样只是部分逻辑层。相当于只是状态帧同步加上一个帧预测。</p><h3 id="ET状态同步预测回滚"><a href="#ET状态同步预测回滚" class="headerlink" title="ET状态同步预测回滚"></a>ET状态同步预测回滚</h3><p>状态同步，客户端都是表现，可以认为是表现层的预测回滚。moba等无法逻辑层预测回滚的游戏也能使用这种表现层预测回滚的形式</p><p>比如说demo鼠标点击移动做预测回滚</p><p>本地寻路完成立即移动，不用等服务端返回。向服务端发送寻路请求带一个客户端的时间</p><p>服务端返回寻路消息，这个时候，本地可以根据客户端这次移动了多少时间，重新计算服务端返回的路径应该走到了什么位置。然后表现层插值过去</p><p>收到stop的消息，预测失败，则立即stop到指定位置</p><h3 id="更多方式"><a href="#更多方式" class="headerlink" title="更多方式"></a>更多方式</h3><p>大家取发掘，根据项目灵活应变</p><p>定点数物理库:</p><p><a href="https://et-framework.cn/d/1501-by/3">https://et-framework.cn/d/1501-by/3</a></p><h2 id="第11节-补充"><a href="#第11节-补充" class="headerlink" title="第11节 补充"></a>第11节 补充</h2><h3 id="Updater中为什么要排序？"><a href="#Updater中为什么要排序？" class="headerlink" title="Updater中为什么要排序？"></a>Updater中为什么要排序？</h3><p><strong>LSWorld中的updater中的id为什么要排序？</strong></p><p><strong>两个设备计算一致，id插入的顺序也一致为什么要排序？</strong></p><p>Updater中的Entity是RegisterSystem注册进去的</p><p>反序列化注册Entity domain的时候会RegisterSystem</p><p>反序列化注册domain是从上到下执行的。</p><p>但是在运行时执行的顺序无法保证。而实际运行中的Updater并不是按这个规律执行</p><p>所以都用排序的方式，保持一致性。</p><p><strong>帧同步逻辑内有关执行顺序的逻辑都需要小心，因为执行顺序不同造成的结果也是不同的。</strong></p><h3 id="预测回滚帧同步中逻辑层不能用协程"><a href="#预测回滚帧同步中逻辑层不能用协程" class="headerlink" title="预测回滚帧同步中逻辑层不能用协程"></a>预测回滚帧同步中逻辑层不能用协程</h3><p>预测回滚帧同步中逻辑层不能用协程，服务端驱动的状态帧同步可以</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 1</span><br><span class="hljs-keyword">await</span> F1(); <span class="hljs-comment">// 调用F2</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-keyword">await</span> F2(); <span class="hljs-comment">// 调用F3</span><br><span class="hljs-comment">// 3</span><br><span class="hljs-keyword">await</span> F3(); <span class="hljs-comment">// 调用F4</span><br><span class="hljs-comment">// 4</span><br><span class="hljs-keyword">await</span> F4();<br><span class="hljs-comment">//第四帧回滚到第一帧，协程F1重新执行，没什么问题</span><br><span class="hljs-comment">//第四帧回滚到第二帧，协程状态机并不会重新回到第二帧的状态，导致协程丢失</span><br></code></pre></td></tr></tbody></table></figure><p>因为协程的连续调用是链式反应。调用F2函数依赖F1函数执行完后才会调用。所以就算数据回滚了，函数的调用顺序也是有依赖关系。所以不能用协程。</p><h3 id="预测回滚帧同步中使用事件的注意事项"><a href="#预测回滚帧同步中使用事件的注意事项" class="headerlink" title="预测回滚帧同步中使用事件的注意事项"></a>预测回滚帧同步中使用事件的注意事项</h3><h4 id="逻辑层抛出事件，表现层订阅事件"><a href="#逻辑层抛出事件，表现层订阅事件" class="headerlink" title="逻辑层抛出事件，表现层订阅事件"></a>逻辑层抛出事件，表现层订阅事件</h4><ul><li>在回滚的时候，就不能触发表现的事件。因为当回滚时，如果表现层监听了逻辑层抛出的事件，那么就会造成表现层的错误。</li><li>解决办法是回滚过程中修改掉LSWorld的SceneType，这样回滚过程中的事件，表现层就订阅不到了</li><li>回滚完成再把LSWorld的SceneType修改正确</li><li>同样，两个demo中all in one，都是靠domain的SceneType来区分事件的</li><li>更加发散，如果使用权威world跟预测world的方案，区分事件也是一样通过SceneType来区分</li></ul><h3 id="怎么做预测？"><a href="#怎么做预测？" class="headerlink" title="怎么做预测？"></a>怎么做预测？</h3><p>预测只是希望预测准确减少回滚的机率，所以只要计算量不大，怎么准确怎么来就行了</p><p>一般容易预测的就是一直触发的输入，比如移动输入，FPS机枪一直按着射击等等</p><p>按一下就弹起的键一般很难预测准确，就没必要预测了</p><p>比如某个职业有设计技能，需要一直按着按键，那么我们就可以做这种预测</p><h3 id="浮点型分析器限制"><a href="#浮点型分析器限制" class="headerlink" title="浮点型分析器限制"></a>浮点型分析器限制</h3><p>LSEntity的浮点型限制，一个类中有任何包含浮点类型的都会编译报错</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>: <span class="hljs-title">LSEntity</span><br><br>{<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> a;<br><br>    <span class="hljs-keyword">public</span> List&lt;<span class="hljs-built_in">double</span>&gt; b;<br><br>    <span class="hljs-keyword">public</span> Dictionary&lt;<span class="hljs-built_in">float</span>, <span class="hljs-built_in">int</span>&gt; c;<br><br>    <span class="hljs-keyword">public</span> Dictionary&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">double</span>&gt; d;<br><br>    <span class="hljs-keyword">public</span> Dictionary&lt;<span class="hljs-built_in">int</span>, HashSet&lt;<span class="hljs-built_in">double</span>&gt;&gt; e;<br><br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>框架篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>框架 ET框架 帧同步 状态帧同步</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AssetBundle详解</title>
    <link href="/2023/08/29/AssetBundle%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/08/29/AssetBundle%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="AssetBundle详解"><a href="#AssetBundle详解" class="headerlink" title="AssetBundle详解"></a>AssetBundle详解</h1><h2 id="AssetBundle"><a href="#AssetBundle" class="headerlink" title="AssetBundle"></a>AssetBundle</h2><h3 id="一个AssetBundle有什么？"><a href="#一个AssetBundle有什么？" class="headerlink" title="一个AssetBundle有什么？"></a>一个AssetBundle有什么？</h3><ul><li>一个序列化文件，标识符、是否压缩和清单(manifest)数据。<ul><li>manifest数据是由对象的名称为key的查找表(lookup table)，每个条目都提供了一个字节的索引来标识对象在AssetBundle数据段的位置</li></ul></li><li>资源文件，二进制数据块，支持异步加载<ul><li>所有资源都被序列化，如果选择压缩则将序列化数据压缩。</li></ul></li></ul><h3 id="AssetBundle的压缩方式"><a href="#AssetBundle的压缩方式" class="headerlink" title="AssetBundle的压缩方式"></a>AssetBundle的压缩方式</h3><h4 id="LZMA"><a href="#LZMA" class="headerlink" title="LZMA"></a>LZMA</h4><p>基于文件流</p><p>包体小，解压时间长</p><p>因为使用流的方式，所以使用时必须加载整包，解压后会被重新压缩成LZ4</p><h4 id="LZ4"><a href="#LZ4" class="headerlink" title="LZ4"></a>LZ4</h4><p>基于块(Chunk)的算法，读取文件时只需要解压文件所在的块数据</p><p>加载速度和不加载速度差不多，优势在于在内存中的占用变小了</p><p>会比LZMA的包体大25%，可以使用其他压缩手段进行二次压缩，包体也可以被压得很小。</p><h4 id="差异更新"><a href="#差异更新" class="headerlink" title="差异更新"></a>差异更新</h4><p>可以通过包体的差异更新，在热更新的时候通过算法比对出新增内容再进行更新。因为是基于Chunk的算法，所以比对出来的差异文件会比较小，因为数据相对连续。</p><p>差异更新一般分为两种</p><ul><li>基于源文件(安装包)<ul><li>成功率高，算法简单</li><li>但在移动端保存所有源文件，在更新文件整合后再编译不现实。</li></ul></li><li>基于二进制<ul><li>也是最常用的差异比对方式，也是大多数PC游戏的做法。算是很成熟的技术了</li><li>可以和AB包配合，打出更小的热更包</li></ul></li></ul><h5 id="Bsdiff-基于二进制的比对算法"><a href="#Bsdiff-基于二进制的比对算法" class="headerlink" title="Bsdiff ( 基于二进制的比对算法 )"></a>Bsdiff ( 基于二进制的比对算法 )</h5><p>二进制比对生成差异化文件</p><p>比对两个版本文件的二进制数据，然后生成一个patch文件，再将这个patch打到旧文件就可以生成新文件。也就是游戏中的更新补丁包。</p><p>缺点：需要考虑二进制效率，生成的差异化文件可能会比小包情况大一些。</p><h6 id="AssetBundle压缩算法不同导致的差异化文件差异"><a href="#AssetBundle压缩算法不同导致的差异化文件差异" class="headerlink" title="AssetBundle压缩算法不同导致的差异化文件差异"></a>AssetBundle压缩算法不同导致的差异化文件差异</h6><p><strong>在<code>LZ4</code>和<code>LZMA</code>两种压缩方式中，生成的差异化文件大小也是不同的。因为前面提到的<code>AssetBundle</code>的压缩算法都是先序列化再压缩。这就导致了<code>LZMA</code>的压缩算法可能导致一个<code>Asset</code>的数据分散开导致差异化文件过大，而<code>LZ4</code>压缩则是按块压缩数据相对比较集中。所以<code>LZ4</code>生成的差异化文件都比<code>LZMA</code>小。</strong></p><p><code>Uncompressed</code>(不压缩)的方式则差异不大</p><h6 id="差异化文件-补丁-合并"><a href="#差异化文件-补丁-合并" class="headerlink" title="差异化文件(补丁)合并"></a>差异化文件(补丁)合并</h6><p>在合并差异化文件过程中，至少会进行一次文件复制，所以考虑到合并造成的IO消耗，所以单个包的大小还是需要限制一下。</p><p>在patch过程中，可能会造成界面卡顿，所以最好在其他线程中处理。</p><h4 id="补丁文件的版本规划"><a href="#补丁文件的版本规划" class="headerlink" title="补丁文件的版本规划"></a>补丁文件的版本规划</h4><p>保持上个版本的全部文件，然后和新版本的文件做一次diff操作，然后把diff和新版本文件上传CDN。</p><p>如果有玩家多个版本没有更新，那么就下载多个版本的diff进行多次合并。如果跨越的版本数量过多，也可以中间插几个大版本的补丁包来减少补丁数量。</p><h3 id="AssetBundle依赖项"><a href="#AssetBundle依赖项" class="headerlink" title="AssetBundle依赖项"></a>AssetBundle依赖项</h3><p>当<code>Asset</code>被打进<code>AssetBundle包</code>时，其他<code>AssetBundle包</code>依赖这个<code>Asset</code>时会变成依赖这个<code>AssetBundle包</code>。</p><p>当<code>Asset</code>没有打进<code>AssetBundle包</code>，在构建<code>AssetBundle</code>时如果有依赖于这个<code>Asset</code>则会将它打到一起。如果有多个<code>AssetBundle</code>依赖于这个<code>Asset</code>就会被打入多份，造成冗余。</p><p>如果<code>AssetBundle</code>内有依赖对象，在使用时需要先加载依赖的<code>AssetBundle</code>，Unity不会自动加载依赖项。需要自己根据<code>AssetBundleManifest</code>中加载依赖项。</p><p><strong>当精灵图被依赖时，对应的精灵图集也会被打到AssetBundle中，容易造成图集冗余</strong></p><h3 id="AssetBundle之间的重复信息"><a href="#AssetBundle之间的重复信息" class="headerlink" title="AssetBundle之间的重复信息"></a>AssetBundle之间的重复信息</h3><p>公共的资源最好打入一个<code>AssetBundle包</code>中，否则公共资源可能会被构建在多个<code>AssetBundle包</code>中。从而造成资源冗余，安装包的大小变大，运行时的内存占用量变大。</p><p><strong>一个公共材质如果被打入到AssetBundle中会被视为副本，Unity将同一个材质的每个副本都视为独特材质。如果材质被打入到多个AssetBundle中，每个生成的AssetBundle都会包含此材质(包括其着色器和引用纹理)。Unity将同一个材质的每个副本都视为独特材质，所以还会影响到批处理。</strong></p><p>所以在构建时<code>材质</code>和<code>引用的资源</code>尽量打在同一个AssetBundle中。还可以仅标记材质，因为纹理依赖关系也会被包含在AssetBundle中。</p><h3 id="AssetBundle的加载"><a href="#AssetBundle的加载" class="headerlink" title="AssetBundle的加载"></a>AssetBundle的加载</h3><h4 id="AssetBundle-LoadFromMemoryAsync"><a href="#AssetBundle-LoadFromMemoryAsync" class="headerlink" title="AssetBundle.LoadFromMemoryAsync"></a>AssetBundle.LoadFromMemoryAsync</h4><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">AssetBundleCreateRequest createRequest = AssetBundle.LoadFromMemoryAsync(File.ReadAllBytes(path));<br></code></pre></td></tr></tbody></table></figure><p>按字节数组加载AB包。LZMA会在加载时解压，LZ4则会以压缩状态加载。</p><h4 id="AssetBundle-LoadFromFile"><a href="#AssetBundle-LoadFromFile" class="headerlink" title="AssetBundle.LoadFromFile"></a>AssetBundle.LoadFromFile</h4><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> myLoadedAssetBundle = AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath, <span class="hljs-string">"myassetBundle"</span>));<br></code></pre></td></tr></tbody></table></figure><p>从本地存储中加载AB包。未压缩或LZ4直接从磁盘加载AB包，LZMA则先解压再加载到内存中。</p><h4 id="从AssetBundle中加载资源"><a href="#从AssetBundle中加载资源" class="headerlink" title="从AssetBundle中加载资源"></a>从AssetBundle中加载资源</h4><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//加载指定资源</span><br>T objectFromBundle = bundleObject.LoadAsset&lt;T&gt;(assetName);<br><span class="hljs-comment">//加载全部资源</span><br>Unity.Object[] objectArray = loadedAssetBundle.LoadAllAssets();<br><span class="hljs-comment">//加载依赖清单文件</span><br>AssetBundleManifest manifest = assetBundle.LoadAsset&lt;AssetBundleManifest&gt;(<span class="hljs-string">"AssetBundleManifest"</span>);<br></code></pre></td></tr></tbody></table></figure><h3 id="AssetBundle的卸载"><a href="#AssetBundle的卸载" class="headerlink" title="AssetBundle的卸载"></a>AssetBundle的卸载</h3><h4 id="AssetBundle-Unload-true"><a href="#AssetBundle-Unload-true" class="headerlink" title="AssetBundle.Unload(true)"></a>AssetBundle.Unload(true)</h4><p>强制卸载掉所有AssetBundle中加载的Asset，包括AssetBundle的映射结构，和从AssetBundle创建出来的所有资源。释放AssetBundle实例。</p><p><strong>会导致正在使用的资源丢失</strong>，需要一套自己的机制(引用计数)来关注是否有正在使用的资源。</p><h4 id="AssetBundle-Unload-false"><a href="#AssetBundle-Unload-false" class="headerlink" title="AssetBundle.Unload(false)"></a>AssetBundle.Unload(false)</h4><p>AssetBundle内的序列化数据会被释放，正在使用的资源还保持完好。等于断开了AssetBundle和实例的联系。再次使用这个AB包时，则会重新实例化一个新的，旧的就引用不到了。就造成了重复资源的冗余。</p><h4 id="Resources-UnloadUnusedAssets"><a href="#Resources-UnloadUnusedAssets" class="headerlink" title="Resources.UnloadUnusedAssets"></a>Resources.UnloadUnusedAssets</h4><p>卸载掉没有使用的Assets，作用范围是整个系统。</p><p>作用方式类似于GC，会遍历所有资源进行引用查询，会阻塞线程。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><code>AssetBundle.Unload(false)</code>更适用于一次性使用的资源，卸载后，在特定时机触发<code>Resources.UnloadUnusedAssets</code>就能卸载干净了。</p><p><code>AssetBundle.Unload(true)</code>使用时最好添加引用计数作为保护。或在应用程序生命周期中具有明确定义的卸载瞬态 AssetBundle 的时间点，例如在关卡之间或在加载屏幕期间。</p><h3 id="AssetBundle变体"><a href="#AssetBundle变体" class="headerlink" title="AssetBundle变体"></a>AssetBundle变体</h3><p>在Android 生态中有些设备不支持ETC2的纹理只支持ETC1的纹理，那么可以构建AssetBundle变体。使用ETC1支持的资源格式来构建AssetBundle变体，构建足够多的变体来支持Android 生态中不支持ETC2的设备。</p>]]></content>
    
    
    <categories>
      
      <category>资源管理篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>资源管理 AssetBundle 热更新</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>纹理详解</title>
    <link href="/2023/07/14/%E7%BA%B9%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/07/14/%E7%BA%B9%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="纹理详解"><a href="#纹理详解" class="headerlink" title="纹理详解"></a>纹理详解</h1><h3 id="图像容量大小"><a href="#图像容量大小" class="headerlink" title="图像容量大小"></a>图像容量大小</h3><p><code>bpp</code>每个像素的内存消耗</p><p>总图像存储大小 = width * height * bpp</p><h3 id="Non-Power-of-2"><a href="#Non-Power-of-2" class="headerlink" title="Non Power of 2"></a>Non Power of 2</h3><p>长、宽不全是2的幂次尺寸的图片称为 NPOT（Non Power Of Two）格式的图片。</p><p>对于项目中需要压缩的贴图，需要尽量做成POT</p><p>NPOT转成POT后，进行ToNearest操作可以压缩到六分之一大小。压缩比1：6</p><h2 id="图片格式"><a href="#图片格式" class="headerlink" title="图片格式"></a>图片格式</h2><h3 id="jpg"><a href="#jpg" class="headerlink" title="jpg"></a>jpg</h3><p>有损压缩</p><p>不带Alpha通道</p><p>不可编辑，读取时需要先读取整张图片，再读取具体内容</p><h3 id="png"><a href="#png" class="headerlink" title="png"></a>png</h3><p>无损压缩</p><p>带Alpha通道</p><p>可编辑，可以直接读取具体内容</p><h2 id="纹理格式"><a href="#纹理格式" class="headerlink" title="纹理格式"></a>纹理格式</h2><h3 id="对于所有平台"><a href="#对于所有平台" class="headerlink" title="对于所有平台"></a>对于所有平台</h3><h4 id="RGBA-32Bit"><a href="#RGBA-32Bit" class="headerlink" title="RGBA 32Bit"></a>RGBA 32Bit</h4><p>一个像素由红、绿、蓝三个色彩通道都由8位色彩深度组成，加上Alpha通道的8位，共计32位Bit。</p><p>Alpha通道8bit可以表示256级灰度，即透明度。</p><p>优点：适用所有设备</p><p>缺点：内存占用太高，移动平台基本不会直接使用</p><p>适用平台：Android、IOS</p><h4 id="RGBA-16Bit"><a href="#RGBA-16Bit" class="headerlink" title="RGBA 16Bit"></a>RGBA 16Bit</h4><p>红色通道、绿色通道、蓝色通道和alpha 通道各4位。</p><h4 id="Alpha8"><a href="#Alpha8" class="headerlink" title="Alpha8"></a>Alpha8</h4><p> 只有透明度，没有颜色。</p><h4 id="ASTC"><a href="#ASTC" class="headerlink" title="ASTC"></a>ASTC</h4><p>要求：iOS A8 处理器(iPhone6及iPad mini 4以上iOS设备)、Android 需要设备GPU支持 OpenGL ES 3.1及以上即部分 ES 3.0</p><p>优点：压缩后图片画质好、自由度高，有多种格式可以选择4x4~12x12、不要求图片尺寸</p><p>缺点：需要考虑支持的设备市场普及率，看了相关的几篇机型调查文章。不支持ES3.1的Android机型大概为1.5%，IOS基本没有。</p><p>适用平台：Android、IOS</p><p>注意：在不支持的设备上，贴图会解压成RGB(A)，然后与压缩的贴图一起存储在内存中，会增加纹理加载时间和增加额外内存</p><p><img src="/2023/07/14/%E7%BA%B9%E7%90%86%E8%AF%A6%E8%A7%A3/v2-4607b8ab1d63fd97ea6b47fdd6a1fcfb_b.jpg" alt="img"></p><h5 id="关于法线贴图"><a href="#关于法线贴图" class="headerlink" title="关于法线贴图"></a>关于法线贴图</h5><p>法线贴图要求的质量会高一些，压缩度越高失真越严重，一般为 5 x 5 或 6 x 6</p><h3 id="对于Android平台"><a href="#对于Android平台" class="headerlink" title="对于Android平台"></a>对于Android平台</h3><h4 id="ETC1"><a href="#ETC1" class="headerlink" title="ETC1"></a>ETC1</h4><p>要求：贴图的长宽为2次幂</p><p>优点：适用所有的Android设备、压缩率较高</p><p>缺点：不支持带 Alpha 通道的贴图、肉眼可见失真，图集需要一张额外的Alpha通道的贴图。</p><p>适用平台：Android</p><p>压缩的RGB纹理。这是Android工程默认的纹理格式。ETC1是OpenGL ES 2.0标准的一部分，并且<strong>支持所有的OpenGL ES 2.0 GPU</strong>，但它<strong>不支持Alpha。</strong></p><h4 id="ETC2"><a href="#ETC2" class="headerlink" title="ETC2"></a>ETC2</h4><p>要求：贴图的长宽要能被4整除、OpenGL ES 3.0及以上</p><p>优点：支持Alpha通道的贴图</p><p>缺点：内存占用大于ETC1格式</p><p>适用平台：Android</p><p>注意：在不支持 ETC2 的 Android 平台上，纹理在运行时解压缩为 Build Settings 中的 ETC2 fallback 指定的格式，默认自动转成RGBA32/ARGB32的格式</p><h3 id="对于IOS平台"><a href="#对于IOS平台" class="headerlink" title="对于IOS平台"></a>对于IOS平台</h3><h4 id="PVRTC"><a href="#PVRTC" class="headerlink" title="PVRTC"></a>PVRTC</h4><p>要求长宽相等。且为2的幂次方</p><p>有些GUP不支持NPOT，遇到NPOT会有一个转换POT的过程，浪费性能</p><h2 id="Texture-Cache"><a href="#Texture-Cache" class="headerlink" title="Texture Cache"></a>Texture Cache</h2><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>PS：在图集在纹理采样时，如果尺寸不是2次幂会被引擎层拉伸成2次幂，因为GPU光栅化需要对纹理采样进行快速取值。所以存储时如果非2次幂则节省内存，但是采样时会消耗额外性能；存储时如果拉伸为2次幂存储则费内存，采样时则节省性能。</p><h2 id="TexturePacker工具"><a href="#TexturePacker工具" class="headerlink" title="TexturePacker工具"></a>TexturePacker工具</h2><h3 id="TP工具打图集流程"><a href="#TP工具打图集流程" class="headerlink" title="TP工具打图集流程"></a>TP工具打图集流程</h3><ol><li><p>调用TexturePacker 命令行打图集</p><p>下载TexturePacker工具，然后用命令行调用tp打图集，完成之后会生成2个文件，一张打好的图集，一份保存了真实图片的位置信息.txt文件</p></li><li><p>拆分alpha通道</p></li><li><p>texture导入精灵图(spritesheet)</p></li><li><p>生成材质球</p></li><li><p>生成预制，将padding信息保存在so里【atlas_tp_padding.asset】，游戏运作中需要用到</p></li></ol><h3 id="Padding信息存储和读取"><a href="#Padding信息存储和读取" class="headerlink" title="Padding信息存储和读取"></a>Padding信息存储和读取</h3><p>在打图集的时候，保存图片的位置信息，然后在图片绘制网格的时候，读取这些信息，计算出真实的位置信息，再将像素绘制上去</p><h4 id="Image一些接口说明"><a href="#Image一些接口说明" class="headerlink" title="Image一些接口说明"></a>Image一些接口说明</h4><h5 id="UGUI的OnPopulateMesh函数"><a href="#UGUI的OnPopulateMesh函数" class="headerlink" title="UGUI的OnPopulateMesh函数"></a>UGUI的OnPopulateMesh函数</h5><p>UGUI中与显示相关的控件，例如<strong>Image、Text、RawImage</strong>等都继承自MaskableGraphic类，MaskableGraphic类继承自Graphic类。</p><p>控件在画面中的<strong>形状、颜色、法线等信息都是由Graphics类中的OnPopulateMesh函数所控制</strong><br><strong>每当改变了顶点或者纹理后，会调用OnPopulateMesh函数</strong><br>其中VertexHelper是一个顶点辅助类，保存着生成Mesh的基本信息</p><h5 id="绘制图形"><a href="#绘制图形" class="headerlink" title="绘制图形"></a>绘制图形</h5><ul><li>AddVert<ul><li>添加顶点(第一个添加的顶点索引为0，第二个添加的顶点为1，依次…..)</li></ul></li><li>AddTriangle<ul><li>绘制三角形(GPU绘制时会按照输入的顶点下标的顺序绘制一个三角形)</li><li>绘制四边形时，就是绘制两个三角形。</li></ul></li><li>currentIndexCount<ul><li>VertexHelper结构中有几个顶点索引(重合的顶点被计为2个顶点，例如一个三角形最少有3个顶点，一个正方形最少有6个顶点)</li></ul></li><li>currentVertCount<ul><li>VertexHelper结构中有几个顶点(AddVert添加了几个顶点就有几个)</li></ul></li><li>PopulateUIVertex<ul><li>获取某个索引的顶点数据</li></ul></li><li>SetUIVertex<ul><li>设置某个索引的顶点数据</li></ul></li><li>AddUIVertexQuad<ul><li>把AddVert和AddTriangle封装到一个函数中</li></ul></li><li>AddUIVertexStream<ul><li>把AddVert和AddTriangle封装到一个函数中</li></ul></li></ul><h5 id="sprite和overrideSprite的区别"><a href="#sprite和overrideSprite的区别" class="headerlink" title="sprite和overrideSprite的区别"></a>sprite和overrideSprite的区别</h5><p>官方的说法，overrideSprite 用于临时修改图片，sprite 用于永久修改图片。</p><p>overrideSprite 用于修改图片，但是不会把原来的图片给消除掉，直接的效果是如果 overrideSprite 是 null 的话，会变回原本的图片。可以理解为 overrdieSprite 是覆盖在 sprite 上的一层图片。所以，若使用 overrideSprite 更换图片，接下来要更换也只能用overrideSprite再覆盖掉，除非把它置为 null，不然用 sprite 更换是显示不出来的。</p><h4 id="写入padding信息"><a href="#写入padding信息" class="headerlink" title="写入padding信息"></a>写入padding信息</h4><p><img src="/2023/07/14/%E7%BA%B9%E7%90%86%E8%AF%A6%E8%A7%A3/image-20230628202236053.png"></p><p><code>spriteSourceSize</code>为真实图片的位置信息。</p><p><code>sourceSize</code>为原本的图片信息。</p><p><code>padding</code>为</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">float</span> left = frame.spriteSourceSize.x;<br><span class="hljs-built_in">float</span> top = frame.spriteSourceSize.y;<br><span class="hljs-built_in">float</span> right = frame.sourceSize.x - frame.spriteSourceSize.x - frame.spriteSourceSize.width;<br><span class="hljs-built_in">float</span> bottom = frame.sourceSize.y - frame.spriteSourceSize.y - frame.spriteSourceSize.height;<br></code></pre></td></tr></tbody></table></figure><h4 id="运行时设置padding信息"><a href="#运行时设置padding信息" class="headerlink" title="运行时设置padding信息"></a>运行时设置padding信息</h4><p>SpriteAssetMoudle初始化Init时，设置SDImage的静态对象`m_spritePaddingMap</p><p><code>m_spritePaddingMap&lt;string,Vector4&gt;</code>spriteName为key，padding参数为value。</p><h4 id="重写OnPopulateMesh接口"><a href="#重写OnPopulateMesh接口" class="headerlink" title="重写OnPopulateMesh接口"></a>重写OnPopulateMesh接口</h4><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">protected</span> Vector4 <span class="hljs-title">GetDrawingDimensions</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> shouldPreserveAspect</span>)</span><br>{<br>    Sprite overrideSprite = <span class="hljs-keyword">this</span>.overrideSprite;<br>    <span class="hljs-keyword">var</span> padding = GetPadding();<br>    <span class="hljs-keyword">var</span> size = overrideSprite == <span class="hljs-literal">null</span> ? Vector2.zero : <span class="hljs-keyword">new</span> Vector2(overrideSprite.rect.width, overrideSprite.rect.height);<br>    Rect r = GetPixelAdjustedRect();<br>    <span class="hljs-built_in">int</span> spriteW = Mathf.RoundToInt(size.x);<br>    <span class="hljs-built_in">int</span> spriteH = Mathf.RoundToInt(size.y);<br>    <span class="hljs-built_in">float</span> width = spriteW + padding.z + padding.x;<br>    <span class="hljs-built_in">float</span> height = spriteH + padding.w + padding.y;<br><br>    <span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> Vector4(<br>        padding.x / width,<br>        padding.y / height,<br>        (width - padding.z) / width,<br>        (height - padding.w) / height);<br><br>    <span class="hljs-keyword">if</span> (shouldPreserveAspect &amp;&amp; size.sqrMagnitude &gt; <span class="hljs-number">0.0f</span>)<br>    {<br>        <span class="hljs-keyword">var</span> spriteRatio = size.x / size.y;<br>        <span class="hljs-keyword">var</span> rectRatio = r.width / r.height;<br><br>        <span class="hljs-keyword">if</span> (spriteRatio &gt; rectRatio)<br>        {<br>            <span class="hljs-keyword">var</span> oldHeight = r.height;<br>            r.height = r.width * (<span class="hljs-number">1.0f</span> / spriteRatio);<br>            r.y += (oldHeight - r.height) * rectTransform.pivot.y;<br>        }<br>        <span class="hljs-keyword">else</span><br>        {<br>            <span class="hljs-keyword">var</span> oldWidth = r.width;<br>            r.width = r.height * spriteRatio;<br>            r.x += (oldWidth - r.width) * rectTransform.pivot.x;<br>        }<br>    }<br>    <span class="hljs-comment">//根据padding值换算出来的比例来计算新的 image顶点位置</span><br>    v = <span class="hljs-keyword">new</span> Vector4(<br>        r.x + r.width * v.x,<br>        r.y + r.height * v.y,<br>        r.x + r.width * v.z,<br>        r.y + r.height * v.w<br>    );<br><br>    <span class="hljs-keyword">return</span> v;<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="获取Padding信息"><a href="#获取Padding信息" class="headerlink" title="获取Padding信息"></a>获取Padding信息</h4><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">protected</span> Vector4 <span class="hljs-title">GetPadding</span>()</span><br>{<br>    <span class="hljs-keyword">if</span> (GameMain.Instance != <span class="hljs-literal">null</span> &amp;&amp; GameMain.Instance.enabled)<br>    {<br>        <span class="hljs-keyword">if</span> (m_IsUrl || <span class="hljs-built_in">string</span>.IsNullOrEmpty(SpriteName))<br>        {<br>            <span class="hljs-keyword">return</span> Vector4.zero;<br>        }<br>        <span class="hljs-keyword">if</span> (m_spritePaddings == <span class="hljs-literal">null</span>)<br>        {<br>            <span class="hljs-comment">//Debug.LogError("SpritePadding error");</span><br>            <span class="hljs-keyword">return</span> Vector4.zero;<br>        }<br>        <span class="hljs-keyword">if</span> (m_spritePaddings.ContainsKey(SpriteName))<br>        {<br>            <span class="hljs-keyword">return</span> m_spritePaddings[SpriteName];<br>        }<br>        <span class="hljs-keyword">return</span> Vector4.zero;<br>    }<br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> UNITY_EDITOR</span><br>        <span class="hljs-keyword">if</span> (!overrideSprite)<br>            <span class="hljs-keyword">return</span> Vector4.zero;<br>    <span class="hljs-keyword">if</span> (UseSpritePacker)<br>    {<br>        <span class="hljs-keyword">return</span> DataUtility.GetPadding(overrideSprite);<br>    }<br><br><br>    <span class="hljs-keyword">if</span> (m_spritePaddings == <span class="hljs-literal">null</span>)<br>    {<br>        <span class="hljs-built_in">string</span> path = PathDef.UI_ASSETS_PATH + <span class="hljs-string">"/atlas_tp_padding.asset"</span>;<br>        PaddingData paddingData = AssetDatabase.LoadAssetAtPath&lt;PaddingData&gt;(path);<br>        m_spritePaddings = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, Vector4&gt;();<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> atlas <span class="hljs-keyword">in</span> paddingData.atlas)<br>        {<br>            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> spriteInfo <span class="hljs-keyword">in</span> atlas.spritesHavePadding)<br>            {<br>                <span class="hljs-keyword">if</span> (m_spritePaddings.ContainsKey(spriteInfo.name)) <span class="hljs-keyword">continue</span>;<br>                m_spritePaddings.Add(spriteInfo.name, spriteInfo.padding);<br>            }<br>        }<br>    }<br><br>    Vector4 v;<br>    <span class="hljs-keyword">if</span> (!m_spritePaddings.TryGetValue(overrideSprite.name, <span class="hljs-keyword">out</span> v))<br>    {<br>        <span class="hljs-comment">//Debuger.LogError("图集错误. 白边信息缺失: sprite:" + overrideSprite.name);</span><br>        <span class="hljs-keyword">return</span> Vector4.zero;<br>    }<br>    <span class="hljs-keyword">return</span> v;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        <span class="hljs-keyword">return</span> Vector4.zero;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="Texture相关"><a href="#Texture相关" class="headerlink" title="Texture相关"></a>Texture相关</h3><h4 id="TextureImporter"><a href="#TextureImporter" class="headerlink" title="TextureImporter"></a>TextureImporter</h4><p>此类中的设置与 <a href="https://docs.unity.cn/cn/current/Manual/class-TextureImporter.html">Texture Import Settings</a> 中显示的设置相匹配。</p><p><a href="https://docs.unity.cn/cn/current/ScriptReference/TextureImporter.html">UnityEditor.TextureImporter - Unity 脚本 API</a></p><h4 id="TextureImporterPlatformSettings"><a href="#TextureImporterPlatformSettings" class="headerlink" title="TextureImporterPlatformSettings"></a>TextureImporterPlatformSettings</h4><p>存储 TextureImporter 的平台特定设置。</p><p><a href="https://docs.unity.cn/cn/current/ScriptReference/TextureImporterPlatformSettings.html">UnityEditor.TextureImporterPlatformSettings - Unity 脚本 API</a></p><h4 id="SpriteMetaData"><a href="#SpriteMetaData" class="headerlink" title="SpriteMetaData"></a>SpriteMetaData</h4><p><a href="https://docs.unity.cn/cn/2021.1/ScriptReference/SpriteMetaData.html">UnityEditor.SpriteMetaData - Unity 脚本 API</a></p><h4 id="EditorUtility"><a href="#EditorUtility" class="headerlink" title="EditorUtility"></a>EditorUtility</h4><p><a href="https://docs.unity.cn/cn/2019.4/ScriptReference/EditorUtility.html">UnityEditor.EditorUtility - Unity 脚本 API</a></p><h4 id="Generate-Mip-Maps-属性"><a href="#Generate-Mip-Maps-属性" class="headerlink" title="Generate Mip Maps 属性"></a><strong>Generate Mip Maps 属性</strong></h4><p>开启Mipmaps可以使远离相机的物体使用较小的纹理版本，这样渲染时，显存带宽压力比较小，同时避免显示效果产生噪点（pix fight）。</p><h4 id="Read-x2F-Write-Enabled-属性"><a href="#Read-x2F-Write-Enabled-属性" class="headerlink" title="Read/Write Enabled 属性"></a><strong>Read/Write Enabled 属性</strong></h4><p>Read/Write Enabled选项打开的时候主要是为了外部可以通过脚本进行一个修改，例如通过Texture2D.SetPixels、Texture2D.GetPixels和其他一些方法进行问理数据的访问。<strong>但是内部的话，unity并不是直接在原有的纹理上去做这些操作的，毕竟一个贴图可能用在很多地方，直接在原纹理图上进行修改的话，那么所有使用这个纹理的地方都会受到影响。</strong>所以内部unity会对原纹理进行一个拷贝产生一个副本，所有的读写操作都是在副本上进行完成的。所以产生一个副本的话，自然内存是会加倍的。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网络游戏架构设计</title>
    <link href="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="网络游戏架构设计"><a href="#网络游戏架构设计" class="headerlink" title="网络游戏架构设计"></a>网络游戏架构设计</h1><h2 id="第一节-代码结构"><a href="#第一节-代码结构" class="headerlink" title="第一节 代码结构"></a>第一节 代码结构</h2><h3 id="项目代码结构需要满足的需求"><a href="#项目代码结构需要满足的需求" class="headerlink" title="项目代码结构需要满足的需求"></a>项目代码结构需要满足的需求</h3><h4 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h4><p>需要把Unity的MonoBehaviour等等这些和Unity交互较深的脚本进行分离</p><p>至少有一个热更新的程序集</p><h4 id="数据跟方法分离，热重载"><a href="#数据跟方法分离，热重载" class="headerlink" title="数据跟方法分离，热重载"></a>数据跟方法分离，热重载</h4><h5 id="热重载"><a href="#热重载" class="headerlink" title="热重载"></a>热重载</h5><p>​热重载只是数据跟方法分离后得到的好处</p><p>​热重载便于改bug，节省重现环节。</p><h5 id="数据跟方法分离"><a href="#数据跟方法分离" class="headerlink" title="数据跟方法分离"></a>数据跟方法分离</h5><p>​在C语言中叫做<code>data + function</code>的设计。数据就是定义数据结构，方法则是面向过程的方法。</p><p>​相比于面向对象而已没有类与类之间的关联，只有方法和方法的关联，便于重构。</p><h4 id="逻辑跟表现分离"><a href="#逻辑跟表现分离" class="headerlink" title="逻辑跟表现分离"></a>逻辑跟表现分离</h4><p>数据是同步的，而表现可能是异步的情况。在表现过程中可能会有一些资源加载的操作，在这个过程中逻辑发生了变化，表现也需要发生变化。</p><p>预表现。表现层可能提前做出一些表现比如一些战斗前摇，但是对逻辑层没有什么影响。等逻辑层同步了命中逻辑后，再播放命中的表现。</p><p>在MMO的切换场景中，服务器通知场景切换后，客户端逻辑层加载数据，表现层则在数据加载完成后开始异步加载场景。服务器再通知单位模型的数据后，客户端逻辑层整理数据后，表现成开始异步加载单位模型。</p><p>帧同步。帧同步两端的逻辑层的逻辑是一样的。而状态同步逻辑在服务端，两端的逻辑层实际上也是一样的。区别只在于一个是客户端计算一个是服务端计算。 帧同步如果把逻辑层看做是一个服务端，看起来就像是逻辑层在给表现层发消息。逻辑是离散的，表现是要做插值的。</p><h4 id="ECS数据驱动"><a href="#ECS数据驱动" class="headerlink" title="ECS数据驱动"></a>ECS数据驱动</h4><p>数据变化是通过事件通知的。逻辑和表现监听事件产生变化。</p><h3 id="ET版本变更"><a href="#ET版本变更" class="headerlink" title="ET版本变更"></a>ET版本变更</h3><h4 id="1-0"><a href="#1-0" class="headerlink" title="1.0"></a>1.0</h4><p>客户端</p><ul><li>Hoxfix 热更层</li><li>Main 主工程</li></ul><p>服务端</p><ul><li>Hoxfix 纯逻辑</li><li>Main 纯数据</li></ul><h4 id="中间版本"><a href="#中间版本" class="headerlink" title="中间版本"></a>中间版本</h4><p>客户端 </p><p>asmdef功能，多个程序集提升编译速度</p><ul><li>Hoxfix热更层</li><li>Loader 游戏入口，可放Unity脚本</li><li>Core 框架核心</li><li>ThirdParty 第三方库</li></ul><p>服务端</p><ul><li>Hoxfix</li><li>Model</li><li>Loader</li><li>Core</li><li>ThirdParty</li></ul><h4 id="热重载需求"><a href="#热重载需求" class="headerlink" title="热重载需求"></a>热重载需求</h4><p>客户端</p><ul><li>Hoxfix 热更层的逻辑层  <ul><li>纯逻辑改变时不用关闭游戏，直接重载这个程序集</li></ul></li><li>Model 热更层的数据层</li><li>Loader 游戏入口，可放Unity脚本</li><li>Core 框架核心</li><li>ThirdParty 第三方库</li></ul><h4 id="另一种划分"><a href="#另一种划分" class="headerlink" title="另一种划分"></a>另一种划分</h4><ul><li>HoxfixView 表现层</li><li>Hoxfix 逻辑层 抛事件通知表现层</li><li>Loader</li><li>ThridParty</li><li>Core</li></ul><h4 id="结合前面两个版本"><a href="#结合前面两个版本" class="headerlink" title="结合前面两个版本"></a>结合前面两个版本</h4><h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><ul><li>HoxfixView 表现层的方法</li><li>ModelView 表现层数据结构</li><li>Hofix 逻辑层方法</li><li>Model 逻辑层数据</li><li>Loader</li><li>Core</li><li>ThridParty</li></ul><p>前四个程序集编译在一起做热更新。HofixView和Hofix编译在一起做热重载。</p><p>并且逻辑和表现分离</p><h5 id="Robot"><a href="#Robot" class="headerlink" title="Robot"></a>Robot</h5><ul><li>Hofix 逻辑层方法</li><li>Model 逻辑层数据</li><li>Loader</li><li>Core</li><li>ThridParty</li></ul><p>去掉客户端的表现层，就是机器人的程序集了。</p><p>Hofix和Model共用客户端的程序集。</p><h2 id="第二节-All-In-One"><a href="#第二节-All-In-One" class="headerlink" title="第二节 All In One"></a>第二节 All In One</h2><h3 id="各类服务器进程合并"><a href="#各类服务器进程合并" class="headerlink" title="各类服务器进程合并"></a>各类服务器进程合并</h3><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230308124513.png" alt="微信图片_20230308124513"></p><p>很多多进程的设计，都把一个服务整理成一个exe。多个服务就有多个exe，代码可能是高度相似的，或者基本一样的。只是启动时环境变量不同。合并成一个exe并设置环境变量。</p><ul><li>发布部署简单、配置资源方便、多种服务共用进程。</li><li>结构调整容易，比如两种或多种服务要合并，拆分<ul><li>多个exe会有多个进程，当其中一部分逻辑压力过大时（比如一个中心服有好友和组队功能，好友功能压力过大时 ）不好拆分，需要再拆成多个exe。</li><li>无限增加app类型，千古风流有几十种SceneType</li><li>根据配置需要什么服务，就配置什么类型。多个服务配置在一个进程内。</li></ul></li></ul><h3 id="后端和机器人合并"><a href="#后端和机器人合并" class="headerlink" title="后端和机器人合并"></a>后端和机器人合并</h3><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230308124518-1678250733684.jpg" alt="微信图片_20230308124518"></p><p>机器人和服务器的代码基本一样。也引用了大部分的后端代码。还引用了客户端的逻辑代码。代码引用很乱。</p><p>机器人要单独起一个exe很不方便，跑测试需要起两个进程。</p><h4 id="server和机器人合并带来的问题"><a href="#server和机器人合并带来的问题" class="headerlink" title="server和机器人合并带来的问题"></a>server和机器人合并带来的问题</h4><ul><li>代码类重名<ul><li>合并后分别引用了客户端和服务端的代码。两端代码的类名重名（item、buff）。</li><li>用命名空间隔离解决重名冲突，带来的好处只需要检查目录下的命名空间就能保证不会调用到错误的代码。</li><li>ET.Server、ET.Client</li></ul></li><li>事件订阅怎么区分前后端<ul><li>有些工具类，或数值组件这种两端共用的代码就不用隔离。ET</li><li>比如单位组件，前后端都有抛出的事件很难做区分。需要区分订阅。</li><li>通过场景类型做区分SceneType</li></ul></li><li>配置文件结构不同怎么共享<ul><li>问题也不大，大不了两端配置都存在。</li></ul></li></ul><p>机器人在写组队逻辑时很有用。</p><h3 id="前端跟后端合并"><a href="#前端跟后端合并" class="headerlink" title="前端跟后端合并"></a>前端跟后端合并</h3><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230308123835.jpg" alt="微信图片_20230308123835"></p><h4 id="不需要单独起服务端，前后端代码共享更方便"><a href="#不需要单独起服务端，前后端代码共享更方便" class="headerlink" title="不需要单独起服务端，前后端代码共享更方便"></a>不需要单独起服务端，前后端代码共享更方便</h4><p>不需要单独启动服务器，unity一启动就启动前后端代码。</p><p>前后端代码的共享，前端可以包含一个服务器，后端可以包含前端的逻辑做个机器人。</p><h4 id="后端可以更方便做Unity可视化工具，可视化树ENABLE-VIEW"><a href="#后端可以更方便做Unity可视化工具，可视化树ENABLE-VIEW" class="headerlink" title="后端可以更方便做Unity可视化工具，可视化树ENABLE_VIEW"></a>后端可以更方便做Unity可视化工具，可视化树ENABLE_VIEW</h4><p>后端如果是命令行程序，做数据可视化很困难。</p><p>写后端就像写前端一样简单，比如写个行为树，后端可以直接调试，前端可以直接拿到后端数据。</p><p>ET7加上ENABLE_VIEW宏开启可视化树</p><h4 id="更方便做插件机制"><a href="#更方便做插件机制" class="headerlink" title="更方便做插件机制"></a>更方便做插件机制</h4><p>用unity的导入导出做插件机制。</p><h4 id="各种游戏代码合并的需求分析"><a href="#各种游戏代码合并的需求分析" class="headerlink" title="各种游戏代码合并的需求分析"></a>各种游戏代码合并的需求分析</h4><h5 id="竞技游戏"><a href="#竞技游戏" class="headerlink" title="竞技游戏"></a>竞技游戏</h5><p>比如守望先锋，用的状态帧同步。本地先预测下一帧行为，服务器同步下来如果结果不符合则进行回滚。那么两端肯定有相同代码，否则产生结果肯定是不一致的。</p><h5 id="MMO游戏、MOBA游戏"><a href="#MMO游戏、MOBA游戏" class="headerlink" title="MMO游戏、MOBA游戏"></a>MMO游戏、MOBA游戏</h5><p>模拟机器人的需求，充当普通玩家。</p><p>机器人压测需求。</p><h5 id="状态同步"><a href="#状态同步" class="headerlink" title="状态同步"></a>状态同步</h5><p>客户端预测和服务器权威数据跑的代码基本一致。</p><h5 id="帧同步"><a href="#帧同步" class="headerlink" title="帧同步"></a>帧同步</h5><p>逻辑都在客户端，但是在结算结果的时候数据不权威。后期帧同步，很多是依靠服务器也跑一份逻辑，根据跑出来的结果判定结算。也是防作弊很重要的内容。</p><h3 id="前端和后端合并的细节问题"><a href="#前端和后端合并的细节问题" class="headerlink" title="前端和后端合并的细节问题"></a>前端和后端合并的细节问题</h3><h4 id="怎么区分编译前端代码跟后端代码，还有双端编译"><a href="#怎么区分编译前端代码跟后端代码，还有双端编译" class="headerlink" title="怎么区分编译前端代码跟后端代码，还有双端编译"></a>怎么区分编译前端代码跟后端代码，还有双端编译</h4><p>搞一个编译工具，按照需求选择编译</p><h4 id="配置要区分前端跟后端，以及双端，configpatial的处理"><a href="#配置要区分前端跟后端，以及双端，configpatial的处理" class="headerlink" title="配置要区分前端跟后端，以及双端，configpatial的处理"></a>配置要区分前端跟后端，以及双端，configpatial的处理</h4><p>有些配置不需要双端都知道的，比如前端的特效，或后端比较权威计算的数值。</p><p>这就需要导出三份配置。C、CS、S</p><p>config patial就是把配置反序列化成需要的类对象的工具</p><p>config patial不能共享，需要写三份。</p><p>消息要区分前后端，以及双端。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230308123804-1678250496566.jpg" alt="微信图片_20230308123804"></p><p>把服务器逻辑代码也写在客户端程序集内，直接引用。</p><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230308005444.jpg" alt="微信图片_20230308005444"></p><h2 id="第三节-单间管理器"><a href="#第三节-单间管理器" class="headerlink" title="第三节 单间管理器"></a>第三节 单间管理器</h2><h3 id="为什么需要单间管理器？"><a href="#为什么需要单间管理器？" class="headerlink" title="为什么需要单间管理器？"></a>为什么需要单间管理器？</h3><h4 id="统一管理单间类。单间类的问题？"><a href="#统一管理单间类。单间类的问题？" class="headerlink" title="统一管理单间类。单间类的问题？"></a>统一管理单间类。单间类的问题？</h4><p>单间类生命周期的问题，创建了什么时候释放的问题。</p><p>内存随着生命周期清理的问题。</p><h4 id="统一管理基础库，灵活引入基础库"><a href="#统一管理基础库，灵活引入基础库" class="headerlink" title="统一管理基础库，灵活引入基础库"></a>统一管理基础库，灵活引入基础库</h4><h4 id="消除静态字段"><a href="#消除静态字段" class="headerlink" title="消除静态字段"></a>消除静态字段</h4><p><code>static Dictionary</code>这种静态变量，生命周期清理的问题。</p><h4 id="Unity-domain模式"><a href="#Unity-domain模式" class="headerlink" title="Unity domain模式"></a>Unity domain模式</h4><p>domain模式为了提升性能不清理静态字段，需要自己清理。</p><h4 id="为什么不用组件？"><a href="#为什么不用组件？" class="headerlink" title="为什么不用组件？"></a>为什么不用组件？</h4><p>组件本身需要一些额外的东西，比如创建的时候需要对象池。对象池又是谁管理。就可以使用单间管理器创建对象池。</p><h4 id="为什么用Game-AddSingleton-创建单间"><a href="#为什么用Game-AddSingleton-创建单间" class="headerlink" title="为什么用Game.AddSingleton 创建单间"></a>为什么用Game.AddSingleton 创建单间</h4><p><code>Game.AddSingleton&lt;TimeInfo&gt;();</code></p><h5 id="代码可读性，明确知道单间初始化的地方。"><a href="#代码可读性，明确知道单间初始化的地方。" class="headerlink" title="代码可读性，明确知道单间初始化的地方。"></a>代码可读性，明确知道单间初始化的地方。</h5><p>如果都是<code>Instance</code>很难找到哪里是初始化的地方。</p><h5 id="明确知道初始化顺序，方便调整"><a href="#明确知道初始化顺序，方便调整" class="headerlink" title="明确知道初始化顺序，方便调整"></a>明确知道初始化顺序，方便调整</h5><h5 id="好释放，相反的顺序释放"><a href="#好释放，相反的顺序释放" class="headerlink" title="好释放，相反的顺序释放"></a>好释放，相反的顺序释放</h5><p>明确知道了初始化顺序，能更明确释放的顺序。</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ISingleton</span>: <span class="hljs-title">IDisposable</span><br>{<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Register</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Destroy</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">IsDisposed</span>()</span>;<br>}<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>&lt;<span class="hljs-title">T</span>&gt;: <span class="hljs-title">ISingleton</span> <span class="hljs-keyword">where</span> <span class="hljs-title">T</span>: <span class="hljs-title">Singleton</span>&lt;<span class="hljs-title">T</span>&gt;, <span class="hljs-title">new</span>(){<br><br>}<br></code></pre></td></tr></tbody></table></figure><h5 id="通过接口创建生命周期"><a href="#通过接口创建生命周期" class="headerlink" title="通过接口创建生命周期"></a>通过接口创建生命周期</h5><p><code>ISingletonAwake</code> 、<code>ISingletonUpdate</code> 、<code>ISingletonLateUpdate</code></p><p><code>AddSingleton</code>时判断是否有生命周期接口，如果有添加对应生命周期。</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddSingleton</span>(<span class="hljs-params">ISingleton singleton</span>)</span><br>{<br>    Type singletonType = singleton.GetType();<br>    <span class="hljs-keyword">if</span> (singletonTypes.ContainsKey(singletonType))<br>    {<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">$"already exist singleton: <span class="hljs-subst">{singletonType.Name}</span>"</span>);<br>    }<br><br>    singletonTypes.Add(singletonType, singleton);<br>    <span class="hljs-comment">//管理单间加载顺序，做卸载时可用</span><br>    singletons.Push(singleton);<br><br>    singleton.Register();<br><br>    <span class="hljs-keyword">if</span> (singleton <span class="hljs-keyword">is</span> ISingletonAwake awake)<br>    {<br>        awake.Awake();<br>    }<br><br>    <span class="hljs-keyword">if</span> (singleton <span class="hljs-keyword">is</span> ISingletonUpdate)<br>    {<br>        updates.Enqueue(singleton);<br>    }<br><br>    <span class="hljs-keyword">if</span> (singleton <span class="hljs-keyword">is</span> ISingletonLateUpdate)<br>    {<br>        lateUpdates.Enqueue(singleton);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="第四节-多线程、单线程、Task-await-async的关系"><a href="#第四节-多线程、单线程、Task-await-async的关系" class="headerlink" title="第四节 多线程、单线程、Task await async的关系"></a>第四节 多线程、单线程、Task await async的关系</h2><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>使用多线程去执行复杂逻辑时，callback会在执行线程继续执行进行响应。</p><p>比如寻路的逻辑比较复杂抛给其他线程去处理，响应回调时也是会在寻路线程进行响应。</p><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230308233904030.png" alt="image-20230308233904030"></p><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><p>当遇到框架内的api都是单线程的api时，必须在主线程完成回调。在其他线程响应回调会导致线程竞争。</p><p>解决方法也很简单，在其他线程响应回调时把回调放到一个缓存队列中（需要同步上下文），在主线程的update里不断去取缓存队列中的响应，并去执行它。就能把回调丢回到主线程执行。(C++中的没有task而使用的手法)</p><p>详情看看MainThreadSynchronizationContext这个类</p><h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><p>线程消耗比较大，创建的时候一般都使用线程池。Task就是线程池封装的结果。</p><p>Task 执行的线程和响应回调的线程不一致，回调的响应会丢到其他线程执行。</p><p>Task本质就是个状态机，当设置了同步上下文时，回调会被自动调整到主线程执行。 编译器帮我们做了这一步</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StartTask</span>()</span>{<br>SynchronizationContext synchronizationContext = SynchronizationContext.Current;<br>    <span class="hljs-keyword">await</span> Task.Run(FindPath);<br>    <span class="hljs-keyword">if</span>(synchronizationContext == <span class="hljs-literal">null</span>){<br>        <span class="hljs-comment">//没设置同步上下文会在当前线程响应。</span><br>        SendMessage();<br>    }<span class="hljs-keyword">else</span>{<br>        <span class="hljs-comment">//设置了同步上下文实际会在设置的线程响应。</span><br>        synchronizationContext.post(()=&gt;{<br>            SendMessage();<br>        },<span class="hljs-literal">null</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="自己实现个TaskRun"><a href="#自己实现个TaskRun" class="headerlink" title="自己实现个TaskRun"></a>自己实现个TaskRun</h3><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Run</span>(<span class="hljs-params">Action action</span>)</span><br>        {<br>            TaskCompletionSource tcs = <span class="hljs-keyword">new</span> TaskCompletionSource();<br>            ThreadPool.QueueUserWorkItem((_) =&gt;<br>            {<br>                action.Invoke();<br>                tcs.SetResult();<br>            });<br>            <span class="hljs-keyword">await</span> tcs.Task;<br>        }<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StartTask</span>()</span>{<br>    <span class="hljs-keyword">await</span> Run(FindPath);<br>    <span class="hljs-comment">//这里把回调和多线程的调用放在同个方法执行</span><br>    SendMessage();<br>}<br></code></pre></td></tr></tbody></table></figure><p>使用<code>Task.Factory.StartNew</code>创建可以自由调度的线程</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StartTask</span>()</span><br>       {<br>    <span class="hljs-comment">//MyTaskScheduler是自己实现的线程调度器</span><br>           <span class="hljs-keyword">await</span> Task.Factory.StartNew(FindPath,<span class="hljs-keyword">new</span> CancellationToken(),TaskCreationOptions.None,<span class="hljs-keyword">new</span> MyTaskScheduler());<br>       }<br></code></pre></td></tr></tbody></table></figure><h3 id="自定义线程调度器"><a href="#自定义线程调度器" class="headerlink" title="自定义线程调度器"></a>自定义线程调度器</h3><p>继承<code>TaskScheduler</code>实现自己的线程调度器</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyTaskScheduler</span>:<span class="hljs-title">TaskScheduler</span><br>        {<br>            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> IEnumerable&lt;Task&gt; <span class="hljs-title">GetScheduledTasks</span>()</span><br>            {<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            }<br><br>            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">QueueTask</span>(<span class="hljs-params">Task task</span>)</span><br>            {<br>                <span class="hljs-comment">//执行完回收到线程池</span><br>                ThreadPool.QueueUserWorkItem((_) =&gt; TryExecuteTask(task));<br>            }<br><br>            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">TryExecuteTaskInline</span>(<span class="hljs-params">Task task, <span class="hljs-built_in">bool</span> taskWasPreviouslyQueued</span>)</span><br>            {<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException();<br>            }<br>        }<br></code></pre></td></tr></tbody></table></figure><h2 id="第五节-ETTask"><a href="#第五节-ETTask" class="headerlink" title="第五节 ETTask"></a>第五节 ETTask</h2><h3 id="回调地狱-Callback-Hell"><a href="#回调地狱-Callback-Hell" class="headerlink" title="回调地狱 Callback Hell"></a>回调地狱 Callback Hell</h3><p>Task主要是为了解决回调地狱 </p><p>在没有协程和await之前，cpp主要靠函数对象模拟Lambda。 </p><p>后续谷歌推出NewCallback</p><p>C# 5.0 推出了 await async 关键字</p><p>await难以维护的操作<code>while await</code>，await all 所有任务才执行回调。</p><p>go python js ts cpp后续也推出了await关键字，但是go的await不完善，是通过线程的方式去执行。比如玩家有的操作是需要单线程等待一段事件再执行的，回调则会执行在其他线程中。而好的设计则应该是只把回调拉直，而不关心你后续实现是在多线程还是单线程。</p><h3 id="回调转成Task"><a href="#回调转成Task" class="headerlink" title="回调转成Task"></a>回调转成Task</h3><p><code>TaskCompleteSource</code></p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> ETTask <span class="hljs-title">FindPath</span>()</span>{<br>    TaskCompletionSource tcs = TaskCompletionSource();<br>    ThreadPool.QueueUserWorkItem( state=&gt;{<br>       Consle.WriteLine(<span class="hljs-string">"FindPATH"</span>);<br>        tcs.SetResult();<br>    });<br>    <span class="hljs-keyword">await</span> tcs.Task;<br>}<br></code></pre></td></tr></tbody></table></figure><p><code>CancellationTokenSource</code> await的取消操作</p><p>传入token，通过token状态来判断后续代码是否执行。 </p><h3 id="ETTask的好处"><a href="#ETTask的好处" class="headerlink" title="ETTask的好处"></a>ETTask的好处</h3><p>生成代码极简，去除了多线程的支持，性能最好。</p><p>对象池消除了Task GC</p><p><code>TaskCompleteSource</code>和<code>CancellationTokenSource</code>这两个类比较庞大并且没有入池，gc问题比较严重。</p><p>去掉了ETVoid </p><p>ETVoid对应 async void。任何异步都返回ETTask。不需要等待则直接Coroutine。操作简单。</p><h3 id="线程取消"><a href="#线程取消" class="headerlink" title="线程取消"></a>线程取消</h3><ul><li><p>超级简单的ETCancelToken</p><p>ETCancelToken替换<code>CancellationTokenSource</code></p></li><li><p>协程取消判断</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">if</span>(cancellationToken.IsCancel()){<br>Console.WriteLine(<span class="hljs-string">"Start cancel"</span>);<br><span class="hljs-keyword">return</span>;<br>}<br>Console.WriteLine(<span class="hljs-string">"Start finish"</span>);<br></code></pre></td></tr></tbody></table></figure><p>在ETTask中判断ETCanelToken是否取消然后继续执行后面操作。而Task在取消后则抛出异常。</p></li><li><p>ETCancelToken取消多个协程</p><p>多个ETTask判断同一个ETCancelToken</p></li><li><p>ETCancelToken的必要性</p><p>尽可能设计一个await的取消方式，否则后续维护扩展非常困难。</p></li></ul><h3 id="awaitable"><a href="#awaitable" class="headerlink" title="awaitable"></a>awaitable</h3><h4 id="GetAwaiter"><a href="#GetAwaiter" class="headerlink" title="GetAwaiter"></a>GetAwaiter</h4><p>c#提供的<code>GetAwaiter</code>的机制，只要对象有一个成员方法或者静态方法名为<code>GetAwaiter</code>，就可以使用await的语法。</p><h4 id="Unity-yield转换"><a href="#Unity-yield转换" class="headerlink" title="Unity yield转换"></a>Unity yield转换</h4><p>本质上也是回调操作，把yield用await的形式更加简单。</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//unity中yield都会返回AsyncOperation的子类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> ETTask <span class="hljs-title">GetAwaiter</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> AsyncOperation asyncOperation</span>)</span>{<br>    ETTask task = ETTask.Create(<span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">//SetResult执行后会回到await后的操作。</span><br>    asyncOperation.completed += _=&gt;{ task.SetResult();};<br>    <span class="hljs-keyword">await</span> task;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> ETTask&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">HttpGet</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> link</span>)</span>{<br>    <span class="hljs-keyword">try</span>{<br>        UnityWedRequest req = UnityWebRequest.Get(link);<br>        <span class="hljs-comment">//req.SendWebRequest()会返回UnityWebRequestAsyncOperation，继承于AsyncOperation</span><br>        <span class="hljs-keyword">await</span> req.SendWebRequest();<br>        <span class="hljs-keyword">return</span> req.downloadHandler.text;<br>}<br>    <span class="hljs-keyword">catch</span>{<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="第五节-2-ETTask源码分析"><a href="#第五节-2-ETTask源码分析" class="headerlink" title="第五节 -2 ETTask源码分析"></a>第五节 -2 ETTask源码分析</h2><p>用反编译工具<code>.NET Reflector</code>查看ETTask实现。</p><p>这里需要反复看生成概念。</p><p>本质上是基于状态机的实现，执行时通过判断ETTaskCompleted的值来判断是否走到后面的逻辑，如果需要等待则将状态机的<code>MoveNext</code>方法传到ETTask的CallBack中。通过状态机的状态变化继续后面的逻辑。 ETTask的<code>SetResult</code>操作会触发回调，执行状态机的<code>MoveNext</code>。</p><p>实际上是把await前的代码和await后的操作，各放在一个状态中，通过状态机切换来执行。保证了上下文的统一。</p><p>多个await会生成多个状态机</p><h4 id="ETTask"><a href="#ETTask" class="headerlink" title="ETTask"></a>ETTask</h4><p>只要用了<code>ettask.Coroutine()</code>在编译后会生成一个<code>ETAsyncTaskMethodBuilder.Create()</code></p><h4 id="ETAsyncTaskMethodBuilder"><a href="#ETAsyncTaskMethodBuilder" class="headerlink" title="ETAsyncTaskMethodBuilder"></a>ETAsyncTaskMethodBuilder</h4><p>struct类型，包含一个ETTask。</p><p>在方法执行了Coroutine编译后会对应生成一个相对的struct，继承于<code>IAsyncStateMachine</code>。生成一个状态机，根据state参数执行相对应阶段的代码。</p><h4 id="ETVoid"><a href="#ETVoid" class="headerlink" title="ETVoid"></a>ETVoid</h4><h4 id="ETAsyncVoidMethodBuilder"><a href="#ETAsyncVoidMethodBuilder" class="headerlink" title="ETAsyncVoidMethodBuilder"></a>ETAsyncVoidMethodBuilder</h4><h4 id="ETTaskCompleted"><a href="#ETTaskCompleted" class="headerlink" title="ETTaskCompleted"></a>ETTaskCompleted</h4><p>返回完成状态，基本是true</p><h4 id="ETAsyncTaskCompletedMethodBuilder"><a href="#ETAsyncTaskCompletedMethodBuilder" class="headerlink" title="ETAsyncTaskCompletedMethodBuilder"></a>ETAsyncTaskCompletedMethodBuilder</h4><h3 id="协程的使用"><a href="#协程的使用" class="headerlink" title="协程的使用"></a>协程的使用</h3><p>用协程简化工作流程。</p><p><code>int result = await OpenBox();</code>弹窗时返回点击按钮的type做相应的判断，简化在窗口里写逻辑，逻辑上更清晰。(有点像VB的弹窗返回值</p><p> <code>await MoveTo();</code></p><p><code>await ChangeScene();</code> 切换场景的操作写成一个方法，await后执行切换场景完成后的代码。</p><p><code>await CastSpell();</code> 释放技能，技能成功或失败后的操作。比如失败时使用道具，成功后捡道具。如果用事件则会变得很复杂。 </p><p>熊猫哥举了个例子，比如自动寻路时，需要通过几个场景的传送门才能到达最终场景。先把场景选出来，给每个场景写一个最短路径的寻路方法。根据读配置去执行相应的寻路方法。只需要通过一个while循环就能到达最终目标位置。</p><p>把逻辑异步化后，逻辑更清晰，只需要对内容进行封装抽象不需要再关心后续的逻辑了。</p><h2 id="第六节-计时器"><a href="#第六节-计时器" class="headerlink" title="第六节 计时器"></a>第六节 计时器</h2><p><code>TimerComponent</code></p><h3 id="需求场景"><a href="#需求场景" class="headerlink" title="需求场景"></a>需求场景</h3><ul><li>UI倒计时</li><li>网络超时</li><li>技能释放</li><li>buff超时删除，定时事件</li></ul><h3 id="Task-Delay的问题"><a href="#Task-Delay的问题" class="headerlink" title="Task.Delay的问题"></a>Task.Delay的问题</h3><p>C#提供的定时器<code>Task.Delay</code>。</p><ul><li>跨线程<ul><li><code>Task.Delay</code>是跨线程的，会把await的回调放在其他线程执行。</li></ul></li><li>性能<ul><li>如果需要把回调设置到主线程，就需要设置同步上下文<code>SynchronizationContext synchronizationContext = SynchronizationContext.Current;</code>。把action post到主线程，性能很糟糕</li></ul></li><li>CancleToken抛异常<ul><li>抛异常的性能问题</li><li>不执行后续操作</li></ul></li><li>GC<ul><li>基于Task实现 有GC</li></ul></li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="相对时间"><a href="#相对时间" class="headerlink" title="相对时间"></a>相对时间</h5><p><code>public async ETTask WaitAsync(long time,ETCancellationToken cancellationToken = null)</code></p><h5 id="unix绝对时间"><a href="#unix绝对时间" class="headerlink" title="unix绝对时间"></a>unix绝对时间</h5><p><code>public async ETTask WaitTillAsync(long tillTime,ETCancellationToken cancellationToken = null)</code></p><p>相对时间的会跟随帧率 或 线程情况受影响。而绝对时间则是跟随unix时间。在时间达到时，无论什么情况都会执行。</p><h5 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h5><p><code>public long NewOnceTimer(long tillTime,int type,object args)</code></p><p>为什么不用callback？</p><p>计时器里可能会有泄露，方便查找泄露。callback没法热重载，基本不用callback。</p><p>跟WaitAsync的区别？</p><p>时间长时，用<code>NewOnceTimer</code>，可以热重载。而<code>WaitAsync</code>不能热重载。</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>MultMap 管理时间线，在每个时间点插入一个list管理多个计时器。插入list的操作有gc，用对象池创建的话会有回收问题，一直创建池子只会越来越大，在切换场景的时候回收。</p><p>Remove细节，只从timerActions中删除。不删除MultMap 管理的计时器，MultMap管理的List插入删除都会影响性能。时间到了从MultMap 取出执行时，判断是否在timerActions中，如果在再执行。</p><p>WaitAsync ETCancellationToken怎么判断去取消。</p><h2 id="第七节-协程锁"><a href="#第七节-协程锁" class="headerlink" title="第七节 协程锁"></a>第七节 协程锁</h2><p><code>CoroutineLockComponent</code></p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>协程并发造成协程竞争，类比于线程竞争</li><li>unity资源加载<ul><li>同时异步加载同一个资源会报错</li><li>如果打标记后续逻辑比较不好扩展，比如要做await操作。</li></ul></li><li>加载mail数据<ul><li>不同服务器玩家数据的竞争</li></ul></li><li>unit消息队列，上线下线<ul><li>玩家下线了，但是有些异步操作还没完成。</li></ul></li><li>数据库查询保存队列，防止并发过多<ul><li>mongodb数据的并发数量是有限的。</li></ul></li></ul><p>用了协程锁后，协程则是并列进行。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="协程锁中再次获得同一把锁"><a href="#协程锁中再次获得同一把锁" class="headerlink" title="协程锁中再次获得同一把锁"></a>协程锁中再次获得同一把锁</h4><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230314225046861.png" alt="image-20230314225046861"></p><h4 id="A-B互相等待"><a href="#A-B互相等待" class="headerlink" title="A B互相等待"></a>A B互相等待</h4><h4 id="想象不到的死锁"><a href="#想象不到的死锁" class="headerlink" title="想象不到的死锁"></a>想象不到的死锁</h4><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230314225755691.png" alt="image-20230314225755691"></p><p>两条没有关联的消息正好在同一时间请求，请求的内容都需要用到同一把锁。就造成了死锁。</p><p>这种情况比较罕见，要么改成请求锁的地方统一通过转发形式。要么干脆直接不处理了。</p><h3 id="协程队列实现"><a href="#协程队列实现" class="headerlink" title="协程队列实现"></a>协程队列实现</h3><p>CoroutineLockComponent</p><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230314230323393.png" alt="image-20230314230323393"></p><ul><li>协程锁划分类型<ul><li>不同类型的锁没必要等，比如资源和数据。</li></ul></li><li>同一个类型，再根据id划分协程锁队列。</li><li>同一个类型，并且id相同则在同一个队列中，并列执行。</li></ul><p>CoroutineLockQueueType</p><p>CoroutineLockQueue 对象池</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>为什么不用池？不用struct？</p><p>超时实现</p><h2 id="第八节-协程同步"><a href="#第八节-协程同步" class="headerlink" title="第八节 协程同步"></a>第八节 协程同步</h2><p>三件套<code>ETTask</code>、<code>协程锁</code>、<code>WaitAll</code></p><p>在使用waitAll时需要考虑是否能并发，是否需要并发。</p><p><code>ETTaskHelper.WaitAll</code></p><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="资源加载并发"><a href="#资源加载并发" class="headerlink" title="资源加载并发"></a>资源加载并发</h4><p><code>ResourceComponent</code>实现了并发加载资源</p><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230314232242465.png" alt="image-20230314232242465"></p><h4 id="机器人登录并发"><a href="#机器人登录并发" class="headerlink" title="机器人登录并发"></a>机器人登录并发</h4><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230314232906957.png" alt="image-20230314232906957"></p><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230314232915651.png" alt="image-20230314232915651"></p><p>每个流程都可以实现并发</p><h3 id="WaitAll实现"><a href="#WaitAll实现" class="headerlink" title="WaitAll实现"></a>WaitAll实现</h3><h4 id="线程同步barrier"><a href="#线程同步barrier" class="headerlink" title="线程同步barrier"></a>线程同步barrier</h4><p>可以参考barrier</p><ol><li>主协程要阻塞住<ul><li>主协程wait</li></ul></li><li>所有子协程执行完，要通知主协程往下执行<ul><li>子协程执行完有个回调，至少有个setResult的操作<ul><li>用计数形式，每执行完一个子协程，count-1，count=0时表示子协程都执行完毕。</li></ul></li><li>主协程在所有子协程都执行完后才开始执行，就需要判断。<ul><li>在主协程开始时，判断计数是否为0，为0时直接执行。不为0时创建个ETTask等待。</li></ul></li></ul></li><li>Cancel的判断<ul><li>WaitAll取消的操作</li></ul></li></ol><h3 id="WaitAny"><a href="#WaitAny" class="headerlink" title="WaitAny"></a>WaitAny</h3><p>有任一一个协程执行完则返回。</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>计数设置为1，执行完一个-1，count&lt;=0返回</p><h2 id="第九节-ID、TimeInfo、ObjectPool"><a href="#第九节-ID、TimeInfo、ObjectPool" class="headerlink" title="第九节 ID、TimeInfo、ObjectPool"></a>第九节 ID、TimeInfo、ObjectPool</h2><h3 id="ID"><a href="#ID" class="headerlink" title="ID"></a>ID</h3><p>对应类<code>IdGenerater</code></p><h4 id="ID跟InstanceID"><a href="#ID跟InstanceID" class="headerlink" title="ID跟InstanceID"></a>ID跟InstanceID</h4><h5 id="ID是逻辑上的，InstanceID是对象的"><a href="#ID是逻辑上的，InstanceID是对象的" class="headerlink" title="ID是逻辑上的，InstanceID是对象的"></a>ID是逻辑上的，InstanceID是对象的</h5><h5 id="ID可以重复，管理器管理，而InstanceID是全局唯一的"><a href="#ID可以重复，管理器管理，而InstanceID是全局唯一的" class="headerlink" title="ID可以重复，管理器管理，而InstanceID是全局唯一的"></a>ID可以重复，管理器管理，而InstanceID是全局唯一的</h5><h4 id="为什么需要InstanceID？"><a href="#为什么需要InstanceID？" class="headerlink" title="为什么需要InstanceID？"></a>为什么需要InstanceID？</h4><h5 id="InstanceID表示对象的唯一性"><a href="#InstanceID表示对象的唯一性" class="headerlink" title="InstanceID表示对象的唯一性"></a>InstanceID表示对象的唯一性</h5><p>对象可能会被释放或者清除，通过InstanceID判断对象是否存在</p><h5 id="InstanceID有位置信息"><a href="#InstanceID有位置信息" class="headerlink" title="InstanceID有位置信息"></a>InstanceID有位置信息</h5><p>InstanceID拥有时间、进程号</p><h5 id="InstanceID能方便区分对象进入对象池再被使用"><a href="#InstanceID能方便区分对象进入对象池再被使用" class="headerlink" title="InstanceID能方便区分对象进入对象池再被使用"></a>InstanceID能方便区分对象进入对象池再被使用</h5><p>在await等待时当持有的unit可能在某个操作被对象池回收，后再被创建。持有的unit已经变成了新的unit造成逻辑错误。</p><p>InstanceID被池回收后再创建，InstanceID发生变化。在await操作时判断前后InstanceID是否一致。</p><h4 id="ID的构成"><a href="#ID的构成" class="headerlink" title="ID的构成"></a>ID的构成</h4><p><code>long</code>类型 64位</p><ul><li>Time 30bit  34年<ul><li>不用从1970开始，可以从项目发布时间开始，还能用34年</li></ul></li><li>Process进程号 18bit 1024*256<ul><li>一个区大概使用256个进程(根据游戏类型调整)，可以支持1024个区</li></ul></li><li>自增 16bit 65535<ul><li>当一秒内的自增id超过范围时，借用下一秒的</li></ul></li></ul><h4 id="UnitID构成"><a href="#UnitID构成" class="headerlink" title="UnitID构成"></a>UnitID构成</h4><ul><li>Time  30bit 34年</li><li>Zone 10bit 1024个区 跨服用<ul><li>当出现跨服活动时，很方便的通过zone来做区分</li></ul></li><li>ProcessMode 8bit Process % 256</li><li>自增 16bit 65535</li></ul><h4 id="InstanceID构成"><a href="#InstanceID构成" class="headerlink" title="InstanceID构成"></a>InstanceID构成</h4><ul><li>Time 28bit  当年开始的tick<ul><li>生命周期比较短，不需要那么长的 time</li></ul></li><li>Process进程号 18bit 1024*256<ul><li>一个区大概使用256个进程(根据游戏类型调整)，可以支持1024个区</li></ul></li><li>自增 18bit 65535 *4<ul><li>数量比较多，增加自增率</li></ul></li></ul><h3 id="TimeInfo"><a href="#TimeInfo" class="headerlink" title="TimeInfo"></a>TimeInfo</h3><p>对应类<code>TimeInfo</code></p><ul><li>Unix Time 自1970年1月1日以来的毫秒</li><li>ServerMinusClientTime<ul><li>服务器时间  -  客户端时间得到的时间差。在 ping的过程中获取。</li><li>客户端时间 + 与服务器的时间差 = 服务器时间</li></ul></li><li>ServerTime、ClientTime<ul><li>对于服务器而言，ServerTime和ClientTime是一样的，对服务器而言不需要考虑客户端时间。</li><li>对客户端而言，ServerTime就是  客户端时间 加上 与服务器的时间差获得的。</li></ul></li><li>性能优化<ul><li>在ClientNow中 计算时间用到Ticks，Ticks的操作非常耗时。</li></ul></li></ul><h3 id="ObjectPool"><a href="#ObjectPool" class="headerlink" title="ObjectPool"></a>ObjectPool</h3><p>mono的垃圾回收很垃圾。</p><p>在异步代码里，处处使用对象池很有问题。在每个操作都要判断是不是新的对象，漏了一个就有很大的问题。</p><p>有些对象池有定时回收的功能，这个功能的缺陷在于，在某一帧可能会回收大量对象，加深了那一帧的时间。</p><p>ET的设计则是将对象池设置个最大容量，超过最大容量时则不入池，避免内存占用过大。</p><p>在一些场景切换中也可以对对象池进行清理，避免没有意义的内存占用。</p><h2 id="第十节-配置Excel、NLog、Options"><a href="#第十节-配置Excel、NLog、Options" class="headerlink" title="第十节 配置Excel、NLog、Options"></a>第十节 配置Excel、NLog、Options</h2><h3 id="Option"><a href="#Option" class="headerlink" title="Option"></a>Option</h3><p><code>Options</code></p><ul><li>Options类 示例</li><li>长名 短名 Required Default HelperText<ul><li><code>OptionAttribute</code> </li><li>Required 为false时不强制要求带参数</li></ul></li><li>序列化 反序列化<ul><li>序列化和反序列称unix和linux命令行风格的字符串</li></ul></li><li>起服命令参数<ul><li>option一般用于服务器启动，起服命令参数一般用于创建进程的配置信息。</li></ul></li><li>GM指令参数，手动解析？<ul><li>GM指令如果是命令行最好使用option的形式来配置。optin提供静态检查，不容易出错。</li></ul></li></ul><h3 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h3><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230320090859.jpg" alt="微信图片_20230320090859"></p><ul><li>Logger单间类</li><li>ILog接口，策略模式<ul><li>策略模式，客户端使用UnityLogger，服务端用NLogger</li></ul></li><li>LogLevel<ul><li>提供Log等级，来按照等级进行输出。开发模式，测试模式和线上模式</li></ul></li><li>Conditional<ul><li>当有些日志需要进行拼接的操作时，拼接消耗性能，就给个宏定义判断。</li><li>通过打标签的形式对指定 Log函数进行标记，等有了宏定义之后才生效。</li><li>一个函数可以定义多个宏</li><li>.NET的新特性，可以使用DefalutInterpolatedStringHandler来减少字符串拼接带来的GC</li></ul></li><li>LogTrace<ul><li>当需要查看日志的堆栈时可以用LogTrace，函数内会创建个堆栈。这里可以看看堆栈的逻辑。</li></ul></li></ul><h3 id="NLog配置"><a href="#NLog配置" class="headerlink" title="NLog配置"></a>NLog配置</h3><p>对应config里的参数</p><ul><li>Variables<ul><li>通过变量修改Config里的配置，来达到指定参数的日志输出</li><li>LogManager.Configuration.Variables</li></ul></li><li>rules</li><li>targets</li><li>async、buffersize</li></ul><h3 id="Excel"><a href="#Excel" class="headerlink" title="Excel"></a>Excel</h3><ul><li>StartConfig<ul><li>启动时通过命令行选择加载指定的配置</li></ul></li><li>C S #</li><li>patial<ul><li>有些配置，不方便填类型比如 ip地址等等</li><li>通过patial扩展想要的类型，通过proto反序列化时赋值。</li></ul></li><li>KV<ul><li>通过key value的形式配置buff</li></ul></li></ul><h3 id="配置用时再加载"><a href="#配置用时再加载" class="headerlink" title="配置用时再加载"></a>配置用时再加载</h3><p>节省内存</p><p>懒加载减少同时加载造成的cpu过载</p><h2 id="第十一节-Why-not-继承，多态，组合？"><a href="#第十一节-Why-not-继承，多态，组合？" class="headerlink" title="第十一节 Why not 继承，多态，组合？"></a>第十一节 Why not 继承，多态，组合？</h2><h3 id="成员继承的问题"><a href="#成员继承的问题" class="headerlink" title="成员继承的问题"></a>成员继承的问题</h3><h4 id="类层级调整复杂、耦合，一个变化回影响很多子类"><a href="#类层级调整复杂、耦合，一个变化回影响很多子类" class="headerlink" title="类层级调整复杂、耦合，一个变化回影响很多子类"></a>类层级调整复杂、耦合，一个变化回影响很多子类</h4><p>​当层级变多了后，插入一个新的对旧的逻辑都都会有影响</p><h4 id="继承成员随意组合问题"><a href="#继承成员随意组合问题" class="headerlink" title="继承成员随意组合问题"></a>继承成员随意组合问题</h4><h4 id="接口-组合？组合优于继承？"><a href="#接口-组合？组合优于继承？" class="headerlink" title="接口 + 组合？组合优于继承？"></a>接口 + 组合？组合优于继承？</h4><p>​每个类都继承了接口的话，都需要额外实现。</p><p>​缺乏动态性。当有一个功能，当前不开放但是之后开放。如果是接口，代码实现则需要预先实现，是否开放变成了时机的问题。浪费空间</p><p>​特殊性影响了普遍性，可能并不是所有成员都拥有的功能，则需要给每个成员都添加对应的逻辑。</p><p>​临时接口跟成员数量极多。比如各种种类的buff。</p><p>​成员容易随意放置，没有规范。</p><p>​patial分开逻辑？没有解决根本的问题，内存占用巨大。不需要的成员拥有了不需要的字段。</p><h3 id="类方法的问题"><a href="#类方法的问题" class="headerlink" title="类方法的问题"></a>类方法的问题</h3><p>函数跟数据混在一起，重构困难。当需要挪出逻辑时，会有private字段限制，不好挪动。</p><p>类和类之间方法互相调用，耦合，重构困难。</p><p>静态方法和类方法，界限不清晰。</p><h3 id="虚函数问题-多态"><a href="#虚函数问题-多态" class="headerlink" title="虚函数问题(多态)"></a>虚函数问题(多态)</h3><p>行为跟类型绑定，类型数量会爆炸</p><p>当一个类拆的不够细时。由于子类做不到任何成员组合，子函数会巨大。</p><p>不同类型经常写差不多的方法</p><h3 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h3><p>学习成本极大，打补丁的设计模式太多。</p><p>人员要求太高，经常设计不够细致。</p><p>如果没有统一标准，代码维护困难。</p><h3 id="Unity组件的优点"><a href="#Unity组件的优点" class="headerlink" title="Unity组件的优点"></a>Unity组件的优点</h3><p>成员自由搭配</p><p>成员动态插拔的，内存占用率高。</p><p>方法也是动态插拔的，更合理，更不容易出错。</p><p>临时数据不会导致信息爆炸，成员，方法</p><p>代码可读性高，因为内部实现少都是组合。</p><h3 id="Unity组件的缺陷"><a href="#Unity组件的缺陷" class="headerlink" title="Unity组件的缺陷"></a>Unity组件的缺陷</h3><p>数据跟方法没分离，容易耦合，互相调用。</p><p>事件方法基于反射，性能有些损失。</p><p>GameObject过于庞大，里面的东西过多，只需要纯逻辑时不需要view。 </p><p>没有替代多态的解决方案。</p><p>组件无法再挂组件，组件无法再有child。</p><h3 id="ECS的问题"><a href="#ECS的问题" class="headerlink" title="ECS的问题"></a>ECS的问题</h3><p>Entity只有一个ID，全是Entity。全是entity找bug起来很复杂</p><p>组件是strust，限制太大用起来很难受</p><p>非树状结构，不符合对世界的描述，工厂的管理模式。</p><p>组件无法再挂组件，过于扁平，组件无法再有child</p><h2 id="第十二节-实体组件系统"><a href="#第十二节-实体组件系统" class="headerlink" title="第十二节 实体组件系统"></a>第十二节 实体组件系统</h2><h3 id="Entity-Component-System"><a href="#Entity-Component-System" class="headerlink" title="Entity Component System"></a>Entity Component System</h3><p>AddComponet、RemoveComponet、生命周期等等接口名与生命周期都和Unity保持一致。</p><h4 id="Entity和Component合并。原因？区别？"><a href="#Entity和Component合并。原因？区别？" class="headerlink" title="Entity和Component合并。原因？区别？"></a>Entity和Component合并。原因？区别？</h4><p>Entity和Component很类似，功能开发时逻辑很容易互相嵌套，不容易区分。只有Entity能挂组件很不灵活，在线上环境中Component需要扩展成Entity很难进行扩展因为数据已经是Component的形式。</p><h4 id="数据跟方法完全分离"><a href="#数据跟方法完全分离" class="headerlink" title="数据跟方法完全分离"></a>数据跟方法完全分离</h4><h4 id="Entity不能继承"><a href="#Entity不能继承" class="headerlink" title="Entity不能继承"></a>Entity不能继承</h4><p>用组件代替继承，需要什么数据挂在需要的组件。</p><h4 id="Entity树状无限嵌套"><a href="#Entity树状无限嵌套" class="headerlink" title="Entity树状无限嵌套"></a>Entity树状无限嵌套</h4><p>大世界概念，比较容易描述游戏需求。</p><h4 id="跟传统ECS的区别"><a href="#跟传统ECS的区别" class="headerlink" title="跟传统ECS的区别"></a>跟传统ECS的区别</h4><p>传统ECS的System更多是成员的形式。</p><p>传统ECS强调组件的筛选</p><h3 id="ET组件数据跟方法分离的好处"><a href="#ET组件数据跟方法分离的好处" class="headerlink" title="ET组件数据跟方法分离的好处"></a>ET组件数据跟方法分离的好处</h3><p>没有耦合，没有设计模式，学习简单，重构简单</p><p>热重载容易</p><p>多态实现简单，能基于任何字段做逻辑分发</p><h3 id="逻辑分发-多态"><a href="#逻辑分发-多态" class="headerlink" title="逻辑分发-多态"></a>逻辑分发-多态</h3><h4 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h4><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><h4 id="Dictionary-lt-int-Action-gt"><a href="#Dictionary-lt-int-Action-gt" class="headerlink" title="Dictionary<int,Action>"></a>Dictionary&lt;int,Action&gt;</h4><p>状态注册，相比switch而言优化了寻找时的复杂度。</p><p>问题在于需要手动注册状态，删除时需要手动删除相对而言比较麻烦</p><h4 id="ET的分发形式，基于Attribute的自动注册"><a href="#ET的分发形式，基于Attribute的自动注册" class="headerlink" title="ET的分发形式，基于Attribute的自动注册"></a>ET的分发形式，基于Attribute的自动注册</h4><p>eventsystem</p><h3 id="Entity树"><a href="#Entity树" class="headerlink" title="Entity树"></a>Entity树</h3><h4 id="Entity的parent"><a href="#Entity的parent" class="headerlink" title="Entity的parent"></a>Entity的parent</h4><p>最顶层的Scene没有parent</p><p>Entity被反序列化出来时是没有parent的</p><h4 id="Domain"><a href="#Domain" class="headerlink" title="Domain"></a>Domain</h4><p>每个Entity都有一个Domain字段，记录在于哪个场景下</p><p>在找中间某个节点时，防止写了过多的getParent。</p><h4 id="对象生命周期管理的重要性"><a href="#对象生命周期管理的重要性" class="headerlink" title="对象生命周期管理的重要性"></a>对象生命周期管理的重要性</h4><p>创建对象时，谁去管理释放。谁去管理对象的生命周期。</p><p>如果通过单间管理对象的生命周期，又缺少了对单间生命周期的管理。写多了容易遗漏。</p><p>通过父级来管理孩子，父级移除时移除自身挂在的child。</p><h4 id="UISceneComponet-ResourceSceneComponent-Timer等等"><a href="#UISceneComponet-ResourceSceneComponent-Timer等等" class="headerlink" title="UISceneComponet ResourceSceneComponent Timer等等"></a>UISceneComponet ResourceSceneComponent Timer等等</h4><p>按Scene挂ui，根据Scene的生命周期进行资源回收。</p><p>创建时需要想清楚，需要让谁进行管理。</p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>不建议把Entity做为另一个Entity的成员，要么作为组件，要么作为Child。</p><p>异步代码，容易出现对象消失，引用还在的情况。特别是用了对象池更危险，做分析器禁止</p><p>服务端逻辑帧一般不用Update和LateUpdate。服务器的一帧1毫秒，实际上不需要这么频繁，用Update100ms或者定时器来实现。</p><h3 id="Entity代码详解"><a href="#Entity代码详解" class="headerlink" title="Entity代码详解"></a>Entity代码详解</h3><p>Entity内，存放Component以Type为key ，一种Type的Component只能存在一个。</p><p>存放AddChild则是以Id为key。</p><h4 id="EntityStatus"><a href="#EntityStatus" class="headerlink" title="EntityStatus"></a>EntityStatus</h4><p>8位的枚举，每一位都记录了一个信息。</p><h4 id="SetParent"><a href="#SetParent" class="headerlink" title="SetParent"></a>SetParent</h4><p>Parent{Set方法}</p><p>严格限制parent必须要有domain，parent必须在数据树上。</p><h4 id="ComponentParent"><a href="#ComponentParent" class="headerlink" title="ComponentParent"></a>ComponentParent</h4><p>只能通过AddComponent来添加。</p><h4 id="Domain-1"><a href="#Domain-1" class="headerlink" title="Domain"></a>Domain</h4><p>根节点的Domain为自己，其他节点的Domain为父节点的Domain</p><p>如果是通过反序列化出来的Entity则没有domain，这时候需要递归把children的domain都设置一遍</p><h4 id="DB"><a href="#DB" class="headerlink" title="DB"></a>DB</h4><p>如果Child继承于ComponentDB或者ChildDB，则会加到componentsDB或childrenDB内。表示需要持久化。</p><h2 id="第十三节-EventSystem"><a href="#第十三节-EventSystem" class="headerlink" title="第十三节 EventSystem"></a>第十三节 EventSystem</h2><p><strong>Type.GetType在IL2CPP中性能很差</strong></p><h3 id="实体组件生命周期相关"><a href="#实体组件生命周期相关" class="headerlink" title="实体组件生命周期相关"></a>实体组件生命周期相关</h3><p>Awake Update LateUpdate Destory</p><h3 id="Publish-自定义的抛事件方法"><a href="#Publish-自定义的抛事件方法" class="headerlink" title="Publish 自定义的抛事件方法"></a>Publish 自定义的抛事件方法</h3><h5 id="类比dll的单项依赖，防止互相依赖"><a href="#类比dll的单项依赖，防止互相依赖" class="headerlink" title="类比dll的单项依赖，防止互相依赖"></a>类比dll的单项依赖，防止互相依赖</h5><h5 id="模块隔离"><a href="#模块隔离" class="headerlink" title="模块隔离"></a>模块隔离</h5><h5 id="同步异步"><a href="#同步异步" class="headerlink" title="同步异步"></a>同步异步</h5><p>异步Publish，等待订阅者完成操作后，发布者才会进行后面逻辑</p><h5 id="SceneType"><a href="#SceneType" class="headerlink" title="SceneType"></a>SceneType</h5><p>all in one的设计，用来区分是客户端还是服务端</p><p>服务端也能用来做进程间的限制</p><h5 id="全局事件-静态事件"><a href="#全局事件-静态事件" class="headerlink" title="全局事件(静态事件)"></a>全局事件(静态事件)</h5><p>动态事件的绑定都有一个绑定的过程，需要额外管理什么时候监听并且什么时候释放。在查看代码时，需要查看监听的绑定调用，会降低可读性。</p><p>不需要每个监听类都有一个callback，只有全局的callback。</p><h3 id="Invoke"><a href="#Invoke" class="headerlink" title="Invoke"></a>Invoke</h3><p>相当于回调。取决于怎么去触发回调。</p><p>根据id分发。程序启动时把响应方法注册进EventSystem内。</p><h3 id="Invoke和Publish的区别"><a href="#Invoke和Publish的区别" class="headerlink" title="Invoke和Publish的区别"></a>Invoke和Publish的区别</h3><p>Publish抛出去不关心结果不关心订阅者的，Invoke是主动调用(类似函数)需要知道函数真实存在。</p><p>Publish区分SceneType，Invoke没有区分</p><p>Publish没有分发作用，Invoke带有分发作用</p><p>Publish一对多，Invoke一对一</p><p>Publish跟Invoke命名不同，Publish命名跟时间点相关，Invoke命名跟使用者相关</p><h3 id="TypeSystem"><a href="#TypeSystem" class="headerlink" title="TypeSystem"></a>TypeSystem</h3><p>每个Type都有一个对应的OneTypeSystems</p><h4 id="OneTypeSystems"><a href="#OneTypeSystems" class="headerlink" title="OneTypeSystems"></a>OneTypeSystems</h4><p>OneTypeSystems中的QueueFlag记录实现了哪些生命周期，ISystemType中的GetInstanceQueueIndex可以获取到 生命周期的Index</p><p>当Entity实例化时通过OneTypeSystems取生命周期的Flag</p><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>按照生命周期的Flag来缓存需要生命周期的组件ID队列，因为组件可能被对象池回收，所以缓存组件ID</p><h2 id="第十四节-序列化反序列化"><a href="#第十四节-序列化反序列化" class="headerlink" title="第十四节 序列化反序列化"></a>第十四节 序列化反序列化</h2><h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><p>Excel配置文件，编辑器配置文件，大小跟速度都无所谓</p><p>网络消息 大小速度很重要</p><p>Entity对象，很复杂，需要支持继承等复杂特性</p><p>数据库，mongodb</p><p>命令行</p><h3 id="库的选择"><a href="#库的选择" class="headerlink" title="库的选择"></a>库的选择</h3><p>Google Protobuf 性能最好，代码生成复杂不容易扩展，容易无gc</p><p>Protobuf-net 性能较好，代码简洁，使用最广泛。使用反射机制不好定制</p><p>MessagePack 性能较好，代码简洁，其他语言使用少</p><p>Mongo.Bson 性能较差，功能最强，并且支持Json</p><p>选择Protobuf-net跟MongoDB，满足任何需求</p><h4 id="Protobuf-net"><a href="#Protobuf-net" class="headerlink" title="Protobuf-net"></a>Protobuf-net</h4><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>为了支持protobuf的格式，需要在父类上打标签表示继承关系</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">ProtoContract</span>]<br>[<span class="hljs-meta">ProtoInclude(3,typeof(BB))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AA</span>{<br>    [<span class="hljs-meta">ProtoMember(1)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> a;<br>    [<span class="hljs-meta">ProtoMember(2)</span>]<br>    <span class="hljs-keyword">public</span> float3 pos;<br>}<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BB</span>:<span class="hljs-title">AA</span>{<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> b;<br>}<br></code></pre></td></tr></tbody></table></figure><h5 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h5><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">RuntimeTypeModel.Default.<span class="hljs-keyword">add</span>(<span class="hljs-keyword">typeof</span>(float3),<span class="hljs-literal">false</span>).<span class="hljs-keyword">add</span>(<span class="hljs-string">"x"</span>,<span class="hljs-string">"y"</span>,<span class="hljs-string">"z"</span>);<br>AA aa = <span class="hljs-keyword">new</span> AA(){<br>    a =<span class="hljs-number">1</span>,<br>    pos = <span class="hljs-keyword">new</span> float3(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="Mongo-Bson"><a href="#Mongo-Bson" class="headerlink" title="Mongo Bson"></a>Mongo Bson</h4><p>MongoDB的C#库，把C#对象序列化成MongoDB可以用的格式，也可以转换成其他格式，并且支持嵌套。</p><h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ul><li>Bsonld<ul><li>每条数据都需要有一个Bsonld，如果没有赋值会默认给个96位的Id</li></ul></li><li>BsonElement<ul><li>private字段需要序列化字段的标签</li><li>可以重命名，可以取个别名可以节省空间。序列化反序列速度也能提升</li></ul></li><li>Bsonlgnore<ul><li>public字段不需要序列化的标签</li></ul></li><li>BsonDefaultValue<ul><li>没有赋值则取默认值</li></ul></li><li>BsonlgnoreIfDefault<ul><li>如果是默认值则 序列化过程中不进行序列化</li></ul></li></ul><h5 id="子类默认不能反序列化成父类"><a href="#子类默认不能反序列化成父类" class="headerlink" title="子类默认不能反序列化成父类"></a>子类默认不能反序列化成父类</h5><p><code>BsonIgnoreExtraElements</code>加上则在反序列化过程中排除多余的字段</p><p>每个都加比较麻烦，Mongo Bson提供了默认操作</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 自动注册IgnoreExtraElements</span><br>ConventionPack conventionPack = <span class="hljs-keyword">new</span> ConventionPack { <span class="hljs-keyword">new</span> IgnoreExtraElementsConvention(<span class="hljs-literal">true</span>) };<br><br>ConventionRegistry.Register(<span class="hljs-string">"IgnoreExtraElements"</span>, conventionPack, type =&gt; <span class="hljs-literal">true</span>);<br></code></pre></td></tr></tbody></table></figure><h5 id="StructBsonSerialize"><a href="#StructBsonSerialize" class="headerlink" title="StructBsonSerialize"></a>StructBsonSerialize</h5><p>注册了结构体后可以反序列化成结构体</p><h5 id="BsonDictionaryOptions"><a href="#BsonDictionaryOptions" class="headerlink" title="BsonDictionaryOptions"></a>BsonDictionaryOptions</h5><p>字典序列化时，默认的key需要为string。因为默认的json库的key是string类型</p><p><code>BsonDictionaryOptions</code>提供了多种字典序列化方式</p><p>一般用ArrayOfArray的形式</p><h5 id="BsonClassMap-LookupClassMap"><a href="#BsonClassMap-LookupClassMap" class="headerlink" title="BsonClassMap.LookupClassMap"></a>BsonClassMap.LookupClassMap</h5><p>mongo在序列化时会记录继承关系，反序列化则会成功。</p><p>但是如果直接进行反序列化，mongo默认不知道继承关系则会失败。 </p><p>把每个类型都进行注册<code>BsonClassMap.LookupClassMap(type)</code></p><h5 id="标准json格式"><a href="#标准json格式" class="headerlink" title="标准json格式"></a>标准json格式</h5><p>MongoHelper.ToJson时可以传入设置，则为标准json格式。</p><h3 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h3><p>ISerializeToEntity ComponentDB ChildrenDB</p><p>DeserializeSystem 反序列化后执行的System</p><h2 id="第十五节-Network-1"><a href="#第十五节-Network-1" class="headerlink" title="第十五节 Network-1"></a>第十五节 Network-1</h2><ul><li>socket</li><li>IP</li><li>Port</li><li>bind</li><li>accept</li><li>connect<ul><li>分为阻塞和非阻塞</li></ul></li><li>read<ul><li>分为阻塞和非阻塞</li><li>socket有缓冲区，read需要等缓冲区满了才会进行读取。</li></ul></li><li>write<ul><li>分为阻塞和非阻塞</li><li>socket有缓冲区，write等缓存去满了才会进行write操作</li></ul></li></ul><h3 id="ET的需求"><a href="#ET的需求" class="headerlink" title="ET的需求"></a>ET的需求</h3><h4 id="一个主线程-一个网络线程"><a href="#一个主线程-一个网络线程" class="headerlink" title="一个主线程 一个网络线程"></a>一个主线程 一个网络线程</h4><p>网络独立线程后不好做，对客户端而言很难实现0gc的操作不能用对象池，客户端对网络性能的需求没那么高。</p><p>对服务端而言，不是复杂场景下单线程网络线程基本满足需求。</p><h4 id="单进程有多个监听-accept-all-in-one"><a href="#单进程有多个监听-accept-all-in-one" class="headerlink" title="单进程有多个监听(accept)all in one"></a>单进程有多个监听(accept)all in one</h4><h4 id="序列化跟反序列化在网络线程，减轻主线程压力"><a href="#序列化跟反序列化在网络线程，减轻主线程压力" class="headerlink" title="序列化跟反序列化在网络线程，减轻主线程压力"></a>序列化跟反序列化在网络线程，减轻主线程压力</h4><p>如果放在主线程序列化和反序列化就会造成，在序列化后发送请求时，网络线程可能还需要等待一段时间后才会真正发送。这个时间片段内主线程又重新发送了相同的请求，如果使用了对象池就会修改到前面请求的数据。因为对象池是单线程的。</p><h3 id="ET的设计"><a href="#ET的设计" class="headerlink" title="ET的设计"></a>ET的设计</h3><p>抽象出NetService来处理主线程跟网络线程通信</p><p>抽象出AService来处理监听，管理连接</p><p>抽象出AChannel(网络连接)来做消息收发</p><p>多个AService注册到NetService</p><p>主线程封装NetComponent处理收到的连接，消息，错误</p><p>主线程封装Session做主线程消息发送，以及rpc</p><h3 id="NetServices线程安全队列"><a href="#NetServices线程安全队列" class="headerlink" title="NetServices线程安全队列"></a>NetServices线程安全队列</h3><p>NetServices主要负责主线程跟网络线程之间的通信</p><p>主线程-&gt;网络线程：</p><ol><li>创建连接创建Channel</li><li>发送消息给Channel发送</li></ol><p>网络线程-&gt;主线程: </p><ol><li>接收连接创建Session</li><li>接收消息回调主线程</li><li>网络错误回调</li></ol><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230720100918090.png" alt="image-20230720100918090"></p><h4 id="主线程回调函数"><a href="#主线程回调函数" class="headerlink" title="主线程回调函数"></a>主线程回调函数</h4><ul><li>acceptCallback</li><li>readCallback</li><li>errorCallback</li></ul><h4 id="Service管理"><a href="#Service管理" class="headerlink" title="Service管理"></a>Service管理</h4><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ConcurrentDictionary&lt;<span class="hljs-built_in">long</span>, AService&gt; services = <span class="hljs-keyword">new</span>();<br></code></pre></td></tr></tbody></table></figure><h4 id="多线程注意事项"><a href="#多线程注意事项" class="headerlink" title="多线程注意事项"></a>多线程注意事项</h4><ul><li><p>除了线程队列，一个成员永远只能一个线程操作</p><ul><li>一个方法永远只能跑在一个线程中，如果方法内操作了成员非常危险。</li></ul></li><li><p>非常清楚每个字段是哪个线程操作的，绝对不能出错</p></li><li><p><strong>NetOperator</strong>，跨线程消息要注意</p><ul><li><p>只通过跨线程的消息做跨线程的处理</p></li><li><p>只通过双队列进行跨线程的数据传递，通过Update来取出双队列的数据。</p></li></ul> <figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ConcurrentQueue&lt;NetOperator&gt; netThreadOperators = <span class="hljs-keyword">new</span> ConcurrentQueue&lt;NetOperator&gt;();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ConcurrentQueue&lt;NetOperator&gt; mainThreadOperators = <span class="hljs-keyword">new</span> ConcurrentQueue&lt;NetOperator&gt;(); <br></code></pre></td></tr></tbody></table></figure></li></ul><h2 id="第十六节-Network-2"><a href="#第十六节-Network-2" class="headerlink" title="第十六节 Network -2"></a>第十六节 Network -2</h2><h3 id="TCP特点"><a href="#TCP特点" class="headerlink" title="TCP特点"></a>TCP特点</h3><p><strong>监听的socket  监听到连接后，会返回读写的socket</strong></p><p><strong>TODO：看看TService和Tchannel</strong></p><p><strong>面向连接的协议，syn ask fin</strong> <strong>三次握手</strong></p><p><strong>可靠有序</strong></p><p><strong>滑动窗口</strong></p><p>告诉发送方还能发多少还能接受多少数据，避免一次性发送过多，把缓冲区发爆了</p><p><strong>拥塞窗口</strong></p><p>发现丢包就控制下发包数量，未确认的包过多时，则会等待确认后再发包。控制发包速度。</p><p>一旦发生丢包，发送速度会指数型的下降。但是恢复则是线性的增长。</p><p><strong>流</strong></p><p>只保证数据会发送到，不保证顺序和完整性。</p><h3 id="TCP实现"><a href="#TCP实现" class="headerlink" title="TCP实现"></a>TCP实现</h3><ul><li>CPP包装</li><li>BindSend EndSend</li><li>TcpListener TcpClient NetworkSteam<ul><li>c#提供的tcpsocket包装有少量GC</li></ul></li><li>SocketAsyncEventArgs<ul><li>用这个做异步回调，没有gc</li><li>TService</li><li>TChannel</li></ul></li><li>System.IO.Pipelines</li></ul><p>异步回调</p><ul><li>TService Listem</li><li>TChannel Read Write</li></ul><h3 id="IOCP线程，网络线程"><a href="#IOCP线程，网络线程" class="headerlink" title="IOCP线程，网络线程"></a>IOCP线程，网络线程</h3><p>windos下的网络异步api是完成端口。异步回调是在IO线程内。</p><ul><li>SocketAsyncEventArgs的回调<ul><li>回调是在另外一个线程，并不是在哪里调用就是在哪个线程。需要扔回网络线程处理</li></ul></li><li>ConcurrentQueue<targs><ul><li>网络线程处理回调的队列，收到回调时会塞数据到队列中。网络线程Update轮询拿出数据</li></ul></targs></li><li>TArgs<ul><li>类似于NetOperator，用作线程间的传递</li></ul></li></ul><h3 id="CircularBuffer"><a href="#CircularBuffer" class="headerlink" title="CircularBuffer"></a>CircularBuffer</h3><p>减少Read和Write的调用</p><p>把异步的操作变成同步操作(和缓冲队列同理，写入和读取都是同步的)</p><p>socket是在内核里的，每次调用socket的代价算是比较大的。</p><ul><li>recvBuffer<ul><li>socket写入，应用层取出调用</li></ul></li><li>sendBuffer<ul><li>应用层写入，socket取出调用</li></ul></li></ul><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230726193709984.png" alt="image-20230726193709984"></p><h3 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h3><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230726195506719.png" alt="image-20230726195506719"></p><p><code>PacketParser类</code>解析消息</p><h3 id="遇到的问题-1"><a href="#遇到的问题-1" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><ul><li>堆栈溢出<ul><li>TChannel.StartSend()内的while循环，之前是用递归写的。递归造成的问题就是调用的层数太多，会造成堆栈溢出</li></ul></li><li>Tcp在linux上占用过多线程， cpu占用过多，不好观察性能</li></ul><h2 id="第十七节-Network-3"><a href="#第十七节-Network-3" class="headerlink" title="第十七节 Network -3"></a>第十七节 Network -3</h2><h3 id="TCP的问题"><a href="#TCP的问题" class="headerlink" title="TCP的问题"></a>TCP的问题</h3><ul><li>有连接<ul><li>内核内，无法定制</li><li>不需要断开连接的时候被断开连接</li></ul></li><li>拥塞控制算法</li><li>丢包重传算法</li><li>ICMP<ul><li>TCP层发送的数据无法到达时，IP层会进行通知</li><li>上层无法控制</li></ul></li><li>容易破解<ul><li>容易创建中间连接，中间连接容易破解数据</li></ul></li><li>内核，不好定制</li></ul><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ul><li>无连接</li><li>不可靠</li><li>无序</li></ul><h3 id="KCP"><a href="#KCP" class="headerlink" title="KCP"></a>KCP</h3><ul><li>应用层连接</li><li>可靠有序<ul><li>模拟tcp</li></ul></li><li>数据冗余，降低丢包影响</li><li>拥塞控制</li><li>好定制</li><li>http3.0</li></ul><h3 id="ET-KCP改进"><a href="#ET-KCP改进" class="headerlink" title="ET KCP改进"></a>ET KCP改进</h3><ul><li>KCP默认连接端才有conn，ET双端都有conn<ul><li>PS：conn连接号</li></ul></li><li>默认客户端只能一个socket一个连接，ET一个socket可以发起多个连接<ul><li>因为双端都有conn带来的好处</li></ul></li><li>ikcp_input修改<ul><li>客户端和服务端各有各的连接号，需要删除连接号的判断条件</li><li><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230727093218220.png" alt="image-20230727093218220"></li></ul></li></ul><h4 id="KCP改造"><a href="#KCP改造" class="headerlink" title="KCP改造"></a>KCP改造</h4><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230727101112402.png" alt="image-20230727101112402"></p><h5 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h5><p>标识这条消息的类型，连接消息、断开消息、确认消息等等</p><p><code>TService.Recv()</code></p><ul><li>SYN<ul><li>accept</li></ul></li><li>ACK<ul><li>connect返回</li><li>一旦连接成功开始发送缓冲队列里的包</li></ul></li><li>FIN<ul><li>连接断开</li></ul></li><li>MSG<ul><li>包体信息</li></ul></li></ul><h5 id="Conn"><a href="#Conn" class="headerlink" title="Conn"></a>Conn</h5><p>一条消息会带自己的连接号和对面的连接号，保证无法被攻击。第三方无法读到这两个连接号。每条消息回来都会进行校验。</p><h5 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h5><p>消息的内容</p><h4 id="KCP握手"><a href="#KCP握手" class="headerlink" title="KCP握手"></a>KCP握手</h4><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230727101932122.png" alt="image-20230727101932122"></p><ol><li>连接方发送握手请求，发送自己的LocalConn。被连接方，收到请求后创建自己的LocalConn并且记录RemoteConn(对方的连接号)</li><li>ack回复，带上双方的Conn。连接方校验自己的连接号后创建连接<ol><li>ack也可能会丢包，连接方会重复发送syn请求连接</li></ol></li><li>为什么少了一次连接方的ack？因为等被连接方发送第一条msg就能表示连接成功</li></ol><h4 id="KCP收消息流程"><a href="#KCP收消息流程" class="headerlink" title="KCP收消息流程"></a>KCP收消息流程</h4><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230727103406008.png" alt="image-20230727103406008"></p><h5 id="kcp-lib"><a href="#kcp-lib" class="headerlink" title="kcp lib"></a>kcp lib</h5><p>c编写的Kcp库，收到的消息会丢到kcp库执行</p><p>可能会做排序、可靠性检查等操作(与TCP类似)</p><ol><li>KcpInput <ul><li>接受到消息后输入到kcp lib库内执行 排序、检查等操作</li></ul></li><li>KcpPeeksize <ul><li>扔进库后，马上查询kcp lib有没有拼装出完整的包，如果有完整包则读取到应用层</li></ul></li><li>KcpRecv <ul><li>应用层 通过 kcp lib中返回的数据包，在通过kcp lib读取消息</li></ul></li></ol><h4 id="KCP发消息流程"><a href="#KCP发消息流程" class="headerlink" title="KCP发消息流程"></a>KCP发消息流程</h4><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230727110904752.png" alt="image-20230727110904752"></p><ol><li>KcpWaitSend<ul><li>发送之前的检查，可能网络问题不断重试。或者等待消息超过上限，可能判断连接超时有断开连接的操作。</li></ul></li><li>KcpSend<ul><li>发送检查正常时则把需要发送的数据写入到kcp lib中。</li><li>kcp lib会把数据拆分成多个片段，判断大小根据设置走。<strong>有些路由限制了udp包的大小，超过500字节的到不了，所以et kcp外网每个udp消息限制是470大小。</strong></li></ul></li><li>KcpSetOutPut<ul><li>应用层通过KcpOutPut设置好回调，将回调设置到kcp lib库中。</li><li>KcpOutPut用udp协议，回调设置好通过upd发送到kcp lib中。</li><li>回调包含一些 发送状态的信息</li></ul></li></ol><h4 id="KService-KChannel"><a href="#KService-KChannel" class="headerlink" title="KService KChannel"></a>KService KChannel</h4><h5 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h5><p>KService内有一个Socket，用来收发udp消息。</p><p>同步读socket消息时判断<code>Socket.Available&gt;0</code>。当缓冲队列数据量&gt;0时才进行真正读取，虽然是同步的但是不会造成阻塞。</p><p>PS:如果当前使用的是非阻止 <a href="https://msdn.microsoft.com/zh-cn/library/system.net.sockets.socket(v=vs.110).aspx">Socket</a>，一种较好的做法是在调用 <a href="https://msdn.microsoft.com/zh-cn/library/26f591ax(v=vs.110).aspx">Receive</a> 之前使用 Available 来确定数据是否排队等待读取。可用的数据即网络缓冲区中排队等待读取的全部数据。如果在网络缓冲区中没有排队的数据，则 Available 返回 0。</p><h5 id="KService计时器"><a href="#KService计时器" class="headerlink" title="KService计时器"></a>KService计时器</h5><p>独立的计时器，因为是在网络线程</p><h5 id="InitKcp"><a href="#InitKcp" class="headerlink" title="InitKcp"></a>InitKcp</h5><p>具体参数需要结合文档</p><p><a href="https://github.com/skywind3000/kcp/wiki/KCP-Basic-Usage#%E5%8D%8F%E8%AE%AE%E9%85%8D%E7%BD%AE">KCP Basic Usage · skywind3000/kcp Wiki (github.com)</a></p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitKcp</span>()</span><br>{<br>   <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.Service.ServiceType)<br>   {<br>      <span class="hljs-keyword">case</span> ServiceType.Inner:<br>         <span class="hljs-keyword">this</span>.kcp.SetNoDelay(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">true</span>);<br>         <span class="hljs-keyword">this</span>.kcp.SetWindowSize(<span class="hljs-number">1024</span>, <span class="hljs-number">1024</span>);<br>         <span class="hljs-comment">//分片包大小</span><br>         <span class="hljs-keyword">this</span>.kcp.SetMtu(<span class="hljs-number">1400</span>); <span class="hljs-comment">// 默认1400</span><br>         <span class="hljs-keyword">this</span>.kcp.SetMinrto(<span class="hljs-number">30</span>);<br>         <span class="hljs-keyword">this</span>.kcp.InitArrayPool(<span class="hljs-number">1600</span>, <span class="hljs-number">10000</span>);<br>         <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> ServiceType.Outer:<br>         <span class="hljs-keyword">this</span>.kcp.SetNoDelay(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">true</span>);<br>         <span class="hljs-keyword">this</span>.kcp.SetWindowSize(<span class="hljs-number">256</span>, <span class="hljs-number">256</span>);<br>         <span class="hljs-keyword">this</span>.kcp.SetMtu(<span class="hljs-number">470</span>);<br>         <span class="hljs-keyword">this</span>.kcp.SetMinrto(<span class="hljs-number">30</span>);<br>         <span class="hljs-keyword">this</span>.kcp.InitArrayPool(<span class="hljs-number">600</span>, <span class="hljs-number">10000</span>);<br>         <span class="hljs-keyword">break</span>;<br>   }<br>}<br></code></pre></td></tr></tbody></table></figure><h5 id="大包的实现"><a href="#大包的实现" class="headerlink" title="大包的实现"></a>大包的实现</h5><p>超过大包设置的限定值时，进行分片处理</p><h6 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a>发送端</h6><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 先发分片信息</span><br><span class="hljs-comment">// 头部信息，和普通消息做区分，前4个字节是0则代表是分片的包。</span><br><span class="hljs-keyword">this</span>.sendCache.WriteTo(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 5-8字节 包体大小</span><br><span class="hljs-keyword">this</span>.sendCache.WriteTo(<span class="hljs-number">4</span>, count);<br><span class="hljs-keyword">this</span>.kcp.Send(<span class="hljs-keyword">this</span>.sendCache.AsSpan(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>));<br><br><span class="hljs-comment">// 分片发送</span><br><span class="hljs-built_in">int</span> alreadySendCount = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (alreadySendCount &lt; count)<br>{<br>    <span class="hljs-built_in">int</span> leftCount = count - alreadySendCount;<br>    <span class="hljs-built_in">int</span> sendCount = leftCount &lt; AService.MaxCacheBufferSize? leftCount: AService.MaxCacheBufferSize;<br>    <span class="hljs-keyword">this</span>.kcp.Send(memoryStream.GetBuffer().AsSpan((<span class="hljs-built_in">int</span>)memoryStream.Position + alreadySendCount, sendCount));<br><br>    alreadySendCount += sendCount;<br>}<br></code></pre></td></tr></tbody></table></figure><h6 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a>接收端</h6><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>{<br>    <span class="hljs-comment">//...一堆判断条件这里省略</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.needReadSplitCount &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 说明消息分片了</span><br>    {<br>        <span class="hljs-built_in">byte</span>[] buffer = readMemory.GetBuffer();<br>        <span class="hljs-built_in">int</span> count = <span class="hljs-keyword">this</span>.kcp.Receive(buffer.AsSpan((<span class="hljs-built_in">int</span>)(<span class="hljs-keyword">this</span>.readMemory.Length - <span class="hljs-keyword">this</span>.needReadSplitCount), n));<br>        <span class="hljs-keyword">this</span>.needReadSplitCount -= count;<br>        <span class="hljs-keyword">if</span> (n != count)<br>        {<br>            Log.Error(<span class="hljs-string">$"kchannel read error1: <span class="hljs-subst">{<span class="hljs-keyword">this</span>.LocalConn}</span> <span class="hljs-subst">{<span class="hljs-keyword">this</span>.RemoteConn}</span>"</span>);<br>            <span class="hljs-keyword">this</span>.OnError(ErrorCore.ERR_KcpReadNotSame);<br>            <span class="hljs-keyword">return</span>;<br>        }<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.needReadSplitCount &lt; <span class="hljs-number">0</span>)<br>        {<br>            Log.Error(<span class="hljs-string">$"kchannel read error2: <span class="hljs-subst">{<span class="hljs-keyword">this</span>.LocalConn}</span> <span class="hljs-subst">{<span class="hljs-keyword">this</span>.RemoteConn}</span>"</span>);<br>            <span class="hljs-keyword">this</span>.OnError(ErrorCore.ERR_KcpSplitError);<br>            <span class="hljs-keyword">return</span>;<br>        }<br><br>        <span class="hljs-comment">// 没有读完</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.needReadSplitCount != <span class="hljs-number">0</span>)<br>        {<br>            <span class="hljs-keyword">continue</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">else</span><br>    {<br>        <span class="hljs-keyword">this</span>.readMemory = <span class="hljs-keyword">this</span>.Service.Fetch(n);<br>        <span class="hljs-keyword">this</span>.readMemory.SetLength(n);<br>        <span class="hljs-keyword">this</span>.readMemory.Seek(<span class="hljs-number">0</span>, SeekOrigin.Begin);<br><br>        <span class="hljs-built_in">byte</span>[] buffer = readMemory.GetBuffer();<br><br>        <span class="hljs-built_in">int</span> count = <span class="hljs-keyword">this</span>.kcp.Receive(buffer.AsSpan(<span class="hljs-number">0</span>, n));<br>        <span class="hljs-keyword">if</span> (n != count)<br>        {<br>            <span class="hljs-keyword">break</span>;<br>        }<br><br>        <span class="hljs-comment">// 如果是8字节代表有可能是分片包</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">8</span>)<br>        {<br>            <span class="hljs-comment">// 如果前4个字节是0则代表是分片包</span><br>            <span class="hljs-built_in">int</span> headInt = BitConverter.ToInt32(<span class="hljs-keyword">this</span>.readMemory.GetBuffer(), <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (headInt == <span class="hljs-number">0</span>)<br>            {<br>                <span class="hljs-keyword">this</span>.needReadSplitCount = BitConverter.ToInt32(readMemory.GetBuffer(), <span class="hljs-number">4</span>);<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.needReadSplitCount &lt;= AService.MaxCacheBufferSize)<br>                {<br>                    Log.Error(<span class="hljs-string">$"kchannel read error3: <span class="hljs-subst">{<span class="hljs-keyword">this</span>.needReadSplitCount}</span> <span class="hljs-subst">{<span class="hljs-keyword">this</span>.LocalConn}</span> <span class="hljs-subst">{<span class="hljs-keyword">this</span>.RemoteConn}</span>"</span>);<br>                    <span class="hljs-keyword">this</span>.OnError(ErrorCore.ERR_KcpSplitCountError);<br>                    <span class="hljs-keyword">return</span>;<br>                }<br>                <span class="hljs-comment">//打包的长度</span><br>                <span class="hljs-keyword">this</span>.readMemory.SetLength(<span class="hljs-keyword">this</span>.needReadSplitCount);<br>                <span class="hljs-keyword">this</span>.readMemory.Seek(<span class="hljs-number">0</span>, SeekOrigin.Begin);<br>                <span class="hljs-keyword">continue</span>;<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h5 id="代码实现细节"><a href="#代码实现细节" class="headerlink" title="代码实现细节"></a>代码实现细节</h5><h6 id="设置缓冲区"><a href="#设置缓冲区" class="headerlink" title="设置缓冲区"></a>设置缓冲区</h6><p>一个socket对应多条回调的连接监听，缓存区太小容易爆掉</p><p><strong>OSX平台无效</strong></p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">if</span> (!RuntimeInformation.IsOSPlatform(OSPlatform.OSX))<br>{<br>    <span class="hljs-keyword">this</span>.Socket.SendBufferSize = Kcp.OneM * <span class="hljs-number">64</span>;<br>    <span class="hljs-keyword">this</span>.Socket.ReceiveBufferSize = Kcp.OneM * <span class="hljs-number">64</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h6 id="发送时的RemoteConn设置"><a href="#发送时的RemoteConn设置" class="headerlink" title="发送时的RemoteConn设置"></a>发送时的RemoteConn设置</h6><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Output</span>(<span class="hljs-params"><span class="hljs-built_in">byte</span>[] bytes, <span class="hljs-built_in">int</span> count</span>)</span><br>{<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.IsDisposed)<br>    {<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    <span class="hljs-keyword">try</span><br>    {           <br>        <span class="hljs-comment">// 没连接上 kcp不往外发消息, 其实本来没连接上不会调用update，这里只是做一层保护</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.IsConnected)<br>        {<br>            <span class="hljs-keyword">return</span>;<br>        }<br><br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>)<br>        {<br>            Log.Error(<span class="hljs-string">$"output 0"</span>);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        bytes.WriteTo(<span class="hljs-number">0</span>, KcpProtocalType.MSG);<br>        <span class="hljs-comment">// 每个消息头部写下该channel的id;</span><br>        bytes.WriteTo(<span class="hljs-number">1</span>, <span class="hljs-keyword">this</span>.LocalConn);<br>        <span class="hljs-comment">//这里只写入了LocalConn没有写入RemoteConn，是因为输入的bytes就带了RemoteConn</span><br>        <span class="hljs-keyword">this</span>.Service.Socket.SendTo(bytes, <span class="hljs-number">0</span>, count + <span class="hljs-number">5</span>, SocketFlags.None, <span class="hljs-keyword">this</span>.RemoteAddress);<br>    }<br></code></pre></td></tr></tbody></table></figure><h6 id="SetSioUdpConnReset"><a href="#SetSioUdpConnReset" class="headerlink" title="SetSioUdpConnReset"></a>SetSioUdpConnReset</h6><p>只在window平台存在的问题。设置屏蔽</p><p>a向b发送upd的包，a如果关闭了socket会通知b也需要关闭socket</p><h6 id="KChannel连接"><a href="#KChannel连接" class="headerlink" title="KChannel连接"></a>KChannel连接</h6><p>没连接成功前300毫秒发送一次请求连接。</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> timeNow</span>)</span><br>{<br>    <span class="hljs-keyword">try</span><br>    {<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.IsConnected)<br>        {<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-comment">// 300毫秒后再次update发送connect请求</span><br>        <span class="hljs-keyword">if</span> (timeNow &lt; <span class="hljs-keyword">this</span>.lastConnectTime + <span class="hljs-number">300</span>)<br>        {<br>            <span class="hljs-comment">//加到Service的updateChannel里做轮询连接</span><br>            <span class="hljs-keyword">this</span>.Service.AddToUpdate(<span class="hljs-number">300</span>, <span class="hljs-keyword">this</span>.Id);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-comment">// 10秒连接超时</span><br>        <span class="hljs-keyword">if</span> (timeNow &gt; <span class="hljs-keyword">this</span>.CreateTime + KService.ConnectTimeoutTime)<br>        {<br>            Log.Error(<span class="hljs-string">$"kChannel connect timeout: <span class="hljs-subst">{<span class="hljs-keyword">this</span>.Id}</span> <span class="hljs-subst">{<span class="hljs-keyword">this</span>.RemoteConn}</span> <span class="hljs-subst">{timeNow}</span> <span class="hljs-subst">{<span class="hljs-keyword">this</span>.CreateTime}</span> <span class="hljs-subst">{<span class="hljs-keyword">this</span>.ChannelType}</span> <span class="hljs-subst">{<span class="hljs-keyword">this</span>.RemoteAddress}</span>"</span>);<br>            <span class="hljs-keyword">this</span>.OnError(ErrorCore.ERR_KcpConnectTimeout);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-built_in">byte</span>[] buffer = sendCache;<br>        buffer.WriteTo(<span class="hljs-number">0</span>, KcpProtocalType.SYN);<br>        buffer.WriteTo(<span class="hljs-number">1</span>, <span class="hljs-keyword">this</span>.LocalConn);<br>        buffer.WriteTo(<span class="hljs-number">5</span>, <span class="hljs-keyword">this</span>.RemoteConn);<br>        <span class="hljs-keyword">this</span>.Service.Socket.SendTo(buffer, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>, SocketFlags.None, <span class="hljs-keyword">this</span>.RemoteAddress);<br>        <span class="hljs-comment">// 这里很奇怪 调用socket.LocalEndPoint会动到this.RemoteAddressNonAlloc里面的temp，这里就不仔细研究了</span><br>        Log.Info(<span class="hljs-string">$"kchannel connect <span class="hljs-subst">{<span class="hljs-keyword">this</span>.LocalConn}</span> <span class="hljs-subst">{<span class="hljs-keyword">this</span>.RemoteConn}</span> <span class="hljs-subst">{<span class="hljs-keyword">this</span>.RealAddress}</span>"</span>);<br><br>        <span class="hljs-keyword">this</span>.lastConnectTime = timeNow;<br><br>        <span class="hljs-keyword">this</span>.Service.AddToUpdate(<span class="hljs-number">300</span>, <span class="hljs-keyword">this</span>.Id);<br>    }<br>    <span class="hljs-keyword">catch</span> (Exception e)<br>    {<br>        Log.Error(e);<br>        <span class="hljs-keyword">this</span>.OnError(ErrorCore.ERR_SocketCantSend);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="第十八节-Network-4"><a href="#第十八节-Network-4" class="headerlink" title="第十八节 Network -4"></a>第十八节 Network -4</h2><h3 id="NetworkComponent"><a href="#NetworkComponent" class="headerlink" title="NetworkComponent"></a>NetworkComponent</h3><ol><li>处理收消息，接收连接，错误等回调<ul><li>NetClientComponent</li><li>NetServerComponent</li><li>NetInnerComponent<ul><li>内部进程通信</li></ul></li></ul></li><li>管理主动的连接跟accept的连接</li></ol><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><ol><li>发消息</li><li>rpc</li></ol><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230727152954789.png" alt="image-20230727152954789"></p><h3 id="配合主线程网络的组件"><a href="#配合主线程网络的组件" class="headerlink" title="配合主线程网络的组件"></a>配合主线程网络的组件</h3><h4 id="OpcodeTypeComponent"><a href="#OpcodeTypeComponent" class="headerlink" title="OpcodeTypeComponent"></a>OpcodeTypeComponent</h4><ol><li>记录外网消息</li><li>记录Request跟Response配对</li></ol><h4 id="MessageDispatcherComponent"><a href="#MessageDispatcherComponent" class="headerlink" title="MessageDispatcherComponent"></a>MessageDispatcherComponent</h4><p>协议消息的分发</p><p>根据Opcode管理具体的事件队列</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> Dictionary&lt;<span class="hljs-built_in">ushort</span>, List&lt;MessageDispatcherInfo&gt;&gt; Handlers = <span class="hljs-keyword">new</span>();<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MessageDispatcherInfo</span><br>{<br>    <span class="hljs-keyword">public</span> SceneType SceneType { <span class="hljs-keyword">get</span>; }<br>    <span class="hljs-keyword">public</span> IMHandler IMHandler { <span class="hljs-keyword">get</span>; }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MessageDispatcherInfo</span>(<span class="hljs-params">SceneType sceneType, IMHandler imHandler</span>)</span><br>    {<br>        <span class="hljs-keyword">this</span>.SceneType = sceneType;<br>        <span class="hljs-keyword">this</span>.IMHandler = imHandler;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>程序启动时，根据Handler标签进行注册绑定。</p><h5 id="Handler划分"><a href="#Handler划分" class="headerlink" title="Handler划分"></a>Handler划分</h5><ul><li>AMHandler<ul><li>正常调用，没有返回值</li></ul></li><li>AMRpcHandler<ul><li>Rpc调用会创建Response返回并发送给对面</li></ul></li></ul><h4 id="SessionAcceptTimeoutComponent"><a href="#SessionAcceptTimeoutComponent" class="headerlink" title="SessionAcceptTimeoutComponent"></a>SessionAcceptTimeoutComponent</h4><p>连接长时间占用消耗资源</p><p><code>SessionAcceptTimeoutComponent</code>维护连接的时长，持有该组件并且超过限定时间则进行断开连接。</p><p>一些外挂会长时间连接只监听消息</p><h4 id="PingComponent"><a href="#PingComponent" class="headerlink" title="PingComponent"></a>PingComponent</h4><p>心跳包组件，与SessionIdleCheckerComponent对应</p><p>客户端挂上PingComponent，每固定时间发送消息。保持连接</p><h4 id="SessionIdleCheckerComponent"><a href="#SessionIdleCheckerComponent" class="headerlink" title="SessionIdleCheckerComponent"></a>SessionIdleCheckerComponent</h4><p>Session挂上SessionIdleCheckerComponent，超过时间没收到PingComponent判断为断开</p><h4 id="SessionMessageStatisticsComponent"><a href="#SessionMessageStatisticsComponent" class="headerlink" title="SessionMessageStatisticsComponent"></a>SessionMessageStatisticsComponent</h4><p>ET里没有这个组件</p><p>记录一段时间内收了多少条客户端消息。判断是否被发起攻击或者写出bug。检测出异常。</p><h2 id="第十九节-软路由"><a href="#第十九节-软路由" class="headerlink" title="第十九节 软路由"></a>第十九节 软路由</h2><p>防止黑客攻击的功能</p><h3 id="黑客攻击"><a href="#黑客攻击" class="headerlink" title="黑客攻击"></a>黑客攻击</h3><h4 id="tcp连接攻击"><a href="#tcp连接攻击" class="headerlink" title="tcp连接攻击"></a>tcp连接攻击</h4><p>黑客创建很多肉鸡创建很多tcp连接，tcp连接消耗内存会把服务器挤爆。</p><h4 id="流量攻击"><a href="#流量攻击" class="headerlink" title="流量攻击"></a>流量攻击</h4><p>不停发消息，把流量吃满。接受不到正常玩家消息也发送不出去</p><h4 id="协议攻击"><a href="#协议攻击" class="headerlink" title="协议攻击"></a>协议攻击</h4><p>破解协议，发送莫名其妙的东西</p><h3 id="Http防攻击"><a href="#Http防攻击" class="headerlink" title="Http防攻击"></a>Http防攻击</h3><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230728163810320.png" alt="image-20230728163810320"></p><p>http防攻击是每次http请求都通过cdn进行中介请求，实际上被攻击的会是cdn。一台崩了其他的还是正常运行。</p><h3 id="游戏跟http不同"><a href="#游戏跟http不同" class="headerlink" title="游戏跟http不同"></a>游戏跟http不同</h3><ul><li>实时性更高</li><li>交互性更多<ul><li>功能之间交互多，不像http可以拆分成各种服务</li></ul></li><li>逻辑更复杂</li><li>服务更集中</li><li>长连接</li></ul><h3 id="大部分游戏服务器的弱点"><a href="#大部分游戏服务器的弱点" class="headerlink" title="大部分游戏服务器的弱点"></a>大部分游戏服务器的弱点</h3><ul><li>TCP<ul><li>只同步协议一样要分配资源</li></ul></li><li>对外地址固定<ul><li>对外的地址是公布的，容易暴漏地址</li></ul></li><li>协议过于简单</li></ul><h3 id="大部分黑客的特点"><a href="#大部分黑客的特点" class="headerlink" title="大部分黑客的特点"></a>大部分黑客的特点</h3><ul><li>流量不多<ul><li>流量大不会攻击小游戏</li></ul></li><li>攻击单个地址<ul><li>成本问题</li></ul></li><li>比较少进行协议破解攻击<ul><li>技术含量比较高</li></ul></li></ul><h3 id="针对性解决"><a href="#针对性解决" class="headerlink" title="针对性解决"></a>针对性解决</h3><ul><li>使用UDP</li><li>多个对外地址</li><li>提高协议复杂性，提高破解难度</li></ul><h3 id="防攻击目标"><a href="#防攻击目标" class="headerlink" title="防攻击目标"></a>防攻击目标</h3><ul><li>服务器不能受影响</li><li>保持连接，不能让在线的玩家掉线</li><li>在线玩家无感</li></ul><h3 id="软路由方案，增加类似CDN的东西"><a href="#软路由方案，增加类似CDN的东西" class="headerlink" title="软路由方案，增加类似CDN的东西"></a>软路由方案，增加类似CDN的东西</h3><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230728171109863.png" alt="image-20230728171109863"></p><h4 id="软路由设计"><a href="#软路由设计" class="headerlink" title="软路由设计"></a>软路由设计</h4><ul><li><p>使用UDP+KCP</p><ul><li>tcp可以吗？<ul><li>软路由如果与客户端用TCP连接，那攻击软路由一样会挂掉</li></ul></li><li>主要利用KCP的有序可靠性</li></ul></li><li><p>一个软路由被攻击，玩家客户端可以切换其它软路由转发</p><ul><li>客户端发现卡顿时，超过限定时间会切换路由，重新请求连接。gate发现ReConnect请求后会变更软路由的地址连接。</li><li>在切换软路由过程中，网关怎么知道发送给软路由的包没真正到达客户端？<ul><li>KCP的消息需要确认，收到会发确认包，没收到确认包则会重发。客户端如果收到两条相同的包也会剔除相同的。(KCP底层实现)</li></ul></li></ul></li><li><p>随时增加减少软路由进程</p></li><li><p>获取软路由服务，使用cdn保护</p><ul><li>软路由的地址通过cdn或缺</li></ul></li></ul><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230728173529322.png" alt="image-20230728173529322"></p><h4 id="RouterComponet"><a href="#RouterComponet" class="headerlink" title="RouterComponet"></a>RouterComponet</h4><p>本质就是校验安全性并且转发的过程</p><p>包含一个内网地址和一个外网地址</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//正在连接，握手的节点</span><br><span class="hljs-keyword">public</span> Dictionary&lt;<span class="hljs-built_in">uint</span>, RouterNode&gt; ConnectIdNodes = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">uint</span>, RouterNode&gt;();<br><br><span class="hljs-comment">// 已经连接成功的，虽然跟id一样，但是没有经过验证的不会加到这里</span><br><span class="hljs-keyword">public</span> Dictionary&lt;<span class="hljs-built_in">uint</span>, RouterNode&gt; OuterNodes = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">uint</span>, RouterNode&gt;();<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//update轮询查询，内网和外网的监听</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params">RouterComponent self</span>)</span><br>{<br>    <span class="hljs-built_in">long</span> timeNow = TimeHelper.ClientNow();<br>    self.RecvOuter(timeNow);<br>    self.RecvInner(timeNow);<br><br>    <span class="hljs-comment">// 每秒钟检查一次</span><br>    <span class="hljs-keyword">if</span> (timeNow - self.LastCheckTime &gt; <span class="hljs-number">1000</span>)<br>    {<br>        self.CheckConnectTimeout(timeNow);<br>        self.LastCheckTime = timeNow;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>连接与kcp连接不同的是需要告诉路由要连接的地址</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">case</span> KcpProtocalType.RouterReconnectSYN:<br>{<br>    <span class="hljs-keyword">if</span> (messageLength &lt; <span class="hljs-number">13</span>)<br>    {<br>        <span class="hljs-keyword">break</span>;<br>    }<br><br>    <span class="hljs-built_in">uint</span> outerConn = BitConverter.ToUInt32(self.Cache, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">uint</span> innerConn = BitConverter.ToUInt32(self.Cache, <span class="hljs-number">5</span>);<br>    <span class="hljs-comment">//要连接路由的地址，后续不需要发送</span><br>    <span class="hljs-built_in">uint</span> connectId = BitConverter.ToUInt32(self.Cache, <span class="hljs-number">9</span>);<br>    <span class="hljs-built_in">string</span> realAddress = self.Cache.ToStr(<span class="hljs-number">13</span>, messageLength - <span class="hljs-number">13</span>);<br><br>    RouterNode routerNode;<br><br>    <span class="hljs-comment">// RouterAck之后ConnectIdNodes会删除，加入到OuterNodes中来</span><br>    <span class="hljs-keyword">if</span> (!self.OuterNodes.TryGetValue(outerConn, <span class="hljs-keyword">out</span> routerNode))<br>    {<br>        self.ConnectIdNodes.TryGetValue(connectId, <span class="hljs-keyword">out</span> routerNode);<br>        <span class="hljs-keyword">if</span> (routerNode == <span class="hljs-literal">null</span>)<br>        {<br>            Log.Info(<span class="hljs-string">$"router create reconnect: <span class="hljs-subst">{self.IPEndPoint}</span> <span class="hljs-subst">{realAddress}</span> <span class="hljs-subst">{connectId}</span> <span class="hljs-subst">{outerConn}</span> <span class="hljs-subst">{innerConn}</span>"</span>);<br>            routerNode = self.New(realAddress, connectId, outerConn, innerConn, self.CloneAddress());<br>            <span class="hljs-comment">// self.OuterNodes 这里不能add，因为还没验证完成,要在RouterAck中加入</span><br>        }<br>    }<br><br>    <span class="hljs-keyword">if</span> (routerNode.ConnectId != connectId)<br>    {<br>        Log.Warning(<span class="hljs-string">$"kcp router router reconnect connectId diff1: <span class="hljs-subst">{routerNode.SyncIpEndPoint}</span> <span class="hljs-subst">{(IPEndPoint) self.IPEndPoint}</span>"</span>);<br>        <span class="hljs-keyword">break</span>;<br>    }<br>    <br>    <span class="hljs-comment">// 不是自己的，outerConn冲突, 直接break,也就是说这个软路由上有个跟自己outerConn冲突的连接，就不能连接了</span><br>    <span class="hljs-comment">// 这个路由连接不上，客户端会换个软路由，所以没关系</span><br>    <span class="hljs-keyword">if</span> (routerNode.InnerConn != innerConn)<br>    {<br>        Log.Warning(<span class="hljs-string">$"kcp router router reconnect inner conn diff1: <span class="hljs-subst">{routerNode.SyncIpEndPoint}</span> <span class="hljs-subst">{(IPEndPoint) self.IPEndPoint}</span>"</span>);<br>        <span class="hljs-keyword">break</span>;<br>    }<br>    <br>    <span class="hljs-keyword">if</span> (routerNode.OuterConn != outerConn)<br>    {<br>        Log.Warning(<span class="hljs-string">$"kcp router router reconnect outer conn diff1: <span class="hljs-subst">{routerNode.SyncIpEndPoint}</span> <span class="hljs-subst">{(IPEndPoint) self.IPEndPoint}</span>"</span>);<br>        <span class="hljs-keyword">break</span>;<br>    }<br><br>    <span class="hljs-comment">// 校验ip，连接过程中ip不能变化</span><br>    <span class="hljs-keyword">if</span> (!Equals(routerNode.SyncIpEndPoint, self.IPEndPoint))<br>    {<br>        Log.Warning(<span class="hljs-string">$"kcp router syn ip is diff1: <span class="hljs-subst">{routerNode.SyncIpEndPoint}</span> <span class="hljs-subst">{(IPEndPoint) self.IPEndPoint}</span>"</span>);<br>        <span class="hljs-keyword">break</span>;<br>    }<br><br>    <span class="hljs-comment">// 校验内网地址</span><br>    <span class="hljs-keyword">if</span> (routerNode.InnerAddress != realAddress)<br>    {<br>        Log.Warning(<span class="hljs-string">$"router sync error2: <span class="hljs-subst">{routerNode.OuterConn}</span> <span class="hljs-subst">{routerNode.InnerAddress}</span> <span class="hljs-subst">{outerConn}</span> <span class="hljs-subst">{realAddress}</span>"</span>);<br>        <span class="hljs-keyword">break</span>;<br>    }<br>    <span class="hljs-comment">//大于40条连接请求则判断为是异常连接</span><br>    <span class="hljs-keyword">if</span> (++routerNode.RouterSyncCount &gt; <span class="hljs-number">40</span>)<br>    {<br>        self.OnError(routerNode.Id, ErrorCore.ERR_KcpRouterRouterSyncCountTooMuchTimes);<br>        <span class="hljs-keyword">break</span>;<br>    }<br><br>    <span class="hljs-comment">// 转发到内网</span><br>    self.Cache.WriteTo(<span class="hljs-number">0</span>, KcpProtocalType.RouterReconnectSYN);<br>    self.Cache.WriteTo(<span class="hljs-number">1</span>, outerConn);<br>    self.Cache.WriteTo(<span class="hljs-number">5</span>, innerConn);<br>    self.Cache.WriteTo(<span class="hljs-number">9</span>, connectId);<br>    self.InnerSocket.SendTo(self.Cache, <span class="hljs-number">0</span>, <span class="hljs-number">13</span>, SocketFlags.None, routerNode.InnerIpEndPoint);<br><br>    <span class="hljs-keyword">if</span> (!routerNode.CheckOuterCount(timeNow))<br>    {<br>        self.OnError(routerNode.Id, ErrorCore.ERR_KcpRouterTooManyPackets);<br>    }<br><br>    <span class="hljs-keyword">break</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h5 id="路由重连"><a href="#路由重连" class="headerlink" title="路由重连"></a>路由重连</h5><p>路由繁忙重新选择路由时，软路由转发给网关，网关会进行remoteConn和localConn的校验，判断只有是链接过的没有造假。并且ip地址不能变化。</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">KcpProtocalType.RouterReconnectSYN<br></code></pre></td></tr></tbody></table></figure><p>KService的网关校验</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">case</span> KcpProtocalType.RouterReconnectSYN:<br>{<br>    <span class="hljs-comment">// 长度!=5，不是RouterReconnectSYN消息</span><br>    <span class="hljs-keyword">if</span> (messageLength != <span class="hljs-number">13</span>)<br>    {<br>        <span class="hljs-keyword">break</span>;<br>    }<br><br>    <span class="hljs-built_in">string</span> realAddress = <span class="hljs-literal">null</span>;<br>    remoteConn = BitConverter.ToUInt32(<span class="hljs-keyword">this</span>.cache, <span class="hljs-number">1</span>);<br>    localConn = BitConverter.ToUInt32(<span class="hljs-keyword">this</span>.cache, <span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">uint</span> connectId = BitConverter.ToUInt32(<span class="hljs-keyword">this</span>.cache, <span class="hljs-number">9</span>);<br><br>    <span class="hljs-keyword">this</span>.localConnChannels.TryGetValue(localConn, <span class="hljs-keyword">out</span> kChannel);<br>    <span class="hljs-keyword">if</span> (kChannel == <span class="hljs-literal">null</span>)<br>    {<br>        Log.Warning(<span class="hljs-string">$"kchannel reconnect not found channel: <span class="hljs-subst">{localConn}</span> <span class="hljs-subst">{remoteConn}</span> <span class="hljs-subst">{realAddress}</span>"</span>);<br>        <span class="hljs-keyword">break</span>;<br>    }<br><br>    <span class="hljs-comment">// 这里必须校验localConn，客户端重连，localConn一定是一样的</span><br>    <span class="hljs-keyword">if</span> (localConn != kChannel.LocalConn)<br>    {<br>        Log.Warning(<span class="hljs-string">$"kchannel reconnect localconn error: <span class="hljs-subst">{localConn}</span> <span class="hljs-subst">{remoteConn}</span> <span class="hljs-subst">{realAddress}</span> <span class="hljs-subst">{kChannel.LocalConn}</span>"</span>);<br>        <span class="hljs-keyword">break</span>;<br>    }<br><br>    <span class="hljs-keyword">if</span> (remoteConn != kChannel.RemoteConn)<br>    {<br>        Log.Warning(<span class="hljs-string">$"kchannel reconnect remoteconn error: <span class="hljs-subst">{localConn}</span> <span class="hljs-subst">{remoteConn}</span> <span class="hljs-subst">{realAddress}</span> <span class="hljs-subst">{kChannel.RemoteConn}</span>"</span>);<br>        <span class="hljs-keyword">break</span>;<br>    }<br><br>    <span class="hljs-comment">// 重连的时候router地址变化, 这个不能放到msg中，必须经过严格的验证才能切换</span><br>    <span class="hljs-keyword">if</span> (!Equals(kChannel.RemoteAddress, <span class="hljs-keyword">this</span>.ipEndPoint))<br>    {<br>        kChannel.RemoteAddress = <span class="hljs-keyword">this</span>.CloneAddress();<br>    }<br><br>    <span class="hljs-keyword">try</span><br>    {<br>        <span class="hljs-built_in">byte</span>[] buffer = <span class="hljs-keyword">this</span>.cache;<br>        buffer.WriteTo(<span class="hljs-number">0</span>, KcpProtocalType.RouterReconnectACK);<br>        buffer.WriteTo(<span class="hljs-number">1</span>, kChannel.LocalConn);<br>        buffer.WriteTo(<span class="hljs-number">5</span>, kChannel.RemoteConn);<br>        buffer.WriteTo(<span class="hljs-number">9</span>, connectId);<br>        <span class="hljs-keyword">this</span>.socket.SendTo(buffer, <span class="hljs-number">0</span>, <span class="hljs-number">13</span>, SocketFlags.None, <span class="hljs-keyword">this</span>.ipEndPoint);<br>    }<br>    <span class="hljs-keyword">catch</span> (Exception e)<br>    {<br>        Log.Error(e);<br>        kChannel.OnError(ErrorCore.ERR_SocketCantSend);<br>    }<br><br>    <span class="hljs-keyword">break</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h5 id="客户端登录时的操作"><a href="#客户端登录时的操作" class="headerlink" title="客户端登录时的操作"></a>客户端登录时的操作</h5><p><code>RouterAddressComponent</code>登陆时获取软路由列表</p><p>localConn为软路由创建并返回客户端，因为如果都由客户端随机也有可能重复。</p><h2 id="第二十节-Actor"><a href="#第二十节-Actor" class="headerlink" title="第二十节 Actor"></a>第二十节 Actor</h2><p>传统意义的多线程写法，需要加各种锁做限制，逻辑复杂后锁容易被遗漏，或者多加了锁造成难以维护，变量膨胀。</p><h3 id="why-Actor？"><a href="#why-Actor？" class="headerlink" title="why Actor？"></a>why Actor？</h3><p>每个线程都有自己的变量，每个线程都维护自己的变量。当线程需要访问其他线程的变量时，实际是告诉其他线程自己要执行什么操作。</p><h3 id="Erlang对Actor的进阶设计"><a href="#Erlang对Actor的进阶设计" class="headerlink" title="Erlang对Actor的进阶设计"></a>Erlang对Actor的进阶设计</h3><p>如果只对线程进行actor的操作，实际上还是可以访问到其他线程的变量。如果使用不规范还是会造成bug。</p><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230731095715561.png" alt="image-20230731095715561"></p><p>不同进程之间进行调度，只需要把需要使用到的进程processid和参数传递到消息通道内，等消息通道执行到时对应进程再从消息通道中取出数据进行执行。</p><p>Erlang对Actor抽象出进程的概念，不同进程之间是不共享内存的所以无法直接访问到其他进程的变量，只通过消息通道进行传递。</p><p>每个虚拟进程都只会通过一个线程进行调度，进程变量通过一个线程进行访问。</p><p>Erlang的虚拟进程使用成本较低，只是数据结构包装成的进程。不需要到内核态进行创建进程，并且能够进行访问地址的有效隔离。</p><h3 id="ET-Actor"><a href="#ET-Actor" class="headerlink" title="ET Actor"></a>ET Actor</h3><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230731101934132.png" alt="image-20230731101934132"></p><p>每个进程都有很多个Entity，每个Entity都有一个Id，Id带有进程的信息。发消息的时候只需要知道id就能够进行通信。</p><p>ET的Actor进一步的扩展，可以直接通知到进程中的对象上。而Erlang只能通知到进程，进程再一步通知给对象。</p><p><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230731102622947.png" alt="image-20230731102622947"></p><h4 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h4><ul><li>InstanceId<ul><li>每个Scene在配置中都有自己的id，在配置AfterEndInit时构造出InstanceId。</li></ul></li><li>StartSceneConfig Scene的InstanceId</li><li>服务器所有内部消息发送，gate转发<ul><li>服务器所有内部信息都用Actor发送</li></ul></li><li>MailboxComponent 三种MailboxType<ul><li><code>MessageDispatcher</code>:队列处理，后续消息都需要进行等待处理完成。</li><li><code>UnOrderMessageDispatcher</code>:不等待，每次消息收到都新开一个协程处理</li><li><code>GateSession</code>:把SessionId缓存在unit上，当收到消息时直接通过SessionId返回给客户端。<ul><li>Session可能会断开。需要额外管理</li></ul></li></ul></li><li>Actor死锁<ul><li>当两个unit消除处理的mailBox都是队列类型时，当A处理完成后会返回一个rpc消息，当是这时候B又发送了一个消息需要A处理。这时候A在等待B的rpc消息处理，B在等待A的消息处理造成了相互等待。在有队列的maiBox中才会发生。</li></ul></li></ul><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><ul><li><p>ActorHandleHelper</p><ul><li>```c#<br>public static async ETTask HandleIActorRequest(long actorId, IActorRequest iActorRequest)<br>{<br>InstanceIdStruct instanceIdStruct = new(actorId);<br>//这里的进程号不是收到的进程号，而是来源的进程号。<br>//因为要response,需要知道从哪个进程来的,回复到哪里取。<br>int fromProcess = instanceIdStruct.Process;<br>instanceIdStruct.Process = Options.Instance.Process;<br>long realActorId = instanceIdStruct.ToLong();<br><br>Entity entity = Root.Instance.Get(realActorId);<br>if (entity == null)<br>{<br>    IActorResponse response = ActorHelper.CreateResponse(iActorRequest, ErrorCore.ERR_NotFoundActor);<br>    Reply(fromProcess, response);<br>    return;<br>}<br><br>MailBoxComponent mailBoxComponent = entity.GetComponent<mailboxcomponent>();<br>if (mailBoxComponent == null)<br>{<br>    Log.Warning($”actor not found mailbox: {entity.GetType().Name} {realActorId} {iActorRequest}”);<br>    IActorResponse response = ActorHelper.CreateResponse(iActorRequest, ErrorCore.ERR_NotFoundActor);<br>    Reply(fromProcess, response);<br>    return;<br>}<br><br>switch (mailBoxComponent.MailboxType)<br>{<br>    case MailboxType.MessageDispatcher:<br>        {<br>            using (await CoroutineLockComponent.Instance.Wait(CoroutineLockType.Mailbox, realActorId))<br>            {<br>                if (entity.InstanceId != realActorId)<br>                {<br>                    IActorResponse response = ActorHelper.CreateResponse(iActorRequest, ErrorCore.ERR_NotFoundActor);<br>                    Reply(fromProcess, response);<br>                    break;<br>                }<br>                await ActorMessageDispatcherComponent.Instance.Handle(entity, fromProcess, iActorRequest);<br>            }<br>            break;<br>        }<br>    case MailboxType.UnOrderMessageDispatcher:<br>        {<br>            await ActorMessageDispatcherComponent.Instance.Handle(entity, fromProcess, iActorRequest);<br>            break;<br>        }<br>    case MailboxType.GateSession:<br>    default:<br>        throw new Exception($”no mailboxtype: {mailBoxComponent.MailboxType} {iActorRequest}”);<br>}<br>}<figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span> ActorHelper<br><br><span class="hljs-bullet">-</span> ActorMessageDispatcherComponentSystem<br><br><span class="hljs-bullet">-</span> ActorMessageSenderComponentSystem<br><br><span class="hljs-bullet">  -</span> 有个超时的设计，Awake时启动定时器每秒钟检查requestCallback内有哪些消息还没返回。方便检查性能。<br><br><span class="hljs-bullet">-</span> AMActorHandler<br><br><span class="hljs-bullet">-</span> AMActorRpcHandler<br><br><span class="hljs-bullet">-</span> MailBoxComponentSystem<br><br><span class="hljs-bullet">-</span> 为什么用两条Session？<br><br><span class="hljs-bullet">  -</span> <span class="hljs-code">`ActorMessageSenderComponentSystem.Call()`</span>为什么调用两个Session来传递，而不是直接用单个Session的call方法？<br><span class="hljs-bullet">  -</span> ![<span class="hljs-string">image-20230731115309727</span>](<span class="hljs-link">网络游戏架构设计/image-20230731115309727.png</span>)<br><span class="hljs-bullet">  -</span> 如果用call返回，这时候再发消息就会有问题。保证Session的单一职责。<br><br><span class="hljs-section">## 第二十一节 ActorLocation</span><br><br>TODO：这部分有点复杂，客户端用不到先简单看下<br><br>LocationComponent<br><br>对Actor基础上的封装，在某些特定场景使用<br><br><span class="hljs-bullet">-</span> 比如Unit <br><span class="hljs-bullet">-</span> InstanceId不固定<br><span class="hljs-bullet">-</span> 只知道Id，并且想通过Id发消息<br><span class="hljs-bullet">  -</span> InstanceId不固定，Id是固定的<br><br><span class="hljs-section">### 设计思路</span><br><br>ActorLocation的概念就像是一个<span class="hljs-code">`中央管理区`</span>，管理所有人的InstanceId，当Id持有的InstanceId需要变更时需要通知给中央管理区，并且锁住状态。当一个actor需要通知到具体对象时，会派出一个<span class="hljs-code">`高级邮递员`</span>向中央管理区请求InstanceId信息，并进行投递。但是在进行投递的过程中，InstanceId还是有可能会变更，<span class="hljs-code">`高级邮递员`</span>还是会发生投递失败的情况，这时候就会重新执行这个流程。需要注意的是，如果InstanceId一直在变更<span class="hljs-code">`高级邮递员`</span>不可能一直处于投递状态，还是需要给个限定时间。<br><br><span class="hljs-section">### 回执</span><br><br>无论有没有回调都需要有一个回执。<br><br><span class="hljs-bullet">-</span> 有内容的回执<br><span class="hljs-bullet">-</span> 没有内容的回执<br><span class="hljs-bullet">  -</span> 只告诉发送者接收者收到了消息。<br><br><span class="hljs-section">### Location作用</span><br><br><span class="hljs-bullet">-</span> zookeeper<br><span class="hljs-bullet">-</span> 分布式锁服务<br><span class="hljs-bullet">-</span> 存键值对<br><br><span class="hljs-section">## 第二十二节 机器人与测试用例</span><br><br><span class="hljs-section">### 机器人的作用</span><br><br><span class="hljs-bullet">-</span> 功能开发的辅助<br><span class="hljs-bullet">-</span> 单元测试<br><span class="hljs-bullet">-</span> 性能压测<br><span class="hljs-bullet">-</span> 逻辑压测<br><span class="hljs-bullet">-</span> 模拟玩家<br><br><span class="hljs-section">### 共享逻辑代码</span><br><br>放在share层，双端可以共享机器人的逻辑代码。<br><br><span class="hljs-section">#### 宏的处理方式</span><br><br>因为是All in one的设计。逻辑层是动态加载出来的，都是编译出来的dll。直接代码里只加客户端的宏就没用了。<br><br><span class="hljs-section">#### ET的宏处理</span><br><br>在<span class="hljs-code">`Define.cs`</span>文件中统一管理宏逻辑，通过宏定义来设置变量的值。通过变量的值来获取状态。<br><br>在逻辑里定义一堆宏反而更麻烦。<br><br><span class="hljs-section">### 测试用例</span><br><br><span class="hljs-bullet">-</span> 测试驱动<br><span class="hljs-bullet">  -</span> 传统概念，写逻辑先写测试用例，先让测试用例测试功能<br><span class="hljs-bullet">  -</span> 但是在游戏中逻辑变化太快，测试用例很容易被推翻。<br><span class="hljs-bullet">-</span> 函数级单元测试<br><span class="hljs-bullet">-</span> 类级别单元测试<br><span class="hljs-bullet">-</span> 协议级的单元测试<br><span class="hljs-bullet">  -</span> 游戏中的测试用例基本都是面向于协议，因为协议较于稳定。<br><br><span class="hljs-section">### 写测试用例的技巧</span><br><br><span class="hljs-bullet">-</span> 利用协程<br><br><span class="hljs-bullet">  -</span> 用协程，发送协议然后等待协议返回，判断结果。当成同步方法来写。<br><br><span class="hljs-bullet">  -</span> 部分协议不是rpc，这时候需要等待其他协议返回时，使用ObjectWait把没有关系的消息进行代码逻辑上的串行。<br><br><span class="hljs-code">    ```c#</span><br><span class="hljs-code">    namespace ET.Server{</span><br><span class="hljs-code">    //虽然协议响应的场景是Client但是是Server命名空间下，所以编译成程序集时是在Server内。</span><br><span class="hljs-code">        //具体协议Handler</span><br><span class="hljs-code">        [MessageHandler(SceneType.Client)]</span><br><span class="hljs-code">        public class xxxHandler:AMHandler&lt;xxx协议&gt;{</span><br><span class="hljs-code">            protected override async ETTask Run(Session session,xxx协议 message){</span><br><span class="hljs-code">                ObjectWait objectWait = session.clientScene().GetComponent&lt;ObjectWait&gt;();</span><br><span class="hljs-code">                objectWait.Notify(new RobotCase_xxx(){});</span><br><span class="hljs-code">            }</span><br><span class="hljs-code">        }</span><br><span class="hljs-code">        public class RobotCase_xxx:ARobotCase{</span><br><span class="hljs-code">            protected override async ETTask Run(RobotCase robotCase){</span><br><span class="hljs-code">                ObjectWait objectWait = robotScene.GetComponent&lt;ObjectWait&gt;();</span><br><span class="hljs-code">                await objectWait&lt;RobotCase_xxx&gt;();</span><br><span class="hljs-code">            }</span><br><span class="hljs-code">        }</span><br><span class="hljs-code">    }</span><br><span class="hljs-code">    </span><br></code></pre></td></tr></tbody></table></figure></mailboxcomponent></li></ul></li><li><p>利用消息事件回调</p></li><li><p>不要用时间来卡逻辑</p></li></ul><h2 id="第二十三节-AI"><a href="#第二十三节-AI" class="headerlink" title="第二十三节 AI"></a>第二十三节 AI</h2><h3 id="AI的用处"><a href="#AI的用处" class="headerlink" title="AI的用处"></a>AI的用处</h3><ol><li>怪物、NPC等行为</li><li>子弹</li><li>机器人</li><li>托管</li></ol><h3 id="AI常用实现方案"><a href="#AI常用实现方案" class="headerlink" title="AI常用实现方案"></a>AI常用实现方案</h3><ul><li>状态机<ul><li>每两个状态都可能发生转换，复杂度是N的平方</li><li>节点与节点之间耦合会很严重</li></ul></li><li>行为树<ul><li>每个方法都要包装成节点，节点太多</li><li>树太大不好编辑</li><li>牵一发而动全身，一个变量的调整可能会导致顺序的调整</li><li>表达弱，难以阅读，难以重构</li><li>协程的支持比较原始，等待的操作会被包装成节点</li></ul></li><li>深度学习</li></ul><h3 id="AI的本质"><a href="#AI的本质" class="headerlink" title="AI的本质"></a>AI的本质</h3><p>根据当前的状态，执行一个行为。</p><h3 id="ET改进"><a href="#ET改进" class="headerlink" title="ET改进"></a>ET改进</h3><p>直接用代码编写AI</p><p>​复用节点改为复用函数。一个行为由多个函数组成。</p><p>协程化，每个节点是一个协程</p><p>​在行为内隔一段时间进行条件的判定，当条件满足时打断其他的行为，并执行满足条件的行为。</p><p>节点包含条件跟行为</p><p>​把行为进行抽象，而不是把状态进行抽象。</p><h2 id="第二十四节-架构设计细节"><a href="#第二十四节-架构设计细节" class="headerlink" title="第二十四节 架构设计细节"></a>第二十四节 架构设计细节</h2><ul><li>推图游戏<ul><li><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230731195658960.png" alt="image-20230731195658960"></li><li>主要就是房间管理的设计，如果有单人和多人的玩法。双端共享代码带来的优势。<ul><li>多人玩法的代码可以通过服务器请求，房间在服务器上，通过协议驱动view表现。</li><li>单人玩法则可以在本地创建一个Scene当作逻辑层模拟服务器房间，驱动view层。</li></ul></li></ul></li><li>帧同步 状态帧<ul><li><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230731195658960.png" alt="image-20230731200542296"></li><li>逻辑层和表现层分离，逻辑层可以优化成单独一个线程运行</li><li>可以客户端计算服务器做转发，然后多个客户端投票机制判定结果是否正常。</li><li>或者状态同步，客户端发送操作，服务器计算结果并转发</li><li>或者只搞结算服，游戏结束把每一帧结果都发送到结算服，判定结果再进行返回。或者改为仲裁机制，有人投诉再进行结果判定。</li></ul></li><li>mmo slg<ul><li><img src="/2023/03/17/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230731203603381.png" alt="image-20230731203603381"></li><li>逻辑都在服务器，客户端只做表现。</li><li>在登录时，网关会先从player取出数据，在player上挂载一个map，把unit临时挂在这个map上。然后进入游戏场景时，相当于一个传送的机制。可以减少登录时的逻辑。修改登录获取数据的get方法来实现，还可以减少map上的压力。</li><li>一个unit上可能会挂在上百个组件，当创建unit到map时如果一起反序列化上百个组件，退出map时又序列化上百个组件无疑会带来很大的性能负担。而有些组件实际并没有使用到造成性能浪费。<ul><li>ET对需要序列化的组件做了优化，会存在一个专门管理序列化组件的组件，只有在第一次GetComponent时会进行序列化并且进行标记为需要反序列化。</li></ul></li></ul></li></ul><h2 id="第二十五节-分析器"><a href="#第二十五节-分析器" class="headerlink" title="第二十五节 分析器"></a>第二十五节 分析器</h2><p><a href="https://www.yuque.com/u28961999/yms0nt">ET分析器介绍 (yuque.com)</a></p><ul><li><strong>HotfixProjectFieldDeclarationAnalyzer</strong><ul><li>Hotfix程序集中只能携带无状态的代码。如果定义了Const变量在热更新时会产生变量参数的变更，造成代码的不稳定。</li></ul></li><li><strong>ClassDeclarationInHotfixAnalyzer</strong><ul><li>数据结构也不能在Hotfix程序集定义，数据结构的变更也会造成热更新的不稳定性。</li></ul></li><li><strong>EntityMethodDeclarationAnalyzer</strong><ul><li>实体类禁止声明方法。</li><li>EnableMethod开后门可以绕过约束</li></ul></li><li><strong>StaticClassCircularDependencyAnalyzer</strong><ul><li>静态类之间不能相互调用</li><li>静态类之间如果互相调用就会造成依赖</li></ul></li><li><strong>UniqueIdAnalyzer</strong><ul><li>避免定义的const int变量参数重复</li><li>框架定义枚举会有侵入性，上层可能会修改到底层的枚举</li></ul></li><li><strong>EntityDelegateDeclarationAnalyzerEntityDelegateDeclarationAnalyzer</strong><ul><li>避免声明Action，避免回调写法</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>框架篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Manager 框架 ET框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于CallBack</title>
    <link href="/2023/01/31/%E5%85%B3%E4%BA%8ECallBack/"/>
    <url>/2023/01/31/%E5%85%B3%E4%BA%8ECallBack/</url>
    
    <content type="html"><![CDATA[<h1 id="关于CallBack"><a href="#关于CallBack" class="headerlink" title="关于CallBack"></a>关于CallBack</h1><h2 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a><strong>Callback</strong></h2><p>提高cpu利用率不会造成阻塞。做一件事不会等待，等需要时再call back处</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>DMA控制器</li></ul><p>cpu做数据复制时会阻塞cpu，cpu 通知硬件进行复制完成后通知回来。不会阻塞整个cpu</p><ul><li>网络多路复用</li></ul><p>Socket读写过程中，等待数据发送或接收过程cpu的阻塞。等数据过来后再进行通知。</p><ul><li><p>多线程</p></li><li><p>时间</p></li></ul><p>比如等待5秒后执行一个函数，不需要阻塞线程5秒后再执行。</p><h3 id="CallBack历史"><a href="#CallBack历史" class="headerlink" title="CallBack历史"></a>CallBack历史</h3><h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a><strong>函数指针</strong></h4><p>C语言内通过函数指针的方式，在callback 后用指针执行函数，但是不方便同步上下文且类型不安全（可以传递任意指针）</p><h4 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a><strong>函数对象</strong></h4><p>C++通过函数对象的方式，类型安全、构造时传递函数指针、构造时传递上下文、绑定上下文</p><p>将上下文和回调函数封装成一个类（闭包），做到延迟调用。闭包比较繁琐，当需要上下文对象类型不满足已有扩展的闭包支持的类型时就要进行 闭包类型的扩展。</p><h4 id="谷歌的NewCallBack"><a href="#谷歌的NewCallBack" class="headerlink" title="谷歌的NewCallBack"></a><strong>谷歌的NewCallBack</strong></h4><p>上下文只能绑定前面的参数不能绑定后面的参数、返回的是指针（本质是new一个函数对象执行）如果没有调用会造成内存泄漏（解决方案：使用智能指针包裹）</p><h2 id="Callback-Hell（回调地狱）"><a href="#Callback-Hell（回调地狱）" class="headerlink" title="Callback Hell（回调地狱）"></a><strong>Callback Hell（回调地狱）</strong></h2><p>在处理回调时，我们的逻辑会被截成两段，一段是发起callback 一段是响应callback 。在Callback调用Callback的过程中，代码相应会像波浪一样越推越远。</p><p>易出错、难修改。在callback 中难插入。</p><h2 id="async-await-Task"><a href="#async-await-Task" class="headerlink" title="async await Task"></a>async await Task</h2><p>把int Func() (回调)转成await Func()</p><p>在C#中通过转换工具TaskCompletionSource <t>转换</t></p><h2 id="ETTask"><a href="#ETTask" class="headerlink" title="ETTask"></a><strong>ETTask</strong></h2><ul><li>简化的Task 生成代码简单</li></ul><p>(.Net Reflector 可以.net stand 2.0反编译)</p><ul><li>解决了GC问题</li></ul><p>Task 使用TaskCompletionSource工具类转换成await Func 时会new 工具类</p><p>ETTask在确保安全的时候使用池消除gc，Set Result (true)时回收</p><p>TaskCompletionSource和Task合并</p><ul><li>不提供多线程处理</li></ul><h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><p>ET提供<code>WaitAll</code> <code>WaitAny</code>，类比线程同步barrier</p><p>当多个回调同时发起，等所有回调执行完再往下执行</p><p>场景：</p><ol><li>切换场景资源,不需要一个个加载，可以同时加载，等所有加载完再往下执行。</li><li>机器人登录50个，不需要一个个登录。</li></ol><h3 id="协程锁"><a href="#协程锁" class="headerlink" title="协程锁"></a>协程锁</h3><p>应用场景：</p><ol><li>两个逻辑同时加载同一个ab包</li><li>服务器玩家异步加载处理到一半，这时收到下线消息。</li></ol><p>实现：</p><ul><li>CoroutineComponent实现思路：<ol><li>同一种锁，同一个key放入同一个队列</li><li>一个协程执行完后从自己队列中取出下一个执行</li></ol></li></ul><p>问题:</p><p>协程执行取出下一个执行时，如果消息处理不过来会产生队列内的处理逻辑的堆积。队列很多时，堆栈的层级也会很多(因为逐层调用)，导致堆栈爆掉。</p><p>改进：</p><p>取出下一个执行时，不直接执行而是放入update中执行。</p><p>问题：</p><p>协程锁死锁情况，await互相等，永远等不到</p><p>改进：</p><p>ET协程锁添加时间限制，时间到了解锁(超时机制)。</p>]]></content>
    
    
    <categories>
      
      <category>框架篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CallBack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ManagerOfManager</title>
    <link href="/2023/01/17/ManagerOfManager/"/>
    <url>/2023/01/17/ManagerOfManager/</url>
    
    <content type="html"><![CDATA[<h1 id="框架搭建随笔"><a href="#框架搭建随笔" class="headerlink" title="框架搭建随笔"></a>框架搭建随笔</h1><h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><p>使⽤版本号命名的⽂件格式为: Framework_vX.Y.Z</p><ul><li>X 是主版本号，⽤于不向前兼容的更新。</li><li>Y 是中间版本，⽤于可向前兼容的功能性更新。</li><li>Z 是⼩版本号，⽤于功能完善和 bug 修复的更新</li></ul><p>⼀般都是从 v0.1.1 这个版本开始发布的，但是这个版本呢叫做 mvp 版本，也就是最⼩可验证版本。后续发布版本都需要向前兼容</p><h2 id="Obsolete-标签"><a href="#Obsolete-标签" class="headerlink" title="Obsolete 标签"></a>Obsolete 标签</h2><p>使用Obsolete标签标记方法已弃用，使用其他方法。</p><p>添加弃用标签后会报警报提醒</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">Obsolete(<span class="hljs-string">"方法已过时，请使用xx方法"</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OpenInFolder</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> folderPath</span>)</span><br>{<br>Application.OpenURL(<span class="hljs-string">"file://"</span> + folderPath);<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="Partial关键字"><a href="#Partial关键字" class="headerlink" title="Partial关键字"></a>Partial关键字</h2><p>当类后续可能增长的时候使用，各个部分类需要用相同的访问权限。而且每个部分类都需要加<code>partial</code>关键字。</p><h2 id="方法结构重复-解决方案"><a href="#方法结构重复-解决方案" class="headerlink" title="方法结构重复 解决方案"></a>方法结构重复 解决方案</h2><p>当一个方法的的参数类型不同时，如果有共同父类可以将类型设置为父类，子类可以进行使用</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetRandomValueFrom</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] values</span>)</span><br>{<br>    <span class="hljs-keyword">return</span> values[Random.Range(<span class="hljs-number">0</span>, values.Length)];<br>}<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">float</span> <span class="hljs-title">GetRandomValueFrom</span>(<span class="hljs-params"><span class="hljs-built_in">float</span>[] values</span>)</span><br>{<br>    <span class="hljs-keyword">return</span> values[Random.Range(<span class="hljs-number">0</span>, values.Length)];<br>}<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">GetRandomValueFrom</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] values</span>)</span><br>{<br>    <span class="hljs-keyword">return</span> values[Random.Range(<span class="hljs-number">0</span>, values.Length)];<br>}<br></code></pre></td></tr></tbody></table></figure><p>可以将类型设置为object</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">object</span> <span class="hljs-title">GetRandomValueFrom</span>(<span class="hljs-params"><span class="hljs-built_in">object</span>[] values</span>)</span><br>{<br>    <span class="hljs-keyword">return</span> values[Random.Range(<span class="hljs-number">0</span>, values.Length)];<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="泛型实现结构复用"><a href="#泛型实现结构复用" class="headerlink" title="泛型实现结构复用"></a>泛型实现结构复用</h3><p>使用泛型实现方法复用</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">GetRandomValueFrom</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">params</span> T[] values</span>)</span><br>{<br>    <span class="hljs-keyword">return</span> values[Random.Range(<span class="hljs-number">0</span>, values.Length)];<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="params关键字"><a href="#params关键字" class="headerlink" title="params关键字"></a>params关键字</h3><p>修饰形参<strong>必须为一维数组</strong>，并且方法声明只能有一个<code>params</code>，如果不是一维数组编译器将报错。</p><p>使用 <code>params</code> 参数调用方法时，可以传入：</p><ul><li><p>数组元素类型的参数的逗号分隔列表。</p></li><li><p>指定类型的参数的数组。</p></li><li><p>无参数。 如果未发送任何参数，则 <code>params</code> 列表的长度为零。</p></li></ul><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//数组元素类型的参数的逗号分隔列表</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Get</span>()</span><br>{<br>GetRandomValueFrom&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>}<br><span class="hljs-comment">//无参数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Get</span>()</span><br>{<br>GetRandomValueFrom&lt;<span class="hljs-built_in">int</span>&gt;();<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="消息机制"><a href="#消息机制" class="headerlink" title="消息机制"></a>消息机制</h2><h3 id="Unity内置消息机制"><a href="#Unity内置消息机制" class="headerlink" title="Unity内置消息机制"></a>Unity内置消息机制</h3><p>方法调用使用字符串，可能用到反射，尽量不用。</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">this</span>.SendMessageUpward(<span class="hljs-string">"MethedName"</span>);<br></code></pre></td></tr></tbody></table></figure><h3 id="通过委托通知"><a href="#通过委托通知" class="headerlink" title="通过委托通知"></a>通过委托通知</h3><p>A注册特定方法，B声明委托。当B想调用A的方法时，通过委托通知。</p><h3 id="消息机制提供的功能"><a href="#消息机制提供的功能" class="headerlink" title="消息机制提供的功能"></a>消息机制提供的功能</h3><ul><li>注册事件</li><li>注销事件</li><li>发送事件</li></ul><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">MsgDispatcher.Register(<span class="hljs-string">"消息名"</span>,(obj)=&gt;{ <span class="hljs-comment">/* 处理消息 */</span> });<br>MsgDispatcher.Send(<span class="hljs-string">"消息名"</span>,<span class="hljs-string">"消息内容"</span>);<br>MsgDispatcher.UnRegister(<span class="hljs-string">"消息名"</span>);<br></code></pre></td></tr></tbody></table></figure><h2 id="new-Class的优化"><a href="#new-Class的优化" class="headerlink" title="new Class的优化"></a>new Class的优化</h2><p>当一个class作为存储数据时，为了减少new的次数可以做一个对象池进行存储</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MsgRecord</span><br>{<br>    <span class="hljs-comment">//私有构造函数后，class无法被new</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">MsgRecord</span>()</span> { }<br>    <span class="hljs-comment">//对象池</span><br>    <span class="hljs-keyword">static</span> Stack&lt;MsgRecord&gt; mMsgRecordPool = <span class="hljs-keyword">new</span> Stack&lt;MsgRecord&gt;();<br>    <span class="hljs-comment">//创建对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MsgRecord <span class="hljs-title">Allocate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> msgName, Action&lt;<span class="hljs-built_in">object</span>&gt; onMsgReceived</span>)</span><br>    {<br>        MsgRecord msgRecord;<br>        <span class="hljs-keyword">if</span> (mMsgRecordPool.Count &gt; <span class="hljs-number">0</span>)<br>        {<br>            msgRecord = mMsgRecordPool.Pop();<br><br>        }<br>        <span class="hljs-keyword">else</span><br>        {<br>            msgRecord = <span class="hljs-keyword">new</span> MsgRecord { };<br>        }<br>        msgRecord.Name = msgName;<br>        msgRecord.OnMsgReceived = onMsgReceived;<br>        <span class="hljs-keyword">return</span> msgRecord;<br>    }<br>    <span class="hljs-comment">//移除对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Recycle</span>()</span><br>    {<br>        Name = <span class="hljs-literal">null</span>;<br>        OnMsgReceived = <span class="hljs-literal">null</span>;<br>        mMsgRecordPool.Push(<span class="hljs-keyword">this</span>);<br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name;<br>    <span class="hljs-keyword">public</span> Action&lt;<span class="hljs-built_in">object</span>&gt; OnMsgReceived;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="框架的定义"><a href="#框架的定义" class="headerlink" title="框架的定义"></a>框架的定义</h2><p><code>框架</code>：提供⼀个架构（⽂件结构、约定等等），你必须遵守它，只要你遵守，那剩下的就 全部处理通⽤需求了。 </p><p><strong>好架构=好规则</strong></p><h2 id="库的定义"><a href="#库的定义" class="headerlink" title="库的定义"></a>库的定义</h2><p>库，插到既有 架构上，补充特定功能。</p><h2 id="Unity常用架构"><a href="#Unity常用架构" class="headerlink" title="Unity常用架构"></a>Unity常用架构</h2><h3 id="1-EmptyGo"><a href="#1-EmptyGo" class="headerlink" title="1.EmptyGo"></a>1.EmptyGo</h3><p> 在 Hierarchy 上创建⼀个空的 GameObject,然后挂上所有与 GameObject ⽆关的逻辑控制的脚 本。使⽤GameObject.Find() 访问对象数据。 </p><p>缺点:逻辑代码散落在各处,不适合⼤型项⽬。 </p><h3 id="2-Simple-GameManager"><a href="#2-Simple-GameManager" class="headerlink" title="2.Simple GameManager"></a>2.Simple GameManager</h3><p>所有与 GameObject ⽆关的逻辑都放在⼀个单例中。 </p><p>缺点:单⼀⽂件过于庞⼤ </p><h3 id="3-Manager-Of-Managers"><a href="#3-Manager-Of-Managers" class="headerlink" title="3.Manager Of Managers"></a>3.Manager Of Managers</h3><p>将不同的功能单独管理。</p><p>如下:</p><ul><li>MainManager: 作为⼊⼝管理器。</li><li>EventManager: 消息管理。 </li><li>GUIManager: 图形视图管理。 </li><li>AudioManager: ⾳效管理。</li><li>PoolManager: GameObject管理（减少动态开辟内存消耗,减少GC)。  存储各类型的spawnPool，spawnpool存储各prefabPool。删除和添加时如果不需要立即操作，可以分步进行添加删除。(最基本拥有) </li><li>LevelManager: 关卡管理。 (最基本拥有)</li><li>GameManager: 游戏管理。</li><li>SaveManager: 配置&amp;存储管理。(最基本拥有)</li><li><code>Easy save2</code>插件使用二进制操作 ，对数据加密</li><li>MenuManager 菜单管理。</li></ul><h3 id="4-将-View-和-Model-之间增加⼀个媒介层"><a href="#4-将-View-和-Model-之间增加⼀个媒介层" class="headerlink" title="4.将 View 和 Model 之间增加⼀个媒介层"></a>4.将 View 和 Model 之间增加⼀个媒介层</h3><p>UI和逻辑分离</p><p> MVCS:</p><p>​StrangeIOC 插件。</p><p>​<code>IBinder.Bind&lt;Key&gt;().To&lt;Value&gt;();</code></p><p>​<code>IBinder.Bind&lt;Key&gt;().To&lt;Value&gt;().ToName(name);</code>当key和value都相同时，根据name区分</p><p>​通过event和listener来触发按键的操作</p><p>​机制依赖于C#的Reflection(反射)，效率慢，模式、思想和理念可借鉴</p><p>MVVM:</p><p>​uFrame 插件</p><h3 id="5-ECS-Entity-Component-Based-System"><a href="#5-ECS-Entity-Component-Based-System" class="headerlink" title="5.ECS (Entity Component Based System)"></a>5.ECS (Entity Component Based System)</h3><p> Unity 是基于 ECS,⽐较适合 GamePlay 模块使⽤ </p><h2 id="Manager-Of-Managers架构模式"><a href="#Manager-Of-Managers架构模式" class="headerlink" title="Manager Of Managers架构模式"></a>Manager Of Managers架构模式</h2><h3 id="LevelManager"><a href="#LevelManager" class="headerlink" title="LevelManager"></a>LevelManager</h3><p>Unity里的<code>LoadScene方法</code>只能传递scene名字或index。改名或者变换顺序时变得非常麻烦。通过配置表配置，读取level时按顺序读取配置表即可。</p><h3 id="PoolManager"><a href="#PoolManager" class="headerlink" title="PoolManager"></a>PoolManager</h3><p>两个经典操作，Spawn、Despawn</p><h4 id="Spawn"><a href="#Spawn" class="headerlink" title="Spawn"></a>Spawn</h4><p>在创建新资源时，对象池有则直接调用，没有则需要初始化。</p><h4 id="DeSpawn"><a href="#DeSpawn" class="headerlink" title="DeSpawn"></a>DeSpawn</h4><p>当池子容量达到指定上限时，将第一个第二个按照队列顺序进行销毁，先进先出。</p><h4 id="对象池优化"><a href="#对象池优化" class="headerlink" title="对象池优化"></a>对象池优化</h4><p>一个PoolManager下有若干个SpawnPool来管理一类的物体。比如NPC一个Pool，物品一个Pool。一个SpawnPool有若干个PrefabPool，一个PrefabPool只能存储一个Prefab，可以进行单个Prefab的加载和卸载。</p><p>对于每一个PrefabPool可以管理两个List，一个是ActivetedList，一个是DeactivateList，并管理所有Prefab的加载和卸载过程。</p><p>在删除时对数量要严格控制，一帧内不能同时删除太多物体，否则会触发GC。需要PoolManager管理时能够缓释，一帧只删除少量对象。</p><h3 id="SaveManager"><a href="#SaveManager" class="headerlink" title="SaveManager"></a>SaveManager</h3><p><code>Easy Save2</code>二进制进行Load和Save，与Unity很好的结合，Unity类型基本都能Serialized。比Json的一些方案快。</p><h3 id="MainManager"><a href="#MainManager" class="headerlink" title="MainManager"></a>MainManager</h3><p>入口管理器，如资源加载流程、第三方SDK启动流程、热更新检测，都是在入口处完成的。</p><p>在开发阶段不同流程会有不同的log或调试需要进行阶段划分进行屏蔽。</p><p>职责：</p><ul><li>管理多个入口</li><li>负责游戏的启动流程。</li></ul><h4 id="阶段划分"><a href="#阶段划分" class="headerlink" title="阶段划分"></a>阶段划分</h4><ol><li>开发阶段:不断编码-&gt;验证结果-&gt;编码-&gt;验证结果-&gt;….</li><li>出包/真机阶段：跑完整流程，QA测试</li><li>发布阶段：上线</li></ol><p>对应的枚举</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> EnvironmentMode{<br>    Developing,<br>    QA,<br>    Release<br>}<br></code></pre></td></tr></tbody></table></figure><p>根据枚举执行抽象方法</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MainManager</span> : <span class="hljs-title">MonoBehaviour</span><br>{<br>    <span class="hljs-keyword">public</span> EnvironmentMode mode;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> EnvironmentMode mSharedMode;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> mModeSetted = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    {<br>        <span class="hljs-comment">//不同场景不同mode时只会有一个唯一mode</span><br>        <span class="hljs-keyword">if</span> (!mModeSetted)<br>        {<br>            mSharedMode = mode;<br>            mModeSetted = <span class="hljs-literal">true</span>;<br>        }<br>        <span class="hljs-keyword">switch</span> (mSharedMode)<br>        {<br>            <span class="hljs-keyword">case</span> EnvironmentMode.Developing:<br>                LaunchInDevelopingMode();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> EnvironmentMode.Test:<br>                LaunchInTestMode();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> EnvironmentMode.Production:<br>                LaunchInProductionMode();<br>                <span class="hljs-keyword">break</span>;<br>        }<br>    }<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LaunchInDevelopingMode</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LaunchInTestMode</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LaunchInProductionMode</span>()</span>;<br><br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="GuiManager"><a href="#GuiManager" class="headerlink" title="GuiManager"></a>GuiManager</h3><h4 id="加载卸载"><a href="#加载卸载" class="headerlink" title="加载卸载"></a>加载卸载</h4><p>通过字典管理，加载和卸载通过存储Panel名字为key，GameObject为Value</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Dictionary&lt;<span class="hljs-built_in">string</span>, GameObject&gt; mPanelDict = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, GameObject&gt;();<br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UnLoadPanel</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> PanelName</span>)</span><br>       {<br>           <span class="hljs-keyword">if</span> (mPanelDict.ContainsKey(PanelName))<br>           {<br>               <span class="hljs-keyword">var</span> gObj = mPanelDict[PanelName];<br>               Destroy(gObj);<br>           }<br>       }<br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GameObject <span class="hljs-title">LoadPanel</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> PanelName, UILayer uILayer</span>)</span><br>       {<br>           <span class="hljs-keyword">var</span> PanelPrefab = Resources.Load&lt;GameObject&gt;(PanelName);<br>           <span class="hljs-keyword">var</span> PanelObj = Instantiate(PanelPrefab, UIRoot.transform);<br>           PanelObj.name = PanelName;<br>           mPanelDict.Add(PanelName, PanelObj);<br><br>           <span class="hljs-keyword">switch</span> (uILayer) <br>           {<br>               <span class="hljs-keyword">case</span> UILayer.Bg:<br>                   PanelObj.transform.SetParent(UIRoot.transform.Find(<span class="hljs-string">"Bg"</span>));<br>                   <span class="hljs-keyword">break</span>;<br>               <span class="hljs-keyword">case</span> UILayer.Common:<br>                   PanelObj.transform.SetParent(UIRoot.transform.Find(<span class="hljs-string">"Common"</span>));<br>                   <span class="hljs-keyword">break</span>;<br>               <span class="hljs-keyword">case</span> UILayer.Top:<br>                   PanelObj.transform.SetParent(UIRoot.transform.Find(<span class="hljs-string">"Top"</span>));<br>                   <span class="hljs-keyword">break</span>;<br>           }<br>           <span class="hljs-keyword">return</span> PanelObj;<br>       }<br></code></pre></td></tr></tbody></table></figure><h4 id="层级管理"><a href="#层级管理" class="headerlink" title="层级管理"></a>层级管理</h4><p>通过枚举分级,在Scene中创建相对应的GameObject来管理对应Panel的层级关系</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> UILayer<br>{<br>    Bg,<br>    Common,<br>    Top<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="/2023/01/17/ManagerOfManager/1649575865089.png" alt="1649575865089"></p><p>在加载时加载到对应层级的GameObject中</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GameObject <span class="hljs-title">LoadPanel</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> panelName, UILayer uILayer</span>)</span><br>{<br>    <span class="hljs-keyword">var</span> canvasObj = GameObject.Find(<span class="hljs-string">"Canvas"</span>);<br><br>    <span class="hljs-keyword">var</span> PanelPrefab = Resources.Load&lt;GameObject&gt;(panelName);<br>    <span class="hljs-keyword">var</span> PanelObj = Instantiate(PanelPrefab, canvasObj.transform);<br>    <br>    <span class="hljs-keyword">switch</span> (uILayer)<br>    {<br>        <span class="hljs-keyword">case</span> UILayer.Bg: PanelObj.transform.SetParent(canvasObj.transform.Find(<span class="hljs-string">"Bg"</span>));<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> UILayer.Common:<br> PanelObj.transform.SetParent(canvasObj.transform.Find(<span class="hljs-string">"Common"</span>));<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> UILayer.Top:     PanelObj.transform.SetParent(canvasObj.transform.Find(<span class="hljs-string">"Top"</span>));<br>            <span class="hljs-keyword">break</span>;<br>    }<br>    <span class="hljs-keyword">return</span> PanelObj;<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="UIRoot"><a href="#UIRoot" class="headerlink" title="UIRoot"></a>UIRoot</h4><p>将前面所描述的canvas结构，制作为Prefab，名字为UIRoot，管理所有的UIPanel。</p><p>在GUIManager中存储一份，在加载Panel时使用。</p><p><img src="/2023/01/17/ManagerOfManager/1649577942704.png" alt="1649577942704"></p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> GameObject mPrivateUIRoot;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GameObject UIRoot<br>{<br>    <span class="hljs-keyword">get</span><br>    {<br>        <span class="hljs-comment">//懒加载</span><br>        <span class="hljs-keyword">if</span> (mPrivateUIRoot == <span class="hljs-literal">null</span>)<br>        {<br>            mPrivateUIRoot = GameObject.Instantiate(Resources.Load&lt;GameObject&gt;(<span class="hljs-string">"UIRoot"</span>));<br>        }<br>        mPrivateUIRoot.name = <span class="hljs-string">"UIRoot"</span>;<br>        <span class="hljs-keyword">return</span> mPrivateUIRoot;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="AudioManager"><a href="#AudioManager" class="headerlink" title="AudioManager"></a>AudioManager</h3><h4 id="播放音效"><a href="#播放音效" class="headerlink" title="播放音效"></a>播放音效</h4><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span>音效 <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> soundName</span>)</span><br>{<br>    CheckAudioListener();<br><br>    <span class="hljs-keyword">var</span> doorClip = Resources.Load&lt;AudioClip&gt;(soundName);<br>    <span class="hljs-keyword">var</span> audioSource = gameObject.AddComponent&lt;AudioSource&gt;();<br><br>    audioSource.clip = doorClip;<br>    audioSource.Play();<br>}<br></code></pre></td></tr></tbody></table></figure><p>播放背景音</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span>背景音 <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlayMusic</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> soundName, <span class="hljs-built_in">bool</span> IsLoop = <span class="hljs-literal">true</span></span>)</span><br>{<br>    CheckAudioListener();<br>    <span class="hljs-keyword">if</span> (mMusicSource == <span class="hljs-literal">null</span>)<br>    {<br>        mMusicSource = gameObject.AddComponent&lt;AudioSource&gt;();<br>    }<br>    <span class="hljs-keyword">var</span> doorClip = Resources.Load&lt;AudioClip&gt;(soundName);<br>    <span class="hljs-keyword">var</span> audioSource = gameObject.AddComponent&lt;AudioSource&gt;();<br><br>    audioSource.loop = IsLoop;<br>    audioSource.clip = doorClip;<br>    audioSource.Play();<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="PoolManager-1"><a href="#PoolManager-1" class="headerlink" title="PoolManager"></a>PoolManager</h3><h4 id="对象池解决的问题"><a href="#对象池解决的问题" class="headerlink" title="对象池解决的问题"></a>对象池解决的问题</h4><ol><li>减少new时候寻址造成的消耗，该消耗的原因是内存碎片。</li><li>减少Object.Instantiate时内部进行序列化和反序列化而造成的CPU消耗。</li></ol><h4 id="简易对象池"><a href="#简易对象池" class="headerlink" title="简易对象池"></a>简易对象池</h4><p>获取的操作一般为Allocate(分配)，放入为Recycle(回收)。也有叫Spawn和Despawn</p><h5 id="定义池接口"><a href="#定义池接口" class="headerlink" title="定义池接口"></a>定义池接口</h5><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IPool</span>&lt;<span class="hljs-title">T</span>&gt;<br>{<br>    <span class="hljs-function">T <span class="hljs-title">Allocate</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">Recycle</span>(<span class="hljs-params">T obj</span>)</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>在Allocate和Recycle时不在意对象顺序，只需要位置连续，使用stack容器来存储对象。</p><h5 id="使用一个简单工厂接口来创建对象。"><a href="#使用一个简单工厂接口来创建对象。" class="headerlink" title="使用一个简单工厂接口来创建对象。"></a>使用一个简单工厂接口来创建对象。</h5><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IObjectFactory</span>&lt;<span class="hljs-title">T</span>&gt;<br>{<br>    <span class="hljs-function">T <span class="hljs-title">Create</span>()</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h5 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h5><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Pool</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">IPool</span>&lt;<span class="hljs-title">T</span>&gt;<br>{<br>    <span class="hljs-keyword">protected</span> Stack&lt;T&gt; mCachedStack = <span class="hljs-keyword">new</span> Stack&lt;T&gt;();<br>    <span class="hljs-keyword">protected</span> IObjectFactory&lt;T&gt; mFactory;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">int</span> MaxNum = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> curCount<br>    {<br>        <span class="hljs-keyword">get</span> { <span class="hljs-keyword">return</span> mCachedStack.Count; }<br>    }<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> T <span class="hljs-title">Allocate</span>()</span><br>    {<br>        <span class="hljs-keyword">if</span> (mCachedStack.Count == <span class="hljs-number">0</span>)<br>        {<br>            <span class="hljs-keyword">return</span> mFactory.Create();<br>        }<br>        <span class="hljs-keyword">return</span> mCachedStack.Pop();<br>    }<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Recycle</span>(<span class="hljs-params">T obj</span>)</span>;<br>    <span class="hljs-comment">//public virtual bool Recycle(T obj)</span><br>    <span class="hljs-comment">//{</span><br>    <span class="hljs-comment">//    if (mCachedStack.Count &gt;= MaxNum)</span><br>    <span class="hljs-comment">//    {</span><br>    <span class="hljs-comment">//        return false;</span><br>    <span class="hljs-comment">//    }</span><br>    <span class="hljs-comment">//    mCachedStack.Push(obj);</span><br>    <span class="hljs-comment">//    return true;</span><br>    <span class="hljs-comment">//}</span><br>}<br></code></pre></td></tr></tbody></table></figure><h5 id="基于工厂接口的简易工厂"><a href="#基于工厂接口的简易工厂" class="headerlink" title="基于工厂接口的简易工厂"></a>基于工厂接口的简易工厂</h5><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 基于工厂接口的简易工厂</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;typeparam name="T"&gt;</span><span class="hljs-doctag">&lt;/typeparam&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CustomObjectFactroy</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">IObjectFactory</span>&lt;<span class="hljs-title">T</span>&gt;<br>{<br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 使用委托设置类内部信息</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-keyword">private</span> Func&lt;T&gt; mFactoryMethod;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomObjectFactroy</span>(<span class="hljs-params">Func&lt;T&gt; factoryMethod</span>)</span><br>    {<br>        mFactoryMethod = factoryMethod;<br>    }<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">Create</span>()</span><br>    {<br>        <span class="hljs-keyword">return</span> mFactoryMethod();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h5 id="包含创建方法的简易对象池"><a href="#包含创建方法的简易对象池" class="headerlink" title="包含创建方法的简易对象池"></a>包含创建方法的简易对象池</h5><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 简易对象池</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;typeparam name="T"&gt;</span><span class="hljs-doctag">&lt;/typeparam&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SimpleObjectPool</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">Pool</span>&lt;<span class="hljs-title">T</span>&gt;<br>{<br>    <span class="hljs-comment">//重置方法</span><br>    Action&lt;T&gt; mResetMethod;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SimpleObjectPool</span>(<span class="hljs-params">Func&lt;T&gt; factoryMethod, Action&lt;T&gt; ResetMethod = <span class="hljs-literal">null</span>, <span class="hljs-built_in">int</span> initCount = <span class="hljs-number">0</span></span>)</span><br>    {<br>        mFactory = <span class="hljs-keyword">new</span> CustomObjectFactroy&lt;T&gt;(factoryMethod);<br>        mResetMethod = ResetMethod;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; initCount; i++)<br>        {<br>            mCachedStack.Push(mFactory.Create());<br>        }<br>    }<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Recycle</span>(<span class="hljs-params">T obj</span>)</span><br>    {<br>        <span class="hljs-keyword">if</span> (mResetMethod != <span class="hljs-literal">null</span>)<br>        {<br>            mResetMethod(obj);<br>        }<br>        mCachedStack.Push(obj);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h4><p>设计一个比较复杂的模块结构时,可以先设计一个接口(规范)。描述内容有什么</p><p><img src="/2023/01/17/ManagerOfManager/1649780552285.png" alt="1649780552285"></p><p>在mFractroy.Create和Recycle(回收)时，更偏向于自定义的操作 </p><h3 id="LevelManager-1"><a href="#LevelManager-1" class="headerlink" title="LevelManager"></a>LevelManager</h3><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LevelManager</span> : <span class="hljs-title">MonoBehaviour</span><br>{<br>    <span class="hljs-comment">//可换成配置表</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;<span class="hljs-built_in">string</span>&gt; mLevelNames;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> Index { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Init</span>(<span class="hljs-params">List&lt;<span class="hljs-built_in">string</span>&gt; levelNames</span>)</span><br>    {<br>        mLevelNames = levelNames;<br>        Index = <span class="hljs-number">0</span>;<br>    }<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LoadCurrent</span>()</span><br>    {<br>        SceneManager.LoadScene(mLevelNames[Index]);<br>    }<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LoadNext</span>()</span><br>    {<br>        Index++;<br>        <span class="hljs-keyword">if</span> (Index &gt;= mLevelNames.Count)<br>        {<br>            Index = <span class="hljs-number">0</span>;<br>        }<br>        SceneManager.LoadScene(mLevelNames[Index]);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>Probject内-&gt;右键-&gt;Create-&gt;Testing</p><p>创建相对应的c#文件(test模板)<br>在Test Runner 界面内可以看到所有的测试脚本和对应的方法</p><p>类似于自己编写测试用例进行测试</p><p><code>Assert.AreEqual</code>叫做断言，在开发大项目时非常有用的工具。测试通不通过取决于断言通不通过。</p>]]></content>
    
    
    <categories>
      
      <category>框架篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Manager 框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏资源管理</title>
    <link href="/2023/01/16/%E6%B8%B8%E6%88%8F%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    <url>/2023/01/16/%E6%B8%B8%E6%88%8F%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="游戏资源管理"><a href="#游戏资源管理" class="headerlink" title="游戏资源管理"></a>游戏资源管理</h1><p>游戏运行就是一个接一个资源的展示，如何管理好这些展示的资源让游戏能够流畅运行在开发中非常重要。需要在合理的地方调用、加载资源，资源空闲时对其进行卸载以减少内存占用。当内存超出预算可能导致游戏闪退，所以对资源的管理实际就是对内存的优化！</p><p>本文争取一文搞懂资源管理。PS：可能和一个视频学完c++差不多(一个视频一个多月)</p><p>TODOLIST：</p><ul><li><input disabled="" type="checkbox"> 分包策略</li><li><input disabled="" type="checkbox"> 依赖处理</li><li><input disabled="" type="checkbox"> AssetBundle详细</li><li><input disabled="" type="checkbox"> 热更<ul><li><input disabled="" type="checkbox"> 断点续传</li><li><input disabled="" type="checkbox"> 代码热更新/热重载<ul><li><input disabled="" type="checkbox"> Lua重新将函数指针赋值的策略</li><li><input disabled="" type="checkbox"> HybridCLR</li></ul></li></ul></li><li><input disabled="" type="checkbox"> 资源包和资源区分开</li><li><input disabled="" type="checkbox"> 一些资源策略<ul><li><input disabled="" type="checkbox"> 整包只有基础内容，后续章节热更的形式(大资源情况)</li></ul></li><li><input disabled="" type="checkbox"> YooAsset扩展篇</li></ul><h2 id="资源管理主要的需求有哪些？"><a href="#资源管理主要的需求有哪些？" class="headerlink" title="资源管理主要的需求有哪些？"></a>资源管理主要的需求有哪些？</h2><ul><li>为开发与正式版本提供资源的加载和卸载</li><li>支持远程更新资源</li><li>做好版本、平台、渠道的资源管理</li><li>内存优化</li></ul><h2 id="Unity中的两种加载方式"><a href="#Unity中的两种加载方式" class="headerlink" title="Unity中的两种加载方式"></a>Unity中的两种加载方式</h2><h3 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h3><ul><li>资源必选放在Resources文件夹下；有容量上限(大概是2G)；重复加载和重复卸载操作，Unity做了容错处理不会报错。不支持热更，只能打整包</li><li>适合放游戏的启动逻辑需要的资源</li><li>可能会延长游戏启动时间</li></ul><h3 id="AssetBundle"><a href="#AssetBundle" class="headerlink" title="AssetBundle"></a>AssetBundle</h3><ul><li>可以理解成Unity内的资源压缩包，有不同的压缩方式，解压速度和包体大小也不同(LZMA 和 LZ4)。</li><li>适合做热更，以减少包体的初始大小。</li><li>已加载的资源不允许重复加载，会报错。而使用AssetDatabase则不需要考虑。需要使用引用计数。</li></ul><p>这里还有一些开源的资源管理系统，如YooAsset。</p><h2 id="同步加载与异步加载"><a href="#同步加载与异步加载" class="headerlink" title="同步加载与异步加载"></a>同步加载与异步加载</h2><h3 id="同步加载"><a href="#同步加载" class="headerlink" title="同步加载"></a>同步加载</h3><p>同步加载在加载资源时，会阻塞线程。等加载逻辑完成后才继续执行后续逻辑（图灵机）</p><h3 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h3><p>同步加载在加载较大资源时阻塞明显，造成卡顿。因为Unity中所有的渲染都是放在主线程中的，所以主线程阻塞非常致命不能进行任何玩家操作。</p><p>所以需要使用另外一种加载方式对较大资源进行加载。异步加载使用协程/线程进行加载逻辑，等资源加载完毕后触发资源加载后的callback。</p><p>在一些资源的加载会影响到游戏的展示时，可以在需要之前对资源进行预先加载，保证流程能够顺利进行。</p><h4 id="异步加载的三种状态"><a href="#异步加载的三种状态" class="headerlink" title="异步加载的三种状态"></a>异步加载的三种状态</h4><p>异步加载的逻辑由于执行完成的时间不确定，可能会导致其他逻辑的冲突。所以我们给异步加载按照逻辑划分状态，好让其他逻辑能够做区分，不同状态下处理相应的操作。</p><ul><li><p>未加载</p><p>异步加载还没开始时可能需要准备的事情，比如资源包不在本地需要下载、解密、解压等等。</p></li><li><p>加载中</p><p>资源开始加载后，其他业务逻辑也加载了相同资源时，可以判断这个资源的状态。正在加载则不再进行加载前的准备操作，并把加载后的callback注册进去。</p></li><li><p>已加载</p><p>主要为加载后触发相应callback。</p></li></ul><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> LoaderState<br>  {<br>      NONE,           <span class="hljs-comment">// 默认</span><br>      LOADING,        <span class="hljs-comment">// 加载中</span><br>      FINISHED,       <span class="hljs-comment">// 完成</span><br>  }<br></code></pre></td></tr></tbody></table></figure><h4 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h4><p>玩家在进入一个场景后，假设资源预加载需要10s，玩家却在未加载完资源的过程中退出场景。这时候就会引发资源状态的问题。</p><h2 id="资源缓存池"><a href="#资源缓存池" class="headerlink" title="资源缓存池"></a>资源缓存池</h2><p>资源缓存池为统一存储和调用资源的地方。在加载资源后统一存入池子中，卸载时则将其从池子中删除。</p><p>加载时先判断池子中是否存在此资源包，如果已经加载过了直接则直接使用，未加载再进行加载逻辑。</p><p>以下内容主要以AssetBundle举例</p><figure class="highlight cc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AssetBundlePool</span>{<br><span class="hljs-keyword">private</span> Dictionary&lt;string,AssetBundleInfo&gt; m_LoadAssetBundle = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Dictionary</span>&lt;string,AssetBundleInfo&gt;();<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>引用技术的应用范围很广，很多引擎、框架、插件的底层都离不开引用计数。</p><p>简单思想：被引用+1，不被引用时-1，当为0时触发清空逻辑。</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IRefCounter</span><br>{<br>    <span class="hljs-built_in">int</span> RefCount { <span class="hljs-keyword">get</span>; }<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Retain</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Release</span>()</span>;<br>}<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SimpleRC</span> : <span class="hljs-title">IRefCounter</span><br>{<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> RefCount { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Retain</span>()</span><br>    {<br>        RefCount++;<br>    }<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Release</span>()</span><br>    {<br>        RefCount--;<br>        <span class="hljs-keyword">if</span> (RefCount == <span class="hljs-number">0</span>){ OnZeroRef(); }<br>    }<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnZeroRef</span>()</span>{}<br>}<br><br></code></pre></td></tr></tbody></table></figure><h3 id="与资源管理结合的引用计数"><a href="#与资源管理结合的引用计数" class="headerlink" title="与资源管理结合的引用计数"></a>与资源管理结合的引用计数</h3><p>资源被使用时引用次数+1，资源解除使用时次数-1，当引用次数为0时则进行卸载逻辑。</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AssetBundleInfo</span><br>{<br>    <span class="hljs-keyword">private</span> AssetBundle m_AssetBundle;   <span class="hljs-comment">//AB包引用</span><br>    <span class="hljs-keyword">public</span> AssetBundle AssetBundle { <span class="hljs-keyword">get</span> { <span class="hljs-keyword">return</span> m_AssetBundle; } }<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> m_ReferencedCount;           <span class="hljs-comment">//引用计数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AssetBundleInfo</span>(<span class="hljs-params">AssetBundle assetBundle</span>)</span><br>    {<br>        m_AssetBundle = assetBundle;<br>        m_ReferencedCount = <span class="hljs-number">1</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="与资源缓冲池结合的加载"><a href="#与资源缓冲池结合的加载" class="headerlink" title="与资源缓冲池结合的加载"></a>与资源缓冲池结合的加载</h3><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AssetBundlePool</span>{<br><span class="hljs-keyword">private</span> Dictionary&lt;<span class="hljs-built_in">string</span>,AssetBundleInfo&gt; m_LoadAssetBundle = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>,AssetBundleInfo&gt;();<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> AssetBundle <span class="hljs-title">LoadAssetsFromAB</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> abName</span>)</span><br>    {<br>        AssetBundleInfo assetBundleInfo = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (m_LoadAssetBundle.TryGetValue(abName, <span class="hljs-keyword">out</span> assetBundleInfo))<br>        {   <span class="hljs-comment">//检查是否加载过</span><br>            assetBundleInfo.m_ReferencedCount++;<span class="hljs-comment">//这里可以使用封装好的引用计数，为了方便展示直接使用</span><br>        }<br>        <span class="hljs-keyword">else</span><br>        {<br>            <span class="hljs-built_in">string</span> loadPath = PathUnit.DataPath + PathUnit.ABRootPath + abName;<br>            <span class="hljs-keyword">var</span> ab = AssetBundle.LoadFromFile(loadPath);<br>            <span class="hljs-keyword">if</span> (ab <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span>)<br>            {<br>                Debug.Log(<span class="hljs-string">"AB包加载失败！"</span>+ loadPath);<br>            }<br>            <span class="hljs-keyword">else</span><br>            {<br>                assetBundleInfo = <span class="hljs-keyword">new</span> AssetBundleInfo(ab);<br>                m_LoadAssetBundle.Add(abName, assetBundleInfo);<br>                <span class="hljs-comment">//assetBundleInfo.m_ReferencedCount++;这里不需要加了因为默认值为1</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> assetBundleInfo.AssetBundle;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>异步加载也是相同的操作，但有点不同。需要一个额外的队列记录加载中的文件。当加载中的文件又收到了加载请求时，则需要在列表中查找是否正在加载。</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AssetBundleCachePool</span><br>{<br>    <span class="hljs-keyword">public</span> MonoBehaviour monoBehaviour;<br>    <span class="hljs-keyword">private</span> Dictionary&lt;<span class="hljs-built_in">string</span>, AssetBundleInfo&gt; m_LoadAssetBundle = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, AssetBundleInfo&gt;();<br>    <span class="hljs-keyword">private</span> Dictionary&lt;<span class="hljs-built_in">string</span>, Action&lt;AssetBundle&gt;&gt; m_LoadingAssetBundle = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, Action&lt;AssetBundle&gt;&gt;();<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LoadAssetsFormAbAsync</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> abName, Action&lt;AssetBundle&gt; loadingABAction</span>)</span><br>    {<br>        monoBehaviour.StartCoroutine(OnLoadAssetsFormAbAsync(abName, loadingABAction));<br>    }<br>    <span class="hljs-function">IEnumerator <span class="hljs-title">OnLoadAssetsFormAbAsync</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> abName, Action&lt;AssetBundle&gt; loadingABAction</span>)</span><br>    {<br>        AssetBundleInfo assetBundleInfo = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (m_LoadAssetBundle.TryGetValue(abName,<span class="hljs-keyword">out</span> assetBundleInfo))<br>        {<br>            Debug.Log(<span class="hljs-string">"已加载过"</span>);<br>            AssetBundle assetBundle = assetBundleInfo.AssetBundle;<br>            <span class="hljs-comment">//引用计数+1</span><br>            assetBundleInfo.m_ReferencedCount++;<br>            <span class="hljs-comment">//触发回调</span><br>            <span class="hljs-keyword">if</span> (loadingABAction != <span class="hljs-literal">null</span>)<br>            {<br>                loadingABAction.Invoke(assetBundle);<br>            }<br>            <span class="hljs-keyword">yield</span> <span class="hljs-keyword">break</span>;<br>        }<br>        <span class="hljs-keyword">else</span><br>        {<br>            <span class="hljs-keyword">if</span> (m_LoadingAssetBundle.TryGetValue(abName,<span class="hljs-keyword">out</span> Action&lt;AssetBundle&gt; temploadingABAction))<br>            {<br>                <span class="hljs-keyword">if</span> (loadingABAction != <span class="hljs-literal">null</span>) { temploadingABAction += loadingABAction; }<br>                Debug.Log(<span class="hljs-string">"正在被加载"</span>);<br>                <span class="hljs-keyword">yield</span> <span class="hljs-keyword">break</span>;<br>            }<br>            <span class="hljs-keyword">else</span><br>            {<br>                <span class="hljs-comment">//这步需要执行，避免与其他逻辑冲突</span><br>                m_LoadingAssetBundle.Add(abName, loadingABAction);<br>                <span class="hljs-built_in">string</span> loadPath = PathUnit.DataPath + PathUnit.ABRootPath + abName;<br>                AssetBundleCreateRequest assetBundleCreateRequest = AssetBundle.LoadFromFileAsync(loadPath);<br>                AssetBundle resAB = assetBundleCreateRequest.assetBundle;<br>                <span class="hljs-keyword">if</span> (resAB <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span>)<br>                {<br>                    Debug.LogError(<span class="hljs-string">"AB包不能存在"</span>);<br>                }<br>                <span class="hljs-keyword">else</span><br>                {<br>                    assetBundleInfo = <span class="hljs-keyword">new</span> AssetBundleInfo(resAB);<br>                    m_LoadAssetBundle.Add(abName, assetBundleInfo);<br>                }<br>                <span class="hljs-comment">//加载完成移除加载中列表</span><br>                <span class="hljs-comment">//避免啥异常状况，保险点！先判断是否存在</span><br>                <span class="hljs-keyword">if</span> (m_LoadingAssetBundle.ContainsKey(abName))<br>                {<br>                    Action&lt;AssetBundle&gt; action = m_LoadingAssetBundle[abName];<br>                    m_LoadingAssetBundle.Remove(abName);<br>                    <span class="hljs-keyword">var</span> callBackList =  action.GetInvocationList();<br>                    <span class="hljs-keyword">foreach</span> (Action&lt;AssetBundle&gt; callBack <span class="hljs-keyword">in</span> callBackList)<br>                    {<br>                        callBack.Invoke(resAB);<br>                    }<br>                }<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="与资源缓冲池结合的卸载"><a href="#与资源缓冲池结合的卸载" class="headerlink" title="与资源缓冲池结合的卸载"></a>与资源缓冲池结合的卸载</h3><p>为了保持<code>平衡</code>有了加载就一定会有卸载。但是在游戏中(特别是手游)卸载操作需要加上一些限制，因为在短时间内进行了大量资源的卸载增加了大量的IO操作也会造成卡顿（线程阻塞）的。🙂</p><p>所以我们的卸载操作需要与数量和时间扯上关系，在一定时间内只卸载一定数量的资源。</p><p>在引用计数中，如果引用计数为0则标记为可以开始卸载了。</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AssetBundleInfo</span>{<br>     <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> ReferencedCount { <br>        <span class="hljs-keyword">get</span> { <span class="hljs-keyword">return</span> m_ReferencedCount; } <br>        <span class="hljs-keyword">set</span> {<br>            m_ReferencedCount = <span class="hljs-keyword">value</span>;<br>            <span class="hljs-keyword">if</span> (m_ReferencedCount&lt;= <span class="hljs-number">0</span>)<br>                IsUnLoadFlag = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span><br>                IsUnLoadFlag = <span class="hljs-literal">false</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> IsUnLoadFlag { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> m_ReferencedCount;           <span class="hljs-comment">//引用计数</span><br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="与时间挂钩"><a href="#与时间挂钩" class="headerlink" title="与时间挂钩"></a>与时间挂钩</h4><p>与时间挂钩就需要有个地方能够一直统计和计算我们的时间并进行回收</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ResourceManager</span>{<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span>{<br>        <br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>本文之前的代码都是没有考虑依赖的，所以如果真的跑起来会发现计数会有偏差。</p><p>一个资源身上用到了别的AB包中的资源，这时候如果只加载自身的AB包，就会出现资源丢失的情况。这时候就需要把当前资源需要用到的依赖包一起加载出来。</p><p>但是我们又要怎么知道这个资源依赖于哪些包？</p><p>这时候就需要用到Unity提供的AB包依赖文件来判断，后缀<code>.manifest·</code>。</p><h2 id="Asset篇"><a href="#Asset篇" class="headerlink" title="Asset篇"></a>Asset篇</h2><h3 id="Asset"><a href="#Asset" class="headerlink" title="Asset"></a>Asset</h3><h4 id="什么是Asst？"><a href="#什么是Asst？" class="headerlink" title="什么是Asst？"></a>什么是Asst？</h4><p><a href="https://blog.uwa4d.com/archives/USparkle_Addressable1.html" target="_blank"></a><a href="https://blog.uwa4d.com/archives/USparkle_Addressable1.html">浅谈Assets——Unity资源映射</a></p><h3 id="Resources-1"><a href="#Resources-1" class="headerlink" title="Resources"></a>Resources</h3><h4 id="什么是Resources？"><a href="#什么是Resources？" class="headerlink" title="什么是Resources？"></a>什么是Resources？</h4><p><a href="https://blog.uwa4d.com/archives/USparkle_Addressable2.html" target="_blank"></a><a href="https://blog.uwa4d.com/archives/USparkle_Addressable2.html">Resources目录的优点与痛点</a></p><h3 id="AssetBundle-1"><a href="#AssetBundle-1" class="headerlink" title="AssetBundle"></a>AssetBundle</h3><h4 id="什么是AssetBundle？"><a href="#什么是AssetBundle？" class="headerlink" title="什么是AssetBundle？"></a>什么是AssetBundle？</h4><p><a href="https://blog.uwa4d.com/archives/USparkle_Addressable3.html" target="_blank"></a><a href="https://blog.uwa4d.com/archives/USparkle_Addressable3.html">AssetBundle的原理及最佳实践 </a></p><h2 id="热更篇"><a href="#热更篇" class="headerlink" title="热更篇"></a>热更篇</h2><p>Todo<span class="github-emoji"><span>💁♀</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f481-2640.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>这部分内容写在别的地方，比较乱后续整理。</p>]]></content>
    
    
    <categories>
      
      <category>资源管理篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>资源管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lua基础语法</title>
    <link href="/2023/01/13/Lua%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/01/13/Lua%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Lua基础语法"><a href="#Lua基础语法" class="headerlink" title="Lua基础语法"></a>Lua基础语法</h1><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul><li>循环用<code>do</code>，if语句用<code>then</code>，都使用<code>end</code>结尾</li><li>Lua不支持自减和自加操作，只能<code>i=i+1</code>，<code>i=i-1</code></li><li>字符串的第一个位置是1不是0</li></ul><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><ul><li>Lua的字符串可以存储<code>0x00</code>，可以用字符串存储二进制流</li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p> 用<code>--</code>开头，来写一段<code>单行注释</code> </p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 单行注释</span><br></code></pre></td></tr></tbody></table></figure><p> 用<code>--[[</code>开头，<code>]]</code>结尾，写一段多行注释。 </p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--[[</span><br><span class="hljs-comment">多行</span><br><span class="hljs-comment">注释</span><br><span class="hljs-comment">]]</span><br></code></pre></td></tr></tbody></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>对一个变量进行赋值就相当于声明变量，与python相似</p><h3 id="声明的变量默认为全局变量"><a href="#声明的变量默认为全局变量" class="headerlink" title="声明的变量默认为全局变量"></a><strong>声明的变量默认为全局变量</strong></h3><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">a=<span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><p>同时给多个变量赋值，多重赋值</p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">a,b=<span class="hljs-number">1</span>,<span class="hljs-number">2</span><br></code></pre></td></tr></tbody></table></figure><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> b=<span class="hljs-number">2</span><br></code></pre></td></tr></tbody></table></figure><h3 id="nil类型"><a href="#nil类型" class="headerlink" title="nil类型"></a>nil类型</h3><p><strong>没有被声明过的变量都是nil</strong></p><p><strong>nil类型只有一个值，就是nil</strong></p><p>nil类似null类型  if(nil)为false</p><h3 id="number类型"><a href="#number类型" class="headerlink" title="number类型"></a>number类型</h3><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--支持十六进制表示方法</span><br>a=<span class="hljs-number">0x11</span><span class="hljs-comment">--输出为17</span><br><span class="hljs-comment">--科学计数法</span><br>a=<span class="hljs-number">2e10</span><br></code></pre></td></tr></tbody></table></figure><h3 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h3><h4 id="单引号、双引号"><a href="#单引号、双引号" class="headerlink" title="单引号、双引号"></a>单引号、双引号</h4><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">a=<span class="hljs-string">"daeqeq"</span><br>b=<span class="hljs-string">'sdarrr'</span><br><span class="hljs-comment">--转义字符\n</span><br>d=<span class="hljs-string">"sdada\nsdar"</span><br></code></pre></td></tr></tbody></table></figure><h4 id="多行文本"><a href="#多行文本" class="headerlink" title="多行文本"></a>多行文本</h4><p>多行文本无法使用转义字符</p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">c=<span class="hljs-string">[[asdasfffrrqweqq]]</span><br></code></pre></td></tr></tbody></table></figure><h4 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h4><p>字符串连接符号<code>..</code></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">a=<span class="hljs-string">"daeqeq"</span><br>b=<span class="hljs-string">'sdarrr'</span><br>c=a..b<br><span class="hljs-built_in">print</span>(<span class="hljs-string">"asdaf"</span>..<span class="hljs-string">"as232"</span>)<br></code></pre></td></tr></tbody></table></figure><h4 id="数值转字符串"><a href="#数值转字符串" class="headerlink" title="数值转字符串"></a>数值转字符串</h4><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">tostring</span>(<span class="hljs-number">10</span>)<br></code></pre></td></tr></tbody></table></figure><h4 id="字符串转数值"><a href="#字符串转数值" class="headerlink" title="字符串转数值"></a>字符串转数值</h4><p><code>tonumber</code>转换失败为nil</p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">tonumber</span>(<span class="hljs-string">"193"</span>)<br></code></pre></td></tr></tbody></table></figure><h4 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h4><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">a=<span class="hljs-string">"daeqeq"</span><br><span class="hljs-built_in">print</span>(#a)<br><span class="hljs-comment">--等价于s:len()</span><br></code></pre></td></tr></tbody></table></figure><h4 id="string类型类似char数组"><a href="#string类型类似char数组" class="headerlink" title="string类型类似char数组"></a>string类型类似char数组</h4><p>Lua中string类型 类似于C里的字符数组，可以包含任意数值包括0x00，可以存储二进制流因为都是原原本本存储</p><h5 id="将ascii码转为字符串"><a href="#将ascii码转为字符串" class="headerlink" title="将ascii码转为字符串"></a>将ascii码转为字符串</h5><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">s=<span class="hljs-built_in">string</span>.<span class="hljs-built_in">char</span>(<span class="hljs-number">65</span>)<br>s=<span class="hljs-built_in">string</span>.<span class="hljs-built_in">char</span>(<span class="hljs-number">0x30</span>,<span class="hljs-number">0x31</span>,<span class="hljs-number">0x32</span>,<span class="hljs-number">0x33</span>)<br></code></pre></td></tr></tbody></table></figure><h5 id="取出string中的某一位的ascii码"><a href="#取出string中的某一位的ascii码" class="headerlink" title="取出string中的某一位的ascii码"></a>取出string中的某一位的ascii码</h5><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">n=<span class="hljs-built_in">string</span>.<span class="hljs-built_in">byte</span>(s,<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(n)<br><span class="hljs-comment">--语法糖，第一个到最后一个</span><br>s:<span class="hljs-built_in">byte</span>(<span class="hljs-number">1</span>，<span class="hljs-number">-1</span>)<br></code></pre></td></tr></tbody></table></figure><h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><p>调用c的接口</p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> f=<span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">"%d,%d"</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(f)<br></code></pre></td></tr></tbody></table></figure><h2 id="function函数"><a href="#function函数" class="headerlink" title="function函数"></a>function函数</h2><p>函数默认返回值为nil，没有任何返回值则为nil</p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">function_name</span><span class="hljs-params">()</span></span><br><span class="hljs-comment">--body</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">--函数名放前面</span><br>f=<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(...)</span></span><br>    <span class="hljs-comment">--body</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">(a,b,c)</span></span><br>    <span class="hljs-built_in">print</span>(a,b,c)<br>    <span class="hljs-keyword">return</span> a<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">--c没有传值则为nil</span><br><span class="hljs-built_in">print</span>(f(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>))<span class="hljs-comment">--1</span><br></code></pre></td></tr></tbody></table></figure><h3 id="函数可以返回多个值"><a href="#函数可以返回多个值" class="headerlink" title="函数可以返回多个值"></a>函数可以返回多个值</h3><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">(a,b,c)</span></span><br>    <span class="hljs-keyword">return</span> a,b<br><span class="hljs-keyword">end</span><br><br><span class="hljs-built_in">print</span>(f(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>))<br></code></pre></td></tr></tbody></table></figure><h4 id="多个返回值可以使用多重赋值语句"><a href="#多个返回值可以使用多重赋值语句" class="headerlink" title="多个返回值可以使用多重赋值语句"></a>多个返回值可以使用多重赋值语句</h4><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">(a,b,c)</span></span><br>    <span class="hljs-keyword">return</span> a,b<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> i,j=f(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br></code></pre></td></tr></tbody></table></figure><h2 id="table"><a href="#table" class="headerlink" title="table"></a>table</h2><h3 id="table接口"><a href="#table接口" class="headerlink" title="table接口"></a>table接口</h3><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span>(a,<span class="hljs-string">"d"</span>)<span class="hljs-comment">--插入元素，末尾添加</span><br><span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span>(a,<span class="hljs-number">2</span>,<span class="hljs-string">"d"</span>)<span class="hljs-comment">--插入元素，第二个位置，后续元素后移</span><br><span class="hljs-keyword">local</span> s= <span class="hljs-built_in">table</span>.<span class="hljs-built_in">remove</span>(a,<span class="hljs-number">2</span>)<span class="hljs-comment">--移除第2个元素</span><br></code></pre></td></tr></tbody></table></figure><h3 id="table数字下标"><a href="#table数字下标" class="headerlink" title="table数字下标"></a>table数字下标</h3><p>可以存所有东西(number,string,table,function)</p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">a={<span class="hljs-number">1</span>,<span class="hljs-string">"ac"</span>,{},<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">end</span>}<br>a[<span class="hljs-number">5</span>]=<span class="hljs-number">123</span> <span class="hljs-comment">--可以直接添加一个元素</span><br><span class="hljs-built_in">print</span>(a[<span class="hljs-number">1</span>])<br><span class="hljs-comment">--获取table长度</span><br><span class="hljs-built_in">print</span>(#a)<br></code></pre></td></tr></tbody></table></figure><h3 id="table字符串下标"><a href="#table字符串下标" class="headerlink" title="table字符串下标"></a>table字符串下标</h3><p>以字符为table的下标</p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua">a={<br>    a=<span class="hljs-number">1</span>,<br>    b=<span class="hljs-string">"1234"</span>,<br>    c=<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>        <span class="hljs-keyword">end</span>,<br>    d=<span class="hljs-number">123123</span><br>}<br><span class="hljs-built_in">print</span>(a[<span class="hljs-string">"a"</span>])<br><span class="hljs-comment">--下标符合变量命名规范时</span><br><span class="hljs-built_in">print</span>(a.a)<br></code></pre></td></tr></tbody></table></figure><h3 id="全局表-G"><a href="#全局表-G" class="headerlink" title="全局表_G"></a>全局表_G</h3><p><strong>Lua内的所有全局变量都在_G这个table内</strong></p><p>包括<code>table.insert</code>中的table(也是全局变量)也存储在_G中，insert为table的下标</p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">_G</span>[<span class="hljs-string">"table"</span>][<span class="hljs-string">"insert"</span>])<br><span class="hljs-comment">--function: 0000000063be4590</span><br><span class="hljs-comment">--输出值为一个函数</span><br><span class="hljs-comment">--多文件调用知识</span><br></code></pre></td></tr></tbody></table></figure><h2 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h2><h3 id="不等于"><a href="#不等于" class="headerlink" title="不等于"></a>不等于</h3><p><strong>在Lua中不等于使用<code>~=</code>表示</strong></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua">a=<span class="hljs-literal">true</span><br>b=<span class="hljs-literal">false</span><br><span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>&gt;<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>&lt;<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>&gt;=<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>&lt;=<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>==<span class="hljs-number">2</span>)<br><span class="hljs-comment">--不等于</span><br><span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>~=<span class="hljs-number">2</span>)<br></code></pre></td></tr></tbody></table></figure><h3 id="与或非"><a href="#与或非" class="headerlink" title="与或非"></a>与或非</h3><h3 id="只有false和nil表示假"><a href="#只有false和nil表示假" class="headerlink" title="只有false和nil表示假"></a>只有false和nil表示假</h3><p>其他都表示真，包括0</p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(a <span class="hljs-keyword">and</span> b)<br><span class="hljs-built_in">print</span>(a <span class="hljs-keyword">or</span> b)<br><span class="hljs-built_in">print</span>(<span class="hljs-keyword">not</span> a)<br></code></pre></td></tr></tbody></table></figure><p><strong><code>and``or</code>返回的并不完全是true和false，会直接返回a或者b的值，可以通过短路求值</strong></p><p>只有<code>not</code>返回true和false</p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua">a=<span class="hljs-literal">nil</span> <span class="hljs-comment">--真</span><br>b=<span class="hljs-number">0</span>  <span class="hljs-comment">--假</span><br><span class="hljs-built_in">print</span>(a <span class="hljs-keyword">and</span> b) <span class="hljs-comment">--nil</span><br><span class="hljs-built_in">print</span>(a <span class="hljs-keyword">or</span> b)  <span class="hljs-comment">--0</span><br><span class="hljs-built_in">print</span>(<span class="hljs-keyword">not</span> a)   <span class="hljs-comment">--true</span><br><span class="hljs-built_in">print</span>(b&gt;<span class="hljs-number">10</span> <span class="hljs-keyword">and</span> <span class="hljs-string">"yes"</span> <span class="hljs-keyword">or</span> <span class="hljs-string">"no"</span>) <span class="hljs-comment">--no</span><br></code></pre></td></tr></tbody></table></figure><h2 id="分支判断"><a href="#分支判断" class="headerlink" title="分支判断"></a>分支判断</h2><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> <span class="hljs-number">1</span>&gt;<span class="hljs-number">10</span> <span class="hljs-keyword">then</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">"1&gt;10"</span>)<br><span class="hljs-keyword">elseif</span> <span class="hljs-number">1</span>&lt;<span class="hljs-number">10</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"1&lt;10"</span>)<br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"no"</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></tbody></table></figure><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">10</span> <span class="hljs-keyword">do</span><br><span class="hljs-built_in">print</span>(i)<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">--步长为2</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">2</span> <span class="hljs-keyword">do</span><br><span class="hljs-built_in">print</span>(i)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></tbody></table></figure><h4 id="倒序循环"><a href="#倒序循环" class="headerlink" title="倒序循环"></a>倒序循环</h4><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">for</span> i=<span class="hljs-number">10</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span> <span class="hljs-keyword">do</span><br><span class="hljs-built_in">print</span>(i)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></tbody></table></figure><p><code>i</code>在过程途中不能赋值，赋值了也没用</p><p>假如对<code>i</code>赋值会被认定为新建了局部变量</p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">for</span> i=<span class="hljs-number">10</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span> <span class="hljs-keyword">do</span><br><span class="hljs-built_in">print</span>(i)<br><span class="hljs-keyword">local</span> i=<span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></tbody></table></figure><h4 id="break"><a href="#break" class="headerlink" title="break"></a>break</h4><p>通过break退出循环</p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">for</span> i=<span class="hljs-number">10</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span> <span class="hljs-keyword">do</span><br><span class="hljs-built_in">print</span>(i)<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">5</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">break</span> <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></tbody></table></figure><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">n = <span class="hljs-number">10</span><br><span class="hljs-keyword">while</span> n&gt;<span class="hljs-number">1</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(n)<br>    n = n - <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></tbody></table></figure><h3 id="repeat循环"><a href="#repeat循环" class="headerlink" title="repeat循环"></a>repeat循环</h3><p>和while循环基本一致</p><h2 id="多文件调用"><a href="#多文件调用" class="headerlink" title="多文件调用"></a>多文件调用</h2><h3 id="require和import的区别"><a href="#require和import的区别" class="headerlink" title="require和import的区别"></a>require和import的区别</h3><h4 id="require实现"><a href="#require实现" class="headerlink" title="require实现"></a>require实现</h4><p>换个目录后就需要对路径进行变更</p><p>个人理解：绝对路径</p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> MyClassBase = <span class="hljs-built_in">require</span>(<span class="hljs-string">"app.classes.MyClassBase"</span>)<br><span class="hljs-keyword">local</span> MyClass = class(<span class="hljs-string">"MyClass"</span>, MyClassBase)<br><br><span class="hljs-keyword">local</span> Data1 = <span class="hljs-built_in">require</span>(<span class="hljs-string">"app.classes.data.Data1"</span>)<br><span class="hljs-keyword">local</span> Data2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">"app.classes.data.Data2"</span>)<br></code></pre></td></tr></tbody></table></figure><h4 id="import实现"><a href="#import实现" class="headerlink" title="import实现"></a>import实现</h4><p>在模块名前添加多个”.” ，这样 import() 会从更上层的目录开始查找模块。</p><p>个人理解：相对路径</p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> MyClassBase = import(<span class="hljs-string">".MyClassBase"</span>)<br><span class="hljs-keyword">local</span> MyClass = class(<span class="hljs-string">"MyClass"</span>, MyClassBase)<br><br><span class="hljs-keyword">local</span> Data1 = import(<span class="hljs-string">".data.Data1"</span>)<br><span class="hljs-keyword">local</span> Data2 = import(<span class="hljs-string">".data.Data2"</span>)<br></code></pre></td></tr></tbody></table></figure><h3 id="require"><a href="#require" class="headerlink" title="require"></a>require</h3><p>运行指定多文件</p><p>末尾不带扩展名</p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--.\?lua   把文件名匹配到？内</span><br><span class="hljs-built_in">require</span>(<span class="hljs-string">"文件名"</span>)<br></code></pre></td></tr></tbody></table></figure><p>不同层架文件夹用<code>.</code>分隔</p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">require</span>(<span class="hljs-string">"文件夹名.文件名"</span>)<br></code></pre></td></tr></tbody></table></figure><p>只会运行一次</p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--lua文件有可以return返回值</span><br><span class="hljs-keyword">local</span> r = <span class="hljs-built_in">require</span>(<span class="hljs-string">'hello'</span>)<br><span class="hljs-comment">--后面调用的都是前面返回的内容</span><br><span class="hljs-built_in">require</span>(<span class="hljs-string">'hello'</span>)<br><span class="hljs-built_in">require</span>(<span class="hljs-string">'hello'</span>)<br><span class="hljs-built_in">require</span>(<span class="hljs-string">'hello'</span>)<br><span class="hljs-built_in">require</span>(<span class="hljs-string">'hello'</span>)<br><span class="hljs-built_in">print</span>(r)<br></code></pre></td></tr></tbody></table></figure><h3 id="package-path"><a href="#package-path" class="headerlink" title="package.path"></a>package.path</h3><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">package</span>.<span class="hljs-built_in">path</span>=<span class="hljs-built_in">package</span>.<span class="hljs-built_in">path</span>..<span class="hljs-string">";./path/?.lua"</span><br><span class="hljs-built_in">require</span>(<span class="hljs-string">'hello2'</span>)<br></code></pre></td></tr></tbody></table></figure><h3 id="多次调用"><a href="#多次调用" class="headerlink" title="多次调用"></a>多次调用</h3><p>调用lua文件内的函数</p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--hello.lua</span><br><span class="hljs-keyword">local</span> hello={}<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello.say</span><span class="hljs-params">()</span></span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"hello world"</span>)<br><span class="hljs-keyword">end</span><br>//通过返回<span class="hljs-built_in">table</span><br><span class="hljs-keyword">return</span> hello<br><br><span class="hljs-comment">--test.lua</span><br><span class="hljs-keyword">local</span> test=<span class="hljs-built_in">require</span>(<span class="hljs-string">'hello'</span>)<br>//通过<span class="hljs-built_in">table</span>内的方法调用<br>test.say()<br></code></pre></td></tr></tbody></table></figure><h2 id="迭代table"><a href="#迭代table" class="headerlink" title="迭代table"></a>迭代table</h2><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">t={<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>,<span class="hljs-string">"c"</span>,<span class="hljs-string">"d"</span>}<br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,#t,<span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(i,t[i])<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></tbody></table></figure><h3 id="迭代器ipairs"><a href="#迭代器ipairs" class="headerlink" title="迭代器ipairs"></a>迭代器ipairs</h3><p>纯数字连续下标可以用</p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">t={<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>,<span class="hljs-string">"c"</span>,<span class="hljs-string">"d"</span>}<br><span class="hljs-comment">--下标给i，值给j</span><br><span class="hljs-keyword">for</span> i,j <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(t) <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(i,j)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua">t={<br>[<span class="hljs-number">1</span>]=<span class="hljs-string">"a"</span>,<br>[<span class="hljs-number">2</span>]=<span class="hljs-string">"b"</span>,<br>[<span class="hljs-number">3</span>]=<span class="hljs-string">"c"</span>,<br>[<span class="hljs-number">5</span>]=<span class="hljs-string">"d"</span><br>}<br><span class="hljs-comment">--下标给i，值给j</span><br><span class="hljs-keyword">for</span> i,j <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(t) <span class="hljs-keyword">do</span><br><span class="hljs-comment">--只能遍历到1到3，不连续的后面遍历不到</span><br>    <span class="hljs-built_in">print</span>(i,j)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></tbody></table></figure><h3 id="迭代器pairs"><a href="#迭代器pairs" class="headerlink" title="迭代器pairs"></a>迭代器pairs</h3><p>可以遍历所有下标</p><p>pairs内部调用的是<code>next</code>函数</p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua">t={<br>[<span class="hljs-number">1</span>]=<span class="hljs-string">"a"</span>,<br>[<span class="hljs-number">2</span>]=<span class="hljs-string">"b"</span>,<br>[<span class="hljs-number">3</span>]=<span class="hljs-string">"c"</span>,<br>[<span class="hljs-number">5</span>]=<span class="hljs-string">"d"</span><br>}<br><span class="hljs-comment">--下标给i，值给j</span><br><span class="hljs-keyword">for</span> i,j <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(t) <span class="hljs-keyword">do</span><br><span class="hljs-comment">--只能遍历到1到3，不连续的后面遍历不到</span><br>    <span class="hljs-built_in">print</span>(i,j)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua">t={<br>apple=<span class="hljs-string">"a"</span>,<br>banana=<span class="hljs-string">"b"</span>,<br>eraser=<span class="hljs-string">"c"</span>,<br>water=<span class="hljs-string">"d"</span><br>}<br><span class="hljs-comment">--下标给i，值给j</span><br><span class="hljs-keyword">for</span> i,j <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(t) <span class="hljs-keyword">do</span><br><span class="hljs-comment">--只能遍历到1到3，不连续的后面遍历不到</span><br>    <span class="hljs-built_in">print</span>(i,j)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></tbody></table></figure><h2 id="元表、元方法"><a href="#元表、元方法" class="headerlink" title="元表、元方法"></a>元表、元方法</h2><h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua">t={<br>a=<span class="hljs-number">0</span>,<br>add=<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(tab,num)</span></span><br>tab.a=tab.a+num<br><span class="hljs-keyword">end</span><br>}<br><span class="hljs-comment">--类似于面向对象的方法调用</span><br>t:add(<span class="hljs-number">10</span>)<span class="hljs-comment">--等价于t.add(t,10)</span><br></code></pre></td></tr></tbody></table></figure><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--对象名</span><br>bag={}<br><br>bagmt={<br>    <span class="hljs-comment">--装入东西的函数</span><br>    put=<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(t,item)</span></span><br>        <span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span>(t.items,item)<br>        <span class="hljs-keyword">end</span>,<br>    take=<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(t)</span></span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">table</span>.<span class="hljs-built_in">remove</span>(t)<br>     <span class="hljs-keyword">end</span>,<br>    list=<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(t)</span></span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">table</span>.<span class="hljs-built_in">concat</span>(t.items,<span class="hljs-string">","</span>)<br>         <span class="hljs-keyword">end</span><br>}<br>bagmt[<span class="hljs-string">"__index"</span>]=bagmt<br><span class="hljs-comment">--构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bag.new</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">local</span> t={<br>        items={}<br>    }<br>    <span class="hljs-built_in">setmetatable</span>(t,bagmt)<br>    <span class="hljs-keyword">return</span> t<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></tbody></table></figure><h2 id="协程coroutine"><a href="#协程coroutine" class="headerlink" title="协程coroutine"></a>协程coroutine</h2><p>一个lua虚拟机里只能有一个线程</p><h3 id="coroutine-create-可创建一个协程"><a href="#coroutine-create-可创建一个协程" class="headerlink" title="coroutine.create 可创建一个协程"></a>coroutine.create 可创建一个协程</h3><p>返回值为 <code>thread </code>类型</p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> co=<span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">create</span>(<br>    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">"hello world!"</span>)<br>    <span class="hljs-keyword">end</span><br>    )<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lua</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
